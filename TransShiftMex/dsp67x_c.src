!<arch>
<filenames>/    0           1     0     0       3496      `

DSPF_sp_autocor.c/
DSPF_sp_bitrev_cplx.c/
DSPF_sp_cfftr4_dif.c/
DSPF_sp_cfftr2_dit.c/
DSPF_sp_fftSPxSP.c/
DSPF_sp_ifftSPxSP.c/
DSPF_sp_icfftr2_dif.c/
DSPF_sp_fir_cplx.c/
DSPF_sp_fir_gen.c/
DSPF_sp_fir_r2.c/
DSPF_sp_fircirc.c/
DSPF_sp_biquad.c/
DSPF_sp_iirlat.c/
DSPF_sp_convol.c/
DSPF_sp_dotp_sqr.c/
DSPF_sp_dotprod.c/
DSPF_sp_dotp_cplx.c/
DSPF_sp_maxval.c/
DSPF_sp_maxidx.c/
DSPF_sp_minval.c/
DSPF_sp_vecrecip.c/
DSPF_sp_vecsum_sq.c/
DSPF_sp_vecmul.c/
DSPF_sp_mat_mul.c/
DSPF_sp_mat_trans.c/
DSPF_sp_mat_mul_cplx.c/
DSPF_sp_blk_move.c/
DSPF_blk_eswap16.c/
DSPF_blk_eswap32.c/
DSPF_blk_eswap64.c/
DSPF_sp_minerr.c/
DSPF_dp_autocor.c/
DSPF_dp_bitrev_cplx.c/
DSPF_dp_cfftr4_dif.c/
DSPF_dp_cfftr2.c/
DSPF_dp_icfftr2.c/
DSPF_dp_fir_cplx.c/
DSPF_dp_fir_gen.c/
DSPF_dp_fir_r2.c/
DSPF_dp_fircirc.c/
DSPF_dp_biquad.c/
DSPF_dp_iirlat.c/
DSPF_dp_convol.c/
DSPF_dp_dotp_sqr.c/
DSPF_dp_dotprod.c/
DSPF_dp_dotp_cplx.c/
DSPF_dp_maxval.c/
DSPF_dp_maxidx.c/
DSPF_dp_minval.c/
DSPF_dp_vecrecip.c/
DSPF_dp_vecsum_sq.c/
DSPF_dp_vecmul.c/
DSPF_dp_mat_mul.c/
DSPF_dp_mat_trans.c/
DSPF_dp_mat_mul_cplx.c/
DSPF_dp_blk_move.c/
DSPF_sp_autocor.h/
DSPF_sp_autocor.h67/
DSPF_sp_bitrev_cplx.h/
DSPF_sp_bitrev_cplx.h67/
DSPF_sp_cfftr4_dif.h/
DSPF_sp_cfftr4_dif.h67/
DSPF_sp_cfftr2_dit.h/
DSPF_sp_cfftr2_dit.h67/
DSPF_sp_fftSPxSP.h/
DSPF_sp_fftSPxSP.h67/
DSPF_sp_ifftSPxSP.h/
DSPF_sp_ifftSPxSP.h67/
DSPF_sp_icfftr2_dif.h/
DSPF_sp_icfftr2_dif.h67/
DSPF_sp_fir_cplx.h/
DSPF_sp_fir_cplx.h67/
DSPF_sp_fir_gen.h/
DSPF_sp_fir_gen.h67/
DSPF_sp_fir_r2.h/
DSPF_sp_fir_r2.h67/
DSPF_sp_fircirc.h/
DSPF_sp_fircirc.h67/
DSPF_sp_biquad.h/
DSPF_sp_biquad.h67/
DSPF_sp_iirlat.h/
DSPF_sp_iirlat.h67/
DSPF_sp_convol.h/
DSPF_sp_convol.h67/
DSPF_sp_dotp_sqr.h/
DSPF_sp_dotp_sqr.h67/
DSPF_sp_dotprod.h/
DSPF_sp_dotprod.h67/
DSPF_sp_dotp_cplx.h/
DSPF_sp_dotp_cplx.h67/
DSPF_sp_maxval.h/
DSPF_sp_maxval.h67/
DSPF_sp_maxidx.h/
DSPF_sp_maxidx.h67/
DSPF_sp_minval.h/
DSPF_sp_minval.h67/
DSPF_sp_vecrecip.h/
DSPF_sp_vecrecip.h67/
DSPF_sp_vecsum_sq.h/
DSPF_sp_vecsum_sq.h67/
DSPF_sp_w_vec.h67/
DSPF_sp_vecmul.h/
DSPF_sp_vecmul.h67/
DSPF_sp_mat_mul.h/
DSPF_sp_mat_mul.h67/
DSPF_sp_mat_trans.h/
DSPF_sp_mat_trans.h67/
DSPF_sp_mat_mul_cplx.h/
DSPF_sp_mat_mul_cplx.h67/
DSPF_sp_blk_move.h/
DSPF_sp_blk_move.h67/
DSPF_blk_eswap16.h/
DSPF_blk_eswap16.h67/
DSPF_blk_eswap32.h/
DSPF_blk_eswap32.h67/
DSPF_blk_eswap64.h/
DSPF_blk_eswap64.h67/
DSPF_fltoq15.h67/
DSPF_sp_minerr.h/
DSPF_sp_minerr.h67/
DSPF_q15tofl.h67/
DSPF_dp_autocor.h/
DSPF_dp_autocor.h67/
DSPF_dp_bitrev_cplx.h/
DSPF_dp_bitrev_cplx.h67/
DSPF_dp_cfftr4_dif.h/
DSPF_dp_cfftr4_dif.h67/
DSPF_dp_cfftr2.h/
DSPF_dp_cfftr2.h67/
DSPF_dp_icfftr2.h/
DSPF_dp_icfftr2.h67/
DSPF_dp_fir_cplx.h/
DSPF_dp_fir_cplx.h67/
DSPF_dp_fir_gen.h/
DSPF_dp_fir_gen.h67/
DSPF_dp_fir_r2.h/
DSPF_dp_fir_r2.h67/
DSPF_dp_fircirc.h/
DSPF_dp_fircirc.h67/
DSPF_dp_biquad.h/
DSPF_dp_biquad.h67/
DSPF_dp_iirlat.h/
DSPF_dp_iirlat.h67/
DSPF_dp_convol.h/
DSPF_dp_convol.h67/
DSPF_dp_dotp_sqr.h/
DSPF_dp_dotp_sqr.h67/
DSPF_dp_dotprod.h/
DSPF_dp_dotprod.h67/
DSPF_dp_dotp_cplx.h/
DSPF_dp_dotp_cplx.h67/
DSPF_dp_maxval.h/
DSPF_dp_maxval.h67/
DSPF_dp_maxidx.h/
DSPF_dp_maxidx.h67/
DSPF_dp_minval.h/
DSPF_dp_minval.h67/
DSPF_dp_vecrecip.h/
DSPF_dp_vecrecip.h67/
DSPF_dp_vecsum_sq.h/
DSPF_dp_vecsum_sq.h67/
DSPF_dp_w_vec.h67/
DSPF_dp_vecmul.h/
DSPF_dp_vecmul.h67/
DSPF_dp_mat_mul.h/
DSPF_dp_mat_mul.h67/
DSPF_dp_mat_trans.h/
DSPF_dp_mat_trans.h67/
DSPF_dp_mat_mul_cplx.h/
DSPF_dp_mat_mul_cplx.h67/
DSPF_dp_blk_move.h/
DSPF_dp_blk_move.h67/
DSPF_sp_lms.c/  1117057335  0     0     0       5965      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      );                                                                  */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       */
/*      input signal and a desired input signal, the filter produces an     */
/*      output signal, the final coefficient values, and returns the final  */
/*      output error signal.                                                */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_lms,    ".text:ansi");

#include "DSPF_sp_lms.h"

/* ======================================================================== */
/* ======================================================================== */

float DSPF_sp_lms(float    * x, float * h, float * desired, float * r, float adaptrate, float error, int nh, int nr)
{

/* ======================================================================== */
/* ======================================================================== */
    int i,j;

    float sum, temp, ae;
    /* --------------------------------------------------------------------------*/
    /* To avoid invalid memory access make input x zero at the start             */
    /* --------------------------------------------------------------------------*/
    temp = 0.0f;

    for (i = 0; i < nr; i++)
    {
        sum = 0.0f;

        /* ------------------------------- */
        /* Eliminate common sub-expression */
        /* ------------------------------- */
        ae = adaptrate * error;

        for (j = 0; j < nh; j++)
        {

        /* --------------------------------------------------- */
        /* adapt the coeffs using current error and prev input */
        /* --------------------------------------------------- */
            h[j] = h[j] + (ae * temp);

        /* ----------------------------------------------------*/
        /* Calculate the output based on the updated coeffs    */
        /* ----------------------------------------------------*/
            sum += h[j] * x[i+j];

            temp = x[i + j];

        }

        r[i] = sum;

        error = desired[i] - sum;

        /* --------------------------------*/
        /* Update temp for next outer loop */
        /* --------------------------------*/
        temp = x[i];

   }

   /* return the final error */
   return error;

}

/* ======================================================================== */
/*  End of file: DSPF_sp_lms.c                                                   */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_autocor/1117057336  1     0     0       4402      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_autocor -- Single Precision autocorrelation                      */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_autocor                                                    */

/*                     (                                                    */

/*                         float       *  restrict r,                       */

/*                         const short *  restrict x,                       */

/*                         int            nx,                               */

/*                         int            nr                                */

/*                     )                                                    */

/*            r  = pointer to output array of autocorrelation of length nr  */

/*            x  = pointer to input array of length nx+nr. Input data must  */

/*                 be padded with nr consecutive zeros at the beginning.    */

/*            nx = Length of Autocorrelation vector.                        */

/*            nr = Length of lags.                                          */

/*                                                                          */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This routine performs the autocorrelation of the input array inp.  */

/*       It is assumed that the length of the input array, x, is a multiple */

/*       of 2 and the length of the output array, r, is a multiple of 4.    */

/*       The assembly routine computes 4 output samples at a time.          */

/*                                                                          */

/*       It is assumed that input vector x is padded with nr no of zeros in */

/*       the beginning.                                                     */

/*                                                                          */

/*       x is to be aligned on a double word boundary.                      */

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_autocor,    ".text:ansi");



#include "DSPF_sp_autocor.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_autocor(float    *restrict r, float *restrict x, int nx, int nr)

{



/* ======================================================================== */

/* ======================================================================== */

    int i,k;

    float sum;



    for (i = 0; i < nr; i++)

    {

        sum = 0;

        for (k = nr; k < nx+nr; k++)

        {

            sum += x[k] * x[k-i];

        }

        r[i] = sum ;

    }



}



/* ======================================================================== */

/*  End of file: DSPF_sp_autocor.c                                               */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_bitrev_/1117057337  20    0     0       8664      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         */

/*      numbers                                                             */

/*                                                                          */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*     This routine is C Callable and can be called as:                     */

/*                                                                          */

/*     void bitrev_cplx(double *x, short *index, int nx);                   */

/*                                                                          */

/*     x[nx]  : Complex input array to be bit-reversed.                     */

/*              Contains 2*nx floats                                        */

/*     index[]: Array of size ~sqrt(nx) created by the routine              */

/*              bitrev_index to allow the fast implementation of the        */

/*              bit-reversal.                                               */

/*     nx     : Number of elements in array x[]. Must be power of 2.        */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*     This routine performs the bit-reversal of the input array x[],       */

/*     where x[] is an integer array of length nx containing 16-bit         */

/*     complex pairs of data.  This routine requires the index array        */

/*     provided by the program below.  This index should be generated at    */

/*     compile time not by the DSP.                                         */

/*                                                                          */

/*     TI retains all rights, title and interest in this code and only      */

/*     authorizes the use of the bit-reversal code and related table        */

/*     generation code with TMS320-family DSPs manufactured by TI.          */

/*                                                                          */

/*     // ----------------------------------------------------------- //    */

/*     //  This routine calculates the index for bit reversal of      //    */

/*     //  an array of length nx.  The length of the index table is   //    */

/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */

/*     //                                                             //    */

/*     //  In other words, the length of the index table is:          //    */

/*     //      - for even power of radix: sqrt(nx)                    //    */

/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */

/*     // ----------------------------------------------------------- //    */

/*     void bitrev_index(short *index, int nx)                              */

/*     {                                                                    */

/*         int   i, j, k, radix = 2;                                        */

/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */

/*                                                                          */

/*         nbits = 0;                                                       */

/*         i = nx;                                                          */

/*         while (i > 1)                                                    */

/*         {                                                                */

/*             i = i >> 1;                                                  */

/*             nbits++;                                                     */

/*         }                                                                */

/*                                                                          */

/*         raddiv2 = radix >> 1;                                            */

/*         nbot    = nbits >> raddiv2;                                      */

/*         nbot    = nbot << raddiv2 - 1;                                   */

/*         ndiff   = nbits & raddiv2;                                       */

/*         ntop    = nbot + ndiff;                                          */

/*         n2      = 1 << ntop;                                             */

/*                                                                          */

/*         index[0] = 0;                                                    */

/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */

/*         {                                                                */

/*             index[i] = j - 1;                                            */

/*                                                                          */

/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */

/*                 j -= k*(radix-1);                                        */

/*                                                                          */

/*             j += k;                                                      */

/*         }                                                                */

/*         index[n2 - 1] = n2 - 1;                                          */

/*     }                                                                    */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_bitrev_cplx,    ".text:ansi");



#include "DSPF_sp_bitrev_cplx.h"



void DSPF_sp_bitrev_cplx(double    * x, short * index, int n)

{



        int    i;

        short  i0, i1, i3;

        short  j0, j1, j3;

        double xi0, xi1, xi3;

        double xj0, xj1, xj3;

        short  t;

        int    a, b, ia, ib, ibs;

        int    mask;

        int    nbits, nbot, ntop, ndiff, n2, halfn;

        

        nbits = 0;

        i = n;

        while (i > 1)

        {

           i = i >> 1;

           nbits++;

        }

        

        nbot    = nbits >> 1;

        ndiff   = nbits & 1;

        ntop    = nbot + ndiff;

        n2      = 1 << ntop;

        mask    = n2 - 1;

        halfn   = n >> 1;

        

        for (i0 = 0; i0 < halfn; i0 += 2)

        {

            b       = i0 & mask;

            a       = i0 >> nbot;

            if (!b) ia = index[a];

            ib      = index[b];

            ibs     = ib << nbot;

        

            j0      = ibs + ia;

            t       = i0 < j0;

            xi0     = x[i0];

            xj0     = x[j0];

        

            if (t)

            {

              x[i0] = xj0;

              x[j0] = xi0;

            }

        

            i1      = i0 + 1;

            j1      = j0 + halfn;

            xi1     = x[i1];

            xj1     = x[j1];

            x[i1] = xj1;

            x[j1] = xi1;

        

            i3      = i1 + halfn;

            j3      = j1 + 1;

            xi3     = x[i3];

            xj3     = x[j3];

            if (t)

            {

              x[i3] = xj3;

              x[j3] = xi3;

            }

          }





}



/* ======================================================================== */

/*  End of file: DSPF_sp_bitrev_cplx.c                                           */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_cfftr4_/1117057338  43    0     0       9350      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      */

/*                                                                          */

/*  USAGE                                                                 */

/*                                                                          */

/*  This routine is C Callable and can be called as:                        */

/*                                                                        */

/*  void cfftr4_dif(float* x, float* w, short n)                          */

/*                                                                          */

/*  x is pointer to an array holding the input and output floating        */

/*     point array which contains 'n' complex points                      */

/*  w is pointer to an array holding the coefficient floating point       */

/*     array which contains 3*n/4 complex numbers                         */

/*  n is the number of complex points in x                                */

/*                                                                          */

/*  If the routine is not to be used as a C callable function,            */

/*  then you need to initialize values for all of the parameters          */

/*  passed to the function since these are assumed to be in               */

/*  registers as defined by the calling convention of the                 */

/*  compiler, (refer to the TMS320C6x Optimizing C Compiler               */

/*  User's Guide).                                                        */

/*                                                                          */

/*                                                                          */

/*  DESCRIPTION                                                            */

/*                                                                          */

/*  This routine implements the DIF (decimation in frequency)             */

/*  complex radix 4 FFT with digit-reversed output and normal             */

/*  order input.  The number of points, 'n', must be a power              */

/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                 */

/*  in-place routine in the sense that the output is written              */

/*  over the input.  It is not an in-place routine in the                 */

/*  sense that the input is in normal order and the output is             */

/*  in digit-reversed order.                                              */

/*                                                                          */

/*  There must be n complex points (2*n values), and 3*n/4 complex        */

/*  coefficients (3*n/2 values).                                          */

/*                                                                          */

/*  Each real and imaginary input value is interleaved in the             */

/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers           */

/*  are in normal order.  Each real and imaginary output value            */

/*  is interleaved in the 'x' array and the complex numbers are           */

/*  in digit-reversed  order {rx0, ix0, ...}.  The real and               */

/*  imaginary values of the coefficients are interleaved in the           */

/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers         */

/*  are in normal order.                                                  */

/*                                                                          */

/*  Note that the imaginary coefficients are negated                      */

/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than         */

/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                     */

/*  where d = 2*PI/n.  The value of w(n,k) is usually written             */

/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).              */

/*                                                                          */

/*  The routine can be used to implement an inverse FFT by                */

/*  performing the complex conjugate on the input complex numbers         */

/*  (negating the imaginary value), and dividing the result by n.         */

/*  Another method to use the FFT to perform an inverse FFT, is to        */

/*  swap the real and imaginary values of the input and the result,       */

/*  and divide the result by n.  In either case, the input is still       */

/*  in normal order and the output is still in digit-reversed order.      */

/*                                                                          */

/*  Note that you can not make the radix 4 FFT into an inverse            */

/*  FFT by using the complex conjugate of the coefficients as             */

/*  you can do with the complex radix 2 FFT.                              */

/*                                                                          */

/*  If you label the input locations from 0 to (n-1) (normal order),      */

/*  the digit-reversed locations can be calculated by reversing the       */

/*  order of the bit pairs of the labels.  For example, for a 1024        */

/*  point FFT, the digit reversed location for                            */

/*  617d = 1001101001b = 10 01 10 10 01  is                               */

/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                  */

/*                                                                          */

/*  TI plans to provide an inverse complex radix 4 FFT with digit-        */

/*  reversed input and normal order output.  With these 2 routines,       */

/*  the digit-reversed output of the FFT can be the input to the          */

/*  inverse FFT without performing digit-reversing on the data.           */

/*                                                                          */

/*  TI also plans to provide a complex digit reverse routine.             */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_cfftr4_dif,    ".text:ansi");



#include "DSPF_sp_cfftr4_dif.h"



void DSPF_sp_cfftr4_dif(float    * x, float * w, short n)

{



        short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;

        float r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3, si1, si2, si3;



        n2 = n;

        ie = 1;

        for(k=n; k>1; k>>=2)

        {

           n1 = n2;

           n2 >>= 2;

           ia1 = 0;

           for(j=0; j<n2; j++)

           {

               ia2 = ia1 + ia1;

               ia3 = ia1 + ia2;

               co1 = w[ia1*2];

               si1 = w[ia1*2 + 1];

               co2 = w[ia2*2];

               si2 = w[ia2*2 + 1];

               co3 = w[ia3*2];

               si3 = w[ia3*2 + 1];

               ia1 += ie;

               for(i0 = j; i0 < n; i0 += n1)

               {

                   i1 = i0 + n2;

                   i2 = i1 + n2;

                   i3 = i2 + n2;

                   r1 = x[i0*2]   + x[i2*2];

                   r3 = x[i0*2]   - x[i2*2];

                   s1 = x[i0*2+1] + x[i2*2+1];

                   s3 = x[i0*2+1] - x[i2*2+1];

                   r2 = x[i1*2]   + x[i3*2];

                   r4 = x[i1*2]   - x[i3*2];

                   s2 = x[i1*2+1] + x[i3*2+1];

                   s4 = x[i1*2+1] - x[i3*2+1];

                   x[i0*2]   = r1 + r2;

                   r2        = r1 - r2;

                   r1        = r3 - s4;

                   r3        = r3 + s4;

                   x[i0*2+1] = s1 + s2;

                   s2        = s1 - s2;

                   s1        = s3 + r4;

                   s3        = s3 - r4;

                   x[i1*2]   = co1*r3 + si1*s3;

                   x[i1*2+1] = co1*s3 - si1*r3;

                   x[i2*2]   = co2*r2 + si2*s2;

                   x[i2*2+1] = co2*s2 - si2*r2;

                   x[i3*2]   = co3*r1 + si3*s1;

                   x[i3*2+1] = co3*s1 - si3*r1;

               }

           }

           ie <<= 2;

        }

}



/* ======================================================================== */

/*  End of file: DSPF_sp_cfftr4_dif.c                                            */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_cfftr2_/1117057339  65    0     0       5473      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   */
/*      complex input                                                       */
/*                                                                          */
/*  USAGE                                                                   */
/*          This routine is C-callable and can be called as:                */
/*                                                                          */
/*          void DSPF_sp_cfftr2_dit(float * x, float * w, short n);              */
/*                                                                          */
/*          x : Pointer to complex data input                               */
/*          w : pointer to complex twiddle factor in Bit reverse order      */
/*          N : length of FFT in complex samples, power of 2 such that N>=3 */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the Decimation-in-Time (DIT) Radix-2 FFT      */
/*      of the input array x.                                               */
/*      x has N complex floating point numbers arranged as successive       */
/*      real and imaginary number pairs. Input array x contains N           */
/*      complex points (N*2 elements). The coefficients for the             */
/*      FFT are passed to the function in array w which contains            */
/*      N/2 complex numbers (N elements) as successive real and             */
/*      imaginary number pairs.                                             */
/*      The FFT Coefficients w are in N/2 bit-reversed order                */
/*      The elements of input array x are in normal order                   */
/*      The assembly routine performs 4 output samples (2 real and 2        */
/*      imaginary) for a pass through inner loop.                           */
/*                                                                          */
/*      Note that (bit-reversed) coefficients for higher order FFT (1024    */
/*      point) can be used unchanged as coefficients for a lower order      */
/*      FFT (512, 256, 128 ... ,2)                                          */
/*                                                                          */
/*      The routine can be used to implement Inverse-FFT by any ONE of      */
/*      the following methods:                                              */
/*                                                                          */
/*      1.Inputs (x) are replaced by their Complex-conjugate values         */
/*        Output values are divided by N                                    */
/*      2.FFT Coefficients (w) are replaced by their Complex-conjugates     */
/*        Output values are divided by N                                    */
/*      3.Swap Real and Imaginary values of input                           */
/*      4.Swap Real and Imaginary values of output                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_cfftr2_dit,    ".text:ansi");

#include "DSPF_sp_cfftr2_dit.h"

void DSPF_sp_cfftr2_dit(float    * x, float * w, int n)
{
           int n2, ie, ia, i, j, k, m;
           float rtemp, itemp, c, s;

           n2 = n;
           ie = 1;

           for(k = n; k > 1; k >>= 1)
           {
              n2 >>= 1;
              ia = 0;
              for(j=0; j < ie; j++)
              {
                 c = w[2*j];
                 s = w[2*j+1];
                 for(i=0; i < n2; i++)
                 {
                    m = ia + n2;
                    rtemp     = c * x[2*m]   + s * x[2*m+1];
                    itemp     = c * x[2*m+1] - s * x[2*m];
                    x[2*m]    = x[2*ia]   - rtemp;
                    x[2*m+1]  = x[2*ia+1] - itemp;
                    x[2*ia]   = x[2*ia]   + rtemp;
                    x[2*ia+1] = x[2*ia+1] + itemp;
                    ia++;
                 }
                 ia += n2;
              }
              ie <<= 1;
           }
}


/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr2_dit.c                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_fftSPxS/1117057340  87    0     0       22452     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          */
/*      forwards FFT with complex input                                     */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of fft in complex samples, power of 2 such that    */
/*                   N >=8 and N<= 16385.                                   */
/*      ptr_x  :  Pointer to complex data input.                            */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data.                           */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest fft butterfly used in computation used for       */
/*                decomposing fft into subffts, see notes.                  */
/*      offset :  Index in complex samples of sub-fft from start of main    */
/*                fft.                                                      */
/*      n_max  :  size of main fft in complex samples.                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards fft using a special   */
/*      sequece of coefficients generated in the following way:             */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the fft  */
/*      producing the frequency domain data in the Y array.                 */
/*      As the fft allows every input point to effect every output point    */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main fft of size N to  */
/*      be divided into several steps, allowing as much data reuse as       */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire 1K data     */
/*      set it covers the 1st pass of the fft until the butterfly size is   */
/*      256. The following 4 ffts do 256 pt ffts 25% of the size. These     */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the fft the following would be needed :                   */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the fft is calculated by summing these      */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array. In the    */
/*      smae way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the FFT, four other calls are required to        */
/*      perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 FFTs in         */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the FFT with one function call invocation as shown    */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_fftSPxSP,    ".text:ansi");

#include "DSPF_sp_fftSPxSP.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_fftSPxSP(int    N, float * ptr_x, float * ptr_w, float * ptr_y, unsigned char * brev, int n_min, int offset, int n_max)
{

/* ======================================================================== */
/* ======================================================================== */
            int  i, j, k, l1, l2, h2, predj;
            int  tw_offset, stride, fft_jmp;

            float x0, x1, x2, x3,x4,x5,x6,x7;
            float xt0, yt0, xt1, yt1, xt2, yt2, yt3;
            float yt4, yt5, yt6, yt7;
            float si1,si2,si3,co1,co2,co3;
            float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;
            float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;
            float xl0_0, xl1_0, xl0_1, xl1_1;
            float xh0_0, xh1_0, xh0_1, xh1_1;
            float *x,*w;
            int   k0, k1, j0, j1, l0, radix;
            float * y0, * ptr_x0, * ptr_x2;

            radix = n_min;

            stride = N; /* n is the number of complex samples */
            tw_offset = 0;
            while (stride > radix)
            {
                j = 0;
                fft_jmp = stride + (stride>>1);
                h2 = stride>>1;
                l1 = stride;
                l2 = stride + (stride>>1);
                x = ptr_x;
                w = ptr_w + tw_offset;

                for (i = 0; i < N; i += 4)
                {
                    co1 = w[j];
                    si1 = w[j+1];
                    co2 = w[j+2];
                    si2 = w[j+3];
                    co3 = w[j+4];
                    si3 = w[j+5];

                    x_0    = x[0];
                    x_1    = x[1];
                    x_h2   = x[h2];
                    x_h2p1 = x[h2+1];
                    x_l1   = x[l1];
                    x_l1p1 = x[l1+1];
                    x_l2   = x[l2];
                    x_l2p1 = x[l2+1];

                    xh0  = x_0    + x_l1;
                    xh1  = x_1    + x_l1p1;
                    xl0  = x_0    - x_l1;
                    xl1  = x_1    - x_l1p1;

                    xh20 = x_h2   + x_l2;
                    xh21 = x_h2p1 + x_l2p1;
                    xl20 = x_h2   - x_l2;
                    xl21 = x_h2p1 - x_l2p1;

                    ptr_x0 = x;
                    ptr_x0[0] = xh0 + xh20;
                    ptr_x0[1] = xh1 + xh21;

                    ptr_x2 = ptr_x0;
                    x += 2;
                    j += 6;
                    predj = (j - fft_jmp);
                    if (!predj) x += fft_jmp;
                    if (!predj) j = 0;

                    xt0 = xh0 - xh20;
                    yt0 = xh1 - xh21;
                    xt1 = xl0 + xl21;
                    yt2 = xl1 + xl20;
                    xt2 = xl0 - xl21;
                    yt1 = xl1 - xl20;

                    ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;
                    ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;
                    ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;
                    ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;
                    ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;
                    ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;
                }
                tw_offset += fft_jmp;
                stride = stride>>2;
            }/* end while */

            j = offset>>2;

            ptr_x0 = ptr_x;
            y0 = ptr_y;
            /*l0 = _norm(n_max) - 17;    get size of fft */
            l0=0;
            for(k=30;k>=0;k--)
                if( (n_max & (1 << k)) == 0 )
                   l0++;
                else
                   break;
            l0=l0-17;
            if (radix <= 4) for (i = 0; i < N; i += 4)
            {
                    /* reversal computation */

                    j0 = (j     ) & 0x3F;
                    j1 = (j >> 6);
                    k0 = brev[j0];
                    k1 = brev[j1];
                    k = (k0 << 6) +  k1;
                    k = k >> l0;
                    j++;        /* multiple of 4 index */

                    x0   = ptr_x0[0];  x1 = ptr_x0[1];
                    x2   = ptr_x0[2];  x3 = ptr_x0[3];
                    x4   = ptr_x0[4];  x5 = ptr_x0[5];
                    x6   = ptr_x0[6];  x7 = ptr_x0[7];
                    ptr_x0 += 8;

                    xh0_0  = x0 + x4;
                    xh1_0  = x1 + x5;
                    xh0_1  = x2 + x6;
                    xh1_1  = x3 + x7;

                    if (radix == 2) {
                      xh0_0 = x0;
                      xh1_0 = x1;
                      xh0_1 = x2;
                      xh1_1 = x3;
                    }

                    yt0  = xh0_0 + xh0_1;
                    yt1  = xh1_0 + xh1_1;
                    yt4  = xh0_0 - xh0_1;
                    yt5  = xh1_0 - xh1_1;

                    xl0_0  = x0 - x4;
                    xl1_0  = x1 - x5;
                    xl0_1  = x2 - x6;
                    xl1_1  = x3 - x7;

                    if (radix == 2) {
                      xl0_0 = x4;
                      xl1_0 = x5;
                      xl1_1 = x6;
                      xl0_1 = x7;
                    }

                    yt2  = xl0_0 + xl1_1;
                    yt3  = xl1_0 - xl0_1;
                    yt6  = xl0_0 - xl1_1;
                    yt7  = xl1_0 + xl0_1;

                    if (radix == 2) {
                      yt7  = xl1_0 - xl0_1;
                      yt3  = xl1_0 + xl0_1;
                    }

                    y0[k] = yt0; y0[k+1] = yt1;
                    k += n_max>>1;
                    y0[k] = yt2; y0[k+1] = yt3;
                    k += n_max>>1;
                    y0[k] = yt4; y0[k+1] = yt5;
                    k += n_max>>1;
                    y0[k] = yt6; y0[k+1] = yt7;
            }

}

/* ======================================================================== */
/*  End of file: DSPF_sp_fftSPxSP.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_ifftSPx/1117057342  107   0     0       23090     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         */
/*      inverse FFT with complex input                                      */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of ifft in complex samples, power of 2 such that   */
/*                N >=8 and N<= 16385.                                      */
/*      ptr_x  :  Pointer to complex data input (normal order).             */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data (normal order).            */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest ifft butterfly used in computation used for      */
/*                decomposing ifft into sub iffts, see notes.               */
/*      offset :  Index in complex samples of sub-ifft from start of main   */
/*                ifft.                                                     */
/*      n_max  :  size of main ifft in complex samples.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards ifft using a special  */
/*      sequence of coefficients generated in the following way:            */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the      */
/*      ifft producing the time domain data in the Y array. The output is   */
/*      scaled by a scaling factor of 1/N.                                  */
/*                                                                          */
/*      As the ifft allows every input point to effect every output point   */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main ifft of size N    */
/*      to be divided into several steps, allowing as much data reuse as    */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          */
/*                                                                          */
/*      Notice how the 1st ifft function is called on the entire 1K data    */
/*      set it covers the 1st pass of the ifft until the butterfly size is  */
/*      256. The following 4 iffts do 256 pt iffts 25% of the size. These   */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the ifft the following would be needed :                  */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the ifft is calculated by summing these     */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array. In the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the IFFT, four other calls are required to       */
/*      perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 IFFTs in        */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the IFFT with one function call invocation as shown   */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_ifftSPxSP,    ".text:ansi");

#include "DSPF_sp_ifftSPxSP.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_ifftSPxSP(int    N, float * ptr_x, float * ptr_w, float * ptr_y, unsigned char * brev, int n_min, int offset, int n_max)
{

/* ======================================================================== */
/* ======================================================================== */
            int  i, j, k, l1, l2, h2, predj;
            int  tw_offset, stride, fft_jmp;

            float x0, x1, x2, x3,x4,x5,x6,x7;
            float xt0, yt0, xt1, yt1, xt2, yt2, yt3;
            float yt4, yt5, yt6, yt7;
            float si1,si2,si3,co1,co2,co3;
            float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;
            float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;
            float xl0_0, xl1_0, xl0_1, xl1_1;
            float xh0_0, xh1_0, xh0_1, xh1_1;
            float *x,*w;
            int   k0, k1, j0, j1, l0, radix;
            float * y0, * ptr_x0, * ptr_x2;
            float scale;

            radix = n_min;

            stride = N; /* n is the number of complex samples */
            tw_offset = 0;
            while (stride > radix)
            {
                j = 0;
                fft_jmp = stride + (stride>>1);
                h2 = stride>>1;
                l1 = stride;
                l2 = stride + (stride>>1);
                x = ptr_x;
                w = ptr_w + tw_offset;

                for (i = 0; i < N; i += 4)
                {
                    co1 = w[j];
                    si1 = w[j+1];
                    co2 = w[j+2];
                    si2 = w[j+3];
                    co3 = w[j+4];
                    si3 = w[j+5];

                    x_0    = x[0];
                    x_1    = x[1];
                    x_h2   = x[h2];
                    x_h2p1 = x[h2+1];
                    x_l1   = x[l1];
                    x_l1p1 = x[l1+1];
                    x_l2   = x[l2];
                    x_l2p1 = x[l2+1];

                    xh0  = x_0    + x_l1;
                    xh1  = x_1    + x_l1p1;
                    xl0  = x_0    - x_l1;
                    xl1  = x_1    - x_l1p1;

                    xh20 = x_h2   + x_l2;
                    xh21 = x_h2p1 + x_l2p1;
                    xl20 = x_h2   - x_l2;
                    xl21 = x_h2p1 - x_l2p1;

                    ptr_x0 = x;
                    ptr_x0[0] = xh0 + xh20;
                    ptr_x0[1] = xh1 + xh21;

                    ptr_x2 = ptr_x0;
                    x += 2;
                    j += 6;
                    predj = (j - fft_jmp);
                    if (!predj) x += fft_jmp;
                    if (!predj) j = 0;

                    xt0 = xh0 - xh20; //xt0 = xh0 - xh20;
                    yt0 = xh1 - xh21; //yt0 = xh1 - xh21;
                    xt1 = xl0 - xl21; //xt1 = xl0 + xl21;
                    yt2 = xl1 - xl20; //yt2 = xl1 + xl20;
                    xt2 = xl0 + xl21; //xt2 = xl0 - xl21;
                    yt1 = xl1 + xl20; //yt1 = xl1 - xl20;

                    ptr_x2[l1  ] = xt1 * co1 - yt1 * si1; //ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;
                    ptr_x2[l1+1] = yt1 * co1 + xt1 * si1; //ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;
                    ptr_x2[h2  ] = xt0 * co2 - yt0 * si2; //ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;
                    ptr_x2[h2+1] = yt0 * co2 + xt0 * si2; //ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;
                    ptr_x2[l2  ] = xt2 * co3 - yt2 * si3; //ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;
                    ptr_x2[l2+1] = yt2 * co3 + xt2 * si3; //ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;
                }
                tw_offset += fft_jmp;
                stride = stride>>2;
            }/* end while */

            j = offset>>2;

            ptr_x0 = ptr_x;
            y0 = ptr_y;
            /*l0 = _norm(n_max) - 17;    get size of fft */
            l0=0;
            for(k=30;k>=0;k--)
                if( (n_max & (1 << k)) == 0 )
                   l0++;
                else
                   break;
            l0=l0-17;
            scale = 1/(float)n_max;
            if (radix <= 4) for (i = 0; i < N; i += 4)
            {
                    /* reversal computation */

                    j0 = (j     ) & 0x3F;
                    j1 = (j >> 6);
                    k0 = brev[j0];
                    k1 = brev[j1];
                    k = (k0 << 6) +  k1;
                    k = k >> l0;
                    j++;        /* multiple of 4 index */

                    x0   = ptr_x0[0];  x1 = ptr_x0[1];
                    x2   = ptr_x0[2];  x3 = ptr_x0[3];
                    x4   = ptr_x0[4];  x5 = ptr_x0[5];
                    x6   = ptr_x0[6];  x7 = ptr_x0[7];
                    ptr_x0 += 8;

                    xh0_0  = x0 + x4;
                    xh1_0  = x1 + x5;
                    xh0_1  = x2 + x6;
                    xh1_1  = x3 + x7;

                    if (radix == 2) {
                      xh0_0 = x0;
                      xh1_0 = x1;
                      xh0_1 = x2;
                      xh1_1 = x3;
                    }

                    yt0  = xh0_0 + xh0_1;
                    yt1  = xh1_0 + xh1_1;
                    yt4  = xh0_0 - xh0_1;
                    yt5  = xh1_0 - xh1_1;

                    xl0_0  = x0 - x4;
                    xl1_0  = x1 - x5;
                    xl0_1  = x2 - x6;
                    xl1_1  = x7 - x3; //xl1_1  = x3 - x7;

                    if (radix == 2) {
                      xl0_0 = x4;
                      xl1_0 = x5;
                      xl1_1 = x6;
                      xl0_1 = x7;
                    }

                    yt2  = xl0_0 + xl1_1;
                    yt3  = xl1_0 + xl0_1; // yt3  = xl1_0 + (- xl0_1);
                    yt6  = xl0_0 - xl1_1;
                    yt7  = xl1_0 - xl0_1; // yt7  = xl1_0 - (- xl0_1);

                    y0[k] = yt0*scale; y0[k+1] = yt1*scale;
                    k += n_max>>1;
                    y0[k] = yt2*scale; y0[k+1] = yt3*scale;
                    k += n_max>>1;
                    y0[k] = yt4*scale; y0[k+1] = yt5*scale;
                    k += n_max>>1;
                    y0[k] = yt6*scale; y0[k+1] = yt7*scale;
            }
}

/* ======================================================================== */
/*  End of file: DSPF_sp_ifftSPxSP.c                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_icfftr2/1117057343  128   0     0       6816      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSPF_sp_icfftr2_dif(                                            */
/*                              float* x,                                   */
/*                              float* w,                                   */
/*                              short n                                     */
/*                             );                                           */
/*                                                                          */
/*          x : input and output sequences (dim-n)      (input/output)      */
/*              x has n complex numbers (2*n SP values).                    */
/*              The real and imaginary values are interleaved in memory.    */
/*              The input is in Bit reversed order nad output is in Normal  */
/*              Order.                                                      */
/*          w : FFT coefficients (dim-n/2)              (input)             */
/*              w has n/2 complex numbers (n SP values).                    */
/*              FFT coeficients must be in bit-reversed order               */
/*              The real and imaginary values are interleaved in memory     */
/*          n : FFT size                                (input)             */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine is used to compute the Inverse, Complex, Radix-2,      */
/*      Decimation-in-Frequency Fast Fourier Transform of a single          */
/*      precision complex sequence of size n, and a power of 2. The         */
/*      routine requires bit-reversed input and bit-reversed coefficents    */
/*      (twiddle factors) and produces results that are in normal order.    */
/*      Final scaling by 1/N is not done in this function.                  */
/*                                                                          */
/*      How To Use                                                          */
/*                                                                          */
/*          void main(void)                                                 */
/*          {                                                               */
/*              gen_w_r2(w, N);      // Generate coefficient table          */
/*              bit_rev(w, N>>1);    // Bit-reverse coefficient table       */
/*              cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   */
/*                                   // from TI available                   */
/*                                   // input in normal order, output in    */
/*                                   // order bit-reversed                  */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 */
/*                                   // input in bit-reversed order,        */
/*                                   // order output in normal              */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              divide(x, N);        // scale inverse FFT output            */
/*                                   // result is same as original input    */
/*          }                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_icfftr2_dif,    ".text:ansi");

#include "DSPF_sp_icfftr2_dif.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_icfftr2_dif(float    * x, float * w, short n)
{

/* ======================================================================== */
/* ======================================================================== */
     short n2, ie, ia, i, j, k, m;

     float rtemp, itemp, c, s;



     n2 = 1;

     ie = n;

     for(k=n; k > 1; k >>= 1)

     {

        ie >>= 1;

        ia = 0;

        for(j=0; j < ie; j++)

        {

           c = w[2*j];

           s = w[2*j+1];

           for(i=0; i < n2; i++)

           {

              m = ia + n2;

              rtemp     = x[2*ia]   - x[2*m];

              x[2*ia]   = x[2*ia]   + x[2*m];

              itemp     = x[2*ia+1] - x[2*m+1];

              x[2*ia+1] = x[2*ia+1] + x[2*m+1];

              x[2*m]    = c*rtemp   - s*itemp;

              x[2*m+1]  = c*itemp   + s*rtemp;

              ia++;

           }

           ia += n2;

        }

        n2 <<= 1;

      }



}

/* ======================================================================== */
/*  End of file: DSPF_sp_icfftr2_dif.c                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_fir_cpl/1117057344  151   0     0       4421      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     */

/*      Filter                                                              */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_fir_cplx(                                                  */

/*                        const float * restrict x,                         */

/*                        const float * restrict h,                         */

/*                        float *       restrict r,                         */

/*                        int   nh,                                         */

/*                        int   nr                                          */

/*                       )                                                  */

/*            x[2*(nr+nh-1)]:Pointer to complex Input array.                */

/*                           The input data pointer x must point to the     */

/*                           (nh)th complex element, i.e. element 2*(nh-1). */

/*            h[2*nh]:       Pointer to complex Coefficient array           */

/*                           (in normal order).                             */

/*            r[2*nr]:       Pointer to complex Output array.               */

/*            nh:            Number of complex coefficients in vector h.    */

/*            nr:            Number of complex output samples to calculate. */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This function implements the FIR filter for complex input data.    */

/*       The filter has nr output samples and nh coefficients. Each array   */

/*       consists of an even and odd term with even terms representing the  */

/*       real part and the odd terms the imaginary part of the element.     */

/*       The coefficients are expected in normal order.                     */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_fir_cplx,    ".text:ansi");



#include "DSPF_sp_fir_cplx.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_fir_cplx(const    float *restrict x, const float *restrict h, float *restrict r, int nh, int nr)

{



/* ======================================================================== */

/* ======================================================================== */

    int i,j;

    float imag, real;

    for (i = 0; i < 2*nr; i += 2)

        {

        imag = 0;

        real = 0;

        for (j = 0; j < 2*nh; j += 2)

            {

            real += h[j] * x[i-j] - h[j+1] * x[i+1-j];

            imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];

            }

        r[i] = real;

        r[i+1] = imag;

        }

}



/* ======================================================================== */

/*  End of file: DSPF_sp_fir_cplx.c                                              */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_fir_gen/1117057345  171   0     0       3981      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   */

/*                                                                          */

/*   USAGE                                                                  */

/*                                                                          */

/*   This routine is C Callable and can be called as:                       */

/*                                                                          */

/*       void sp_firgen(const float *x, const float *h, float * restrict r, */

/*                  int nh, int nr);                                        */

/*                                                                          */

/*       x : Pointer to array holding the input floating point array        */

/*       h : Pointer to array holding the coefficient floating point        */

/*           array                                                          */

/*       y : Pointer to array holding the output floating point array       */

/*       nh: Number of coefficents                                          */

/*       nr: Number of output values                                        */

/*                                                                          */

/*   DESCRIPTION                                                            */

/*                                                                          */

/*       This routine implements a block FIR filter.  There are "nh"        */

/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */

/*       input samples.    The coefficients need to be placed in the "h"    */

/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */

/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */

/*       routine calculates y(0) through y(nr-1) using the following        */

/*       formula:                                                           */

/*                                                                          */

/*       y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */

/*                                                                          */

/*       where n = {0, 1, ... , nr-1}.                                      */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_fir_gen,    ".text:ansi");



#include "DSPF_sp_fir_gen.h"



void DSPF_sp_fir_gen(const    float * restrict x, const float * restrict h, float * restrict r, int nh, int nr)

{



    int i, j;

    float sum;

    for (j = 0; j < nr; j++) 

    {

        sum = 0;        

        for (i = 0; i < nh; i++)

            /* perform the FIR convolution */

            sum += x[i + j] * h[i];

        

        r[j] = sum;

    }



}



/* ======================================================================== */

/*  End of file: DSPF_sp_fir_gen.c                                               */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_fir_r2./1117057346  190   0     0       4072      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       */

/*      Filter                                                              */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_fir_r2(                                                    */

/*                     const float * restrict x,                            */

/*                     const float * restrict h,                            */

/*                     float       * restrict r,                            */

/*                     int   nh,                                            */

/*                     int   nr                                             */

/*                     )                                                    */

/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */

/*            h[nh]:      Pointer to Coefficient array of size nh.          */

/*                        (in reverse order).                               */

/*            r[nr]:      Pointer to Output array od size nr.               */

/*            nh:         Number of coefficients                            */

/*            nr:         Number of output samples.                         */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       Computes a real FIR filter (direct-form) using coefficients        */

/*       stored in vector h[]. The real data input is stored in vector      */

/*       x[]. The filter output result is stored in vector r[]. The         */

/*       filter calculates nr output samples using nh coefficients.         */

/*       The coefficients are expected to be in reverse order.              */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_fir_r2,    ".text:ansi");



#include "DSPF_sp_fir_r2.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_fir_r2(const    float *restrict x, const float *restrict h, float *restrict r, int nh, int nr)

{



/* ======================================================================== */

/* ======================================================================== */

   int i, j;

   float sum;

   

   for (j = 0; j < nr; j++) 

   {

       sum = 0;

       for (i = 0; i < nh; i++)

           sum += x[i + j] * h[i];

       r[j] = sum;

   }

}



/* ======================================================================== */

/*  End of file: DSPF_sp_fir_r2.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_fircirc/1117057347  208   0     0       5393      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has following C prototype                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       );                                                                 */
/*                                                                          */
/*      x[]     : Input array (circular buffer of 2^(csize+1) bytes)        */
/*                Must be aligned at 2^(csize+1) byte boundary              */
/*      h[nh]   : Filter coefficients array                                 */
/*                Must be double-word aligned                               */
/*      r[nr]   : Output array                                              */
/*      index   : Offset by which to start reading from the input array     */
/*                Must be multiple of 2                                     */
/*      csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         */
/*                Must be 2 <= csize <= 31.                                 */
/*      nh      : Number of filter coefficients                             */
/*                Must be multiple of 2 and >= 4                            */
/*      nr      : Size of output array                                      */
/*                Must be multiple of 4                                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine implements a circularly addressed FIR filter.          */
/*      'nh' is the number of filter coefficients. 'nr' is the number       */
/*      of the output samples.                                              */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_fircirc,    ".text:ansi");

#include "DSPF_sp_fircirc.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_fircirc(float    * x, float * h, float * r, int index, int csize, int nh, int nr)
{

/* ======================================================================== */
/* ======================================================================== */
    int i, j;
    //Circular Buffer block size = ((2^(csize + 1)) / 4) floating point numbers
    int mod = (1 << (csize - 1));
    float r0;

    for (i = 0; i < nr; i++)
    {
        r0 = 0;
        for (j = 0; j < nh; j++)
        {
            //Operation "% mod" is equivalent to "& (mod -1)"
            //r0 += x[(i + j + index) % mod] * h[j]
            r0 += x[(i + j + index) & (mod - 1)] * h[j];
        }
        r[i] = r0;
    }
}

/* ======================================================================== */
/*  End of file: DSPF_sp_fircirc.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_biquad./1117057348  227   0     0       4559      `
/* ============================================================================*/
/*                                                                             */
/*  TEXAS INSTRUMENTS, INC.                                                    */
/*                                                                             */
/*  NAME                                                                       */
/*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                     */
/*                                                                             */
/*  USAGE                                                                      */
/*      This routine has following C prototype:                                */
/*                                                                             */
/*           void DSPF_sp_biquad (                                                  */
/*                         float x[],    Pointer to input samples              */
/*                         float b[],    Pointer to Nr coefs b0, b1, b2        */
/*                         float a[],    Pointer to Dr coefs a1, a2            */
/*                         float delay[] Pointer to filter delays              */
/*                         float r[],    Pointer to output samples             */
/*                         int   nx      Number of input/output samples        */
/*                         )                                                   */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*  DESCRIPTION                                                                */
/*      This routine implements a DF 2 transposed structure of the biquad      */
/*      filter. The transfer function of a biquad can be written               */
/*      as:                                                                    */
/*                                                                             */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)            */
/*                       H(Z) =     _________________________________          */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)              */
/*                                                                             */
/*       The  C code below is a general implementation without                 */
/*       restrictions. The assembly code may have some restrictions, as        */
/*       noted in the hand assembly code comment header.                       */
/*                                                                             */
/* ============================================================================*/
/*            Copyright (c) 2002 Texas Instruments, Incorporated.              */
/*                           All Rights Reserved.                              */
/* ============================================================================*/
void DSPF_sp_biquad    (
                float x[],         //Pointer to input samples
                float b[],         //Pointer to numerator coefficients b[0], b[1] and b[2]
                float a[],         //Pointer to denominator coefficients a[1] and a[2]
                float delay[],     //Pointer to filter delays, delay[0] and delay[1]
                float r[],         //Pointer to output samples
                int      nx         //Number of input/output samples
               )
{
    int i;
    float a1, a2, b0, b1, b2, d0, d1, x_i;

    a1 = a[0];
    a2 = a[1];

    b0 = b[0];
    b1 = b[1];
    b2 = b[2];

    d0 = delay[0];
    d1 = delay[1];

    for (i = 0; i < nx; i++)
    {
        x_i = x[i];
        r[i] = b0 * x_i + d0;
        d0 = b1 * x_i - a1 * r[i] + d1;
        d1 = b2 * x_i - a2 * r[i];
    }
    delay[0] = d0;
    delay[1] = d1;
}
/* ======================================================================== */
/*  End of file:  DSPF_sp_biquad.c                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_iir.c/  1117057349  0     0     0       3994      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*   This routine is C callable, and has the following C prototype:         */

/*                                                                          */

/*      void DSPF_sp_iir    (float* restrict r1,                                 */

/*                      const float*    x,                                  */

/*                      float* restrict r2,                                 */

/*                      const float*    h2,                                 */

/*                      const float*    h1,                                 */

/*                      int nr                                              */

/*                     );                                                   */

/*                                                                          */

/*           r1   :  Delay element values (i/p and o/p)                     */

/*           x    :  Pointer to the input array                             */

/*           r2   :  Pointer to the output array                            */

/*           h2   :  Auto-regressive filter coefficients                    */

/*           h1   :  Moving average filter coefficients                     */

/*           nr   :  Number of output samples                               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*    The IIR performs an auto-regressive moving-average (ARMA)             */

/*    filter with 4 auto-regressive filter coefficients and 5               */

/*    moving-average filter coefficients for nr output samples.             */

/*    The output vector is stored in two locations. This routine            */

/*    is used as a high pass filter in the VSELP vocoder.                   */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_iir,    ".text:ansi");



#include "DSPF_sp_iir.h"



void DSPF_sp_iir(float    *restrict r1, const float * x, float *restrict r2, const float * h2, const float * h1, int nr)

{



    int i, j;

    float sum;

    

    for (i = 0; i < nr; i++)

    {

        sum = h2[0] * x[4+i];



        for (j = 1; j <= 4; j++) 

            sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];



        r1[4+i] = sum;

        r2[i] = r1[4+i];

    }

}



/* ======================================================================== */

/*  End of file: DSPF_sp_iir.c                                                   */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_iirlat./1117057350  245   0     0       5163      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           */

/*                                                                          */

/*   USAGE                                                                  */

/*       This routine has following C prototype:                            */

/*                                                                          */

/*            void DSPF_sp_iirlat(                                               */

/*                          float *x,                                       */

/*                          int nx,                                         */

/*                          const float * restrict k,                       */

/*                          int nk,                                         */

/*                          float * restrict b,                             */

/*                          float * r                                       */

/*                          )                                               */

/*         x[nx]   : Input vector                                           */

/*         nx      : Length of input vector.                                */

/*         k[nk]   : Reflection coefficients                                */

/*         nk      : Number of reflection coefficients/lattice stages       */

/*                   Must be multiple of 2 and >=6.                         */

/*         b[nk+1] : Delay line elements from previous call. Should be      */

/*                   initialized to all zeros prior to the first call.      */

/*         r[nx]   : Output vector                                          */

/*                                                                          */

/*     DESCRIPTION                                                          */

/*         This routine implements a real all-pole IIR filter in lattice    */

/*         structure (AR lattice). The filter consists of nk lattice stages */

/*         Each stage requires one reflection coefficient k and one delay   */

/*         element b. The routine takes an input vector x[] and returns the */

/*         filter output in r[]. Prior to the first call of the routine the */

/*         delay elements in b[] should be set to zero. The input data may  */

/*         have to be pre-scaled to avoid overflow or achieve better SNR. T */

/*         reflections coefficients lie in the range -1.0 < k < 1.0. The    */

/*         order of the coefficients is such that k[nk-1] corresponds to th */

/*         first lattice stage after the input and k[0] corresponds to the  */

/*         last stage.                                                      */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_iirlat,    ".text:ansi");



#include "DSPF_sp_iirlat.h"



void DSPF_sp_iirlat(float    * x, int nx, const float * restrict k, int nk, float * restrict b, float * r)

{



       float rt;     // output       //                              

       int i, j;                                                   

                                                                   

       for (j = 0; j < nx; j++)                                        

       {                                                           

           rt = x[j];                                        

                                                                   

           for (i = nk - 1; i >= 0; i--)                           

           {                        

               rt = rt - b[i] * k[i];

               b[i + 1] = b[i] + rt * k[i];

           }

                                                                   

           b[0] = rt;                                                                                                                 

           r[j] = rt;                                        

       }                                                           



}



/* ======================================================================== */

/*  End of file: DSPF_sp_iirlat.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_convol./1117057351  263   0     0       9427      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_convol -- Single Precision convolution                           */
/*                                                                          */
/*  USAGE                                                                   */
/*   This routine has the following C prototype:                            */
/*                                                                          */
/*   void DSPF_sp_convol                                                         */
/*         (                                                                */
/*                   float *x, //x: Pointer to input samples//              */
/*                   float *h, //h: Pointer to impulse response samples//   */
/*                   float *r, //r: Pointer to output samples//             */
/*                   int   nh, //nh: Number of impulse response samples//   */
/*                   int   nr  //nr: Number of output samples//             */
/*         )                                                                */
/*                                                                          */
/*          x = pointer to real input vector of size = nr+nh-1              */
/*              a typically contains input data (x) padded with             */
/*              consecutive nh - 1  zeros at the beginning and end.         */
/*          h = pointer to real input vector of size nh in forward order.   */
/*              h typically contains the filter coefs.                      */
/*          r = pointer to real output vector of size nr                    */
/*          nh= number of elements in vector b. NOTE: nh <= nr  nh is       */
/*              typically noted as m in convol formulas. nh must be a       */
/*              MULTIPLE of 2                                               */
/*          nr= number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*          This function calculates the full-length convolution of real    */
/*          vectors x and h using time-domain techniques. The result is     */
/*          placed in real vector r.                                        */
/*                                                                          */
/*          It is assumed that input vector x is padded with nh-1 no of     */
/*          zeros in the beginning and end.                                 */
/*                                                                          */
/*          It is assumed that the length of the input vector h, nh, is a   */
/*          multiple of 2 and the length of the output vector r, nr, is a   */
/*          multiple of 4. nh is greater thanor equal to 4 and nr is greate */
/*          than or equal to nh. The routine computes 4 output              */
/*          samples at a time.                                              */
/*                                                                          */
/*          x and h are assumed to be aligned on a double word boundary.    */
/*                                                                          */
/*          If routine is not to be used as a C callable function then      */
/*          you need to initialize values for all of the values passed      */
/*          as these are assumed to be in registers as defined by the       */
/*          calling convention of the compiler, (refer to the C compiler    */
/*          reference guide).                                               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*          1. The inner loop is unrolled twice and the outer loop is       */
/*             unrolled four times.                                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*          1. nh is a multiple of 2 and greater than or equal to 4         */
/*          2. nr is a multiple of 4                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*          void DSPF_sp_convol(float *x, float *h, float *r, short nh, short nr */
/*          {                                                               */
/*                  short   ocntr, icntr;                                   */
/*                  float   acc ;                                           */
/*                                                                          */
/*                  for (ocntr = nr ; ocntr > 0 ; ocntr--)                  */
/*                  {                                                       */
/*                          acc = 0 ;                                       */
/*                                                                          */
/*                          for (icntr = nh ; icntr > 0 ; icntr--)          */
/*                          {                                               */
/*                              acc += x[nr-ocntr+nh-icntr]*h[(icntr-1)];   */
/*                          }                                               */
/*                          r[nr-ocntr] = acc;                              */
/*                  }                                                       */
/*                                                                          */
/*          }                                                               */
/*                                                                          */
/*          This is the C equivalent of the assembly code.  Note that       */
/*          the assembly code is hand optimized and restrictions may        */
/*          apply.                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*          (nh/2)*nr + (nr/2)*5 + 9                                        */
/*          For nh=24 and nr=64, cycles=937                                 */
/*          For nh=20 and nr=32, cycles=409                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*          480 bytes                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_convol,    ".text:ansi");

#include "DSPF_sp_convol.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_convol(float    * x, float * h, float * r, int nh, int nr)
{

/* ======================================================================== */
/* ======================================================================== */
            int    ocntr, icntr;
            float    acc ;
            for (ocntr = nr ; ocntr > 0 ; ocntr--)
            {
                acc = 0 ;          /* zero the accumulator */
                for (icntr = nh ; icntr > 0 ; icntr--)
                {
                    acc += x[nr-ocntr+nh-icntr]*h[(icntr-1)] ;
                }
                r[nr-ocntr] = acc; /* Store r[0] thru r[nr-1] */
            }

}

/* ======================================================================== */
/*  End of file: DSPF_sp_convol.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_dotp_sq/1117057352  281   0     0       4143      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_dotp_sqr(                                                  */

/*                       float G,                                           */

/*                       const float * x,                                   */

/*                       const float * y,                                   */

/*                       float *  restrict r,                               */

/*                       int   nx                                           */

/*                       )                                                  */

/*            G:      Sum of y-squared initial value.                       */

/*            x[nx]:  Pointer to First input array.                         */

/*            y[nx]:  Pointer to Second input array.                        */

/*            r:      Pointer to Output for Accumulation of x[]*y[].        */

/*            nx:     Length of input vectors.                              */

/*                                                                          */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This routine computes the dot product of x[] and y[] arrays,adding */

/*       it to the value in the location pointed to by r. Additionally, it  */

/*       computes the sum of the squares of the terms in the y array,adding */

/*       it to the argument G. The final value of G is given as the return  */

/*       value of the function.                                             */

/*                                                                          */

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_dotp_sqr,    ".text:ansi");



#include "DSPF_sp_dotp_sqr.h"



/* ======================================================================== */

/* ======================================================================== */



float DSPF_sp_dotp_sqr(float    G, const float * x, const float * y, float *restrict r, int nx)

{



/* ======================================================================== */

/* ======================================================================== */

   int i;

   

   for (i = 0; i < nx; i++)

   {

   *r += x[i] * y[i];     /* Compute Dot Product */

   G += y[i] * y[i];      /* Compute Square  */

   }

   

   return G;



}



/* ======================================================================== */

/*  End of file: DSPF_sp_dotp_sqr.c                                              */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_dotprod/1117057353  301   0     0       2991      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*    This routine is C Callable and can be called as:                      */

/*                                                                          */

/*      float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     */

/*                                                                          */

/*      x     : Pointer to array holding the first floating point vector    */

/*      y     : Pointer to array holding the second floating point vector   */

/*      nx    : Number of values in the x & y vectors                       */

/*                                                                          */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*      This routine calculates the dot product of 2 single precision       */

/*  float vectors.                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_dotprod,    ".text:ansi");



#include "DSPF_sp_dotprod.h"



float DSPF_sp_dotprod(const    float * x, const float * y, const int nx)

{



    float sum = 0.0f;

    int i;

   

    for(i = 0; i < nx; i++)

    {

        /* calculate dot product and add to sum */

        sum += x[i] * y[i];

    }

    

    return sum;



}



/* ======================================================================== */

/*  End of file: DSPF_sp_dotprod.c                                               */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_dotp_cp/1117057353  320   0     0       3856      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         */

/*      product                                                             */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*    This routine is C Callable and can be called as:                      */

/*                                                                          */

/*      void DSPF_sp_dotp_cplx(const float *x, const float *y, int n, float *    */

/*                        restrict re, float * restrict im);                */

/*                                                                          */

/*      x     : Pointer to array holding the first floating point vector    */

/*      y     : Pointer to array holding the second floating point vector   */

/*      n     : Number of values in the x & y vectors                       */

/*      re    : Pointer to the location storing the real part of the result */

/*      im    : Pointer to the location storing the imaginary part of       */

/*          the result                                                      */

/*                                                                          */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*      This routine calculates the dot product of 2 single precision       */

/*  complex float vectors. The even numbered locations hold the real parts  */

/*  of the complex numbers while the odd numbered locations contain the     */

/*  imaginary portions.                                                     */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_dotp_cplx,    ".text:ansi");



#include "DSPF_sp_dotp_cplx.h"



void DSPF_sp_dotp_cplx(const    float * x, const float * y, int n, 

                     float * restrict re, float * restrict im)

{



    float real = 0, imag = 0;

    int i=0;



    for(i = 0; i < n; i++)

    {

        /* compute the product (a+bj)(c+dj) = (ac-bd) + (ad+bc)j */

        

        /* real part */

        real += (x[2*i] * y[2*i] - x[2*i+1] * y[2*i+1]);

        

        /* imaginary part */

        imag += (x[2*i] * y[2*i+1] + x[2*i+1] * y[2*i]);

    }

    

    /* store results */

    *re = real;

    *im = imag;



}



/* ======================================================================== */

/*  End of file: DSPF_sp_dotp_cplx.c                                             */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_maxval./1117057354  341   0     0       3378      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       float DSPF_sp_maxval(                                                   */

/*                       const float* x,                                    */

/*                       int nx                                             */

/*                      )                                                   */

/*                                                                          */

/*            x :  Pointer to Input array.                                  */

/*            nx:  Number of Inputs in the input Array.                     */

/*            Returns float: Maximum value in the input array               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       This routine Finds out the maximum number in the input array.      */

/*                                                                          */

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */



#pragma CODE_SECTION(DSPF_sp_maxval,    ".text:ansi");



#include "DSPF_sp_maxval.h"

/* ======================================================================== */

/* ======================================================================== */



float DSPF_sp_maxval(const    float* x, int nx)

{



/* ======================================================================== */

/* ======================================================================== */

   int i;

   float max;

   *((int *)&max) = 0xff800000;

  

   for (i = 0; i < nx; i++)

   if (x[i] > max)

      {

      max = x[i];

      }

   //printf("%d\n",index);  

   return max;

}



/* ======================================================================== */

/*  End of file: DSPF_sp_maxval.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_maxidx./1117057355  359   0     0       3295      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       int DSPF_sp_maxidx(                                                     */

/*                      const float* x,                                     */

/*                      int nx                                              */

/*                    )                                                     */

/*                                                                          */

/*            x :  Pointer to Input array.                                  */

/*            nx:  Number of Inputs in the input Array.                     */

/*            Returns int: Index of Maximum value                           */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       This routine Finds out the index of maximum number in the input    */

/*       array.                                                             */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */



#pragma CODE_SECTION(DSPF_sp_maxidx,    ".text:ansi");



#include "DSPF_sp_maxidx.h"



/* ======================================================================== */

/* ======================================================================== */



int DSPF_sp_maxidx(const    float* x, int nx)

{



/* ======================================================================== */

/* ======================================================================== */

   int index, i;

   float max;

   *((int *)&max) = 0xff800000;

  

   for (i = 0; i < nx; i++)

   if (x[i] > max)

      {

      max = x[i];

      index = i;

      }

   return index;

}



/* ======================================================================== */

/*  End of file: DSPF_sp_maxidx.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_minval./1117057356  377   0     0       3392      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             */

/*                                                                          */

/*     USAGE                                                                */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       float DSPF_sp_minval(                                                   */

/*                       const float* x,                                    */

/*                       int nx                                             */

/*                      )                                                   */

/*                                                                          */

/*            x :  Pointer to Input array.                                  */

/*            nx:  Number of Inputs in the input Array.                     */

/*            Returns float: Minimum value in the input array               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       This routine Finds out the minimum number in the input array.      */

/*                                                                          */

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */



#pragma CODE_SECTION(DSPF_sp_minval,    ".text:ansi");



#include "DSPF_sp_minval.h"



/* ======================================================================== */

/* ======================================================================== */



float DSPF_sp_minval(const    float* x, int nx)

{



/* ======================================================================== */

/* ======================================================================== */

   int i;

   float min;

   *((int *)&min) = 0x7f800000;

  

   for (i = 0; i < nx; i++)

   if (x[i] < min)

      {

      min = x[i];

      }

   //printf("\nindex: %d",index);      

   return min;

}



/* ======================================================================== */

/*  End of file: DSPF_sp_minval.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_vecreci/1117057357  395   0     0       3959      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*      This routine is C callable, and has the following C prototype:      */

/*                                                                          */

/*      float DSPF_sp_vecrecip(const float *x,                                   */

/*                        float * restrict r,                               */

/*                        int n                                             */

/*                       )                                                  */

/*                                                                          */

/*             x        :  Pointer to input array                           */

/*             r        :  Pointer to output array                          */

/*             n        :  Number of elements in array                      */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*      The DSPF_sp_vecrecip module calculates the reciprocal of each element in */

/*      array x and returns the output in array r. It uses 2 iterations     */

/*      of the Newton-Raphson method to improve the accuracy of the output  */

/*      generated by the RCPSP instruction of the C67x. Each iteration      */

/*      doubles the accuracy. The initial output generated by RCPSP is 8 bi */

/*      So after the first iteration it is 16 bits and after the second it  */

/*      the full 23 bits. The formula used is:                              */

/*                                                                          */

/*               r[n+1] = r[n](2 - v*r[n])                                  */

/*                                                                          */

/*      where v = the number whose reciprocal is to be found.               */

/*      x[0], the seed value for the algorithm, is given by RCPSP.          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_vecrecip,    ".text:ansi");



#include "DSPF_sp_vecrecip.h"



void DSPF_sp_vecrecip(const    float * x, float * restrict r, int n)

{

    int i;

    

    for(i = 0; i < n; i++)

        /* this reciprocal eval makes a call to the RTS func */

        /* so no software pipelining is possible */

        r[i] = 1 / x[i];

}



/* ======================================================================== */

/*  End of file: DSPF_sp_vecrecip.c                                              */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_vecsum_/1117057360  415   0     0       2893      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*      This routine is C callable, and has the following C prototype:      */

/*                                                                          */

/*      float DSPF_sp_vecsum_sq(const float *x,                                  */

/*                        int n                                             */

/*                       )                                                  */

/*                                                                          */

/*             x        :  Pointer to first input array                     */

/*             n        :  Number of elements in arrays                     */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*       This routine performs a sum of squares of the elements of the      */

/*   array x and returns the sum.                                           */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_vecsum_sq,    ".text:ansi");



#include "DSPF_sp_vecsum_sq.h"



float DSPF_sp_vecsum_sq(const    float * x, int n)

{



    int i;

    float sum=0;

    

    for(i=0; i<n; i++)

        sum += x[i]*x[i];

    

    return sum;



}



/* ======================================================================== */

/*  End of file: DSPF_sp_vecsum_sq.c                                             */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_w_vec.c/1117057361  0     0     0       3380      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*      This routine is C callable, and has the following C prototype:      */

/*                                                                          */

/*        void DSPF_sp_w_vec(const float* x,                                     */

/*                      const float * y,                                    */

/*                      float m,                                            */

/*                      float * restrict r,                                 */

/*                      int     nr                                          */

/*                     )                                                    */

/*                                                                          */

/*             x    :  Pointer to first input array                         */

/*             y    :  Pointer to second input array                        */

/*             m    :  Weight factor                                        */

/*             r    :  Output array pointer                                 */

/*             nr   :  Number of elements in arrays                         */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*     This routine is used to obtain the weighted vector sum.              */

/*     Both the inputs and output are single precision floating             */

/*     point numbers.                                                       */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_w_vec,    ".text:ansi");



#include "DSPF_sp_w_vec.h"



void DSPF_sp_w_vec(const    float * x, const float * y, float m, float * restrict r, int nr)

{



    int i;

    for (i = 0; i < nr; i++)    

        r[i] = (m * x[i]) + y[i];



}



/* ======================================================================== */

/*  End of file: DSPF_sp_w_vec.c                                                 */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_vecmul./1117057362  436   0     0       3199      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_vecmul -- Single Precision vector multiplication                 */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*      This routine is C callable, and has the following C prototype:      */

/*                                                                          */

/*      void DSPF_sp_vecmul   (const float *x,                                   */

/*                        const float *y,                                   */

/*                        float * restrict r,                               */

/*                        int n                                             */

/*                       )                                                  */

/*                                                                          */

/*             x        :  Pointer to first input array                     */

/*             y        :  Pointer to second input array                    */

/*             r        :  Pointer to output array                          */

/*             n        :  Number of elements in arrays                     */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*       This routine performs an element by element floating point         */

/*   multiply of the vectors x[] and y[] and returns the values in r[].     */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_vecmul,    ".text:ansi");



#include "DSPF_sp_vecmul.h"



void DSPF_sp_vecmul(const    float * x, const float * y, float * restrict r, int n)

{



    int i;

    for(i = 0; i < n; i++)

        r[i] = x[i] * y[i];



}



/* ======================================================================== */

/*  End of file: DSPF_sp_vecmul.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_mat_mul/1117057363  454   0     0       5552      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                */

/*                                                                          */

/* USAGE                                                                    */

/*     This routine has following C prototype                               */

/*                                                                          */

/*         void DSPF_sp_mat_mul                                                  */

/*         (                                                                */

/*             float *x, int r1, int c1,                                    */

/*             float *y,         int c2,                                    */

/*             float *r,                                                    */

/*         );                                                               */

/*                                                                          */

/*     x[]  : Pointer to r1 by c1 input matrix.                             */

/*     r1   : Number of rows in x.                                          */

/*     c1   : Number of columns in x.  Also number of rows in y.            */

/*     y[]  : Pointer to c1 by c2 input matrix.                             */

/*     c2   : Number of columns in y.                                       */

/*     r[]  : Pointer to r1 by c2 output matrix.                            */

/*                                                                          */

/* DESCRIPTION                                                              */

/*     This function computes the expression "r = x * y" for the matrices   */

/*     x and y.  The column dimension of x must match the row dimension     */

/*     of y.  The resulting matrix has the same number of rows as x and     */

/*     the same number of columns as y.                                     */

/*                                                                          */

/*     The values stored in the matrices are assumed to be single precision */

/*     floating point values.                                               */

/*                                                                          */

/*     This code is suitable for dense matrices.  No optimizations are      */

/*     made for sparse matrices.                                            */

/*                                                                          */

/*                                                                          */

/* ASSUMPTIONS                                                              */

/*     The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That    */

/*     is, in-place processing is not allowed.                              */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_sp_mat_mul,    ".text:ansi");



#include "DSPF_sp_mat_mul.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_mat_mul(float    * x, int r1, int c1, float * y, int c2, float * r)

{

    int i, j, k;                                              

    float sum;                                                

                                                          

    // ---------------------------------------------------- //

    //  Multiply each row in x by each column in y.  The    //

    //  product of row m in x and column n in y is placed   //

    //  in position (m,n) in the result.                    //

    // ---------------------------------------------------- //

    for (i = 0; i < r1; i++)                                  

    for (j = 0; j < c2; j++)                              

    {                                                     

        sum = 0;                                          

                                                          

        for (k = 0; k < c1; k++)                          

            sum += x[k + i*c1] * y[j + k*c2];             

                                                          

        r[j + i*c2] = sum;                                

    }                                                     

}





/* ======================================================================== */

/*  End of file: DSPF_sp_mat_mul.c                                               */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_mat_tra/1117057364  473   0     0       3757      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_mat_trans(                                                 */

/*                            const float *restrict x,                      */

/*                            int rows,                                     */

/*                            int cols,                                     */

/*                            float *restrict r)                            */

/*                                                                          */

/*          x[r1*c1]:  Input matrix containing r1*c1 floating point         */

/*                     numbers having r1 rows and c1 columns.               */

/*          rows    :  Number of rows in Matrix x.                          */

/*                     Also Number of columns in matrix y                   */

/*          cols    :  No. of columns in Matrx x.                           */

/*                     Also no. of rows in Matrix y.                        */

/*          y[c1*c2]:  Output matrix containing c1*r1 floating point        */

/*                     numbers having c1 rows and r1 columns.               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*    This function transposes the input matrix x[] and writes the          */

/*    result to matrix r[].                                                 */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */





#pragma CODE_SECTION(DSPF_sp_mat_trans,    ".text:ansi");



#include "DSPF_sp_mat_trans.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_mat_trans(const    float *restrict x, int rows, int cols, float *restrict r)

{



/* ======================================================================== */

/* ======================================================================== */



   int i,j;

   

   for(i=0; i<cols; i++)

      for(j=0; j<rows; j++)

         r[i * rows + j] = x[i + cols * j];

}



/* ======================================================================== */

/*  End of file: DSPF_sp_mat_trans.c                                             */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_mat_mul/1117057364  494   0     0       5832      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_mat_mul_cplx(                                              */

/*                              const float* x,                             */

/*                              int r1,                                     */

/*                              int c1,                                     */

/*                              const float* y,                             */

/*                              int c2,                                     */

/*                              float* restrict r                           */

/*                           )                                              */

/*                                                                          */

/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */

/*                          floating point numbers having r1 rows and c1    */

/*                          columns of complex numbers.                     */

/*            r1        :   Number of rows in Matrix x.                     */

/*            c1        :   No. of columns in Matrx x.                      */

/*                          Also no. of rows in Matrix y.                   */

/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */

/*                          floating point numbers having c1 rows and c2    */

/*                          columns of complex numbers.                     */

/*            c2        :   No. of columns in Matrix y.                     */

/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */

/*                          point numbers having c1 rows and c2 columns of  */

/*                          complex numbers.                                */

/*                                                                          */

/*                          Complex numbers are stored consecutively with   */

/*                          Real values are stored in even word positions   */

/*                          and imaginary values in odd positions.          */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*        This function computes the expression "r = x * y" for the         */

/*        matrices x and y. The columnar dimension of x must match the row  */

/*        dimension of y. The resulting matrix has the same number of rows  */

/*        as x and the same number of columns as y.                         */

/*                                                                          */

/*        Each element of Matrices are assumed to be complex numbers with   */

/*        Real values are stored in even word positions and imaginary       */

/*        values in odd positions.                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */



#pragma CODE_SECTION(DSPF_sp_mat_mul_cplx,    ".text:ansi");



#include "DSPF_sp_mat_mul_cplx.h"



/* ======================================================================== */

/* ======================================================================== */



void DSPF_sp_mat_mul_cplx(const    float* x, int r1, int c1, const float* y, int c2, float* restrict r)

{



/* ======================================================================== */

/* ======================================================================== */



    float real, imag;

    int i, j, k;

    

    for(i = 0; i < r1; i++)    

    {

        for(j = 0; j < c2; j++)

        {

            real=0; 

            imag=0;

            

            for(k = 0; k < c1; k++)

            {

                real += (x[i * 2 * c1 + 2 * k] * y[k * 2 * c2 + 2 * j] 

                        - x[i * 2 * c1 + 2 * k + 1] * y[k * 2 * c2 + 2 * j + 1]);

                         

                imag += (x[i * 2 * c1 + 2 * k] * y[k * 2 * c2 + 2 * j + 1] + 

                         x[i * 2 * c1 + 2 * k + 1] * y[k * 2 * c2 + 2 * j]);

            }

            r[i * 2 * c2 + 2 * j] = real;

            r[i * 2 * c2 + 2 * j + 1] = imag;

       }

   }

}



/* ======================================================================== */

/*  End of file: DSPF_sp_mat_mul_cplx.c                                          */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_blk_mov/1117057365  518   0     0       3464      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_blk_move -- Single Precision Block Move                          */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_blk_move                                                   */
/*                     (                                                    */
/*                         const float    *r,                               */
/*                         const float *  restrict r,                       */
/*                         int            nx,                               */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data to be moved.                       */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:        Number of floats to move.                               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine moves nx floats from memory location pointed to by x  */
/*       to a separate memory location pointed to by r.                     */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_sp_blk_move,    ".text:ansi");

#include "DSPF_sp_blk_move.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_sp_blk_move(const    float * x, float *restrict r, int nx)
{

/* ======================================================================== */
/* ======================================================================== */
     int i;

     for (i = 0 ; i < nx; i++)
         r[i] = x[i];


}

/* ======================================================================== */
/*  End of file: DSPF_sp_blk_move.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_blk_eswap1/1117057366  538   0     0       4331      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap16                                                   */
/*                     (                                                    */
/*                         short * restrict x,                              */
/*                         void * restrict r,                               */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of shorts (16-bit values) to endian-swap.          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*         The date in the x array is endian swapped, meaning that the      */
/*      byte-order of the bytest within wach half-word (short) of x is      */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_blk_eswap16,    ".text:ansi");

#include "DSPF_blk_eswap16.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_blk_eswap16(short    * restrict x, short * restrict r, int nx)
{

/* ======================================================================== */
/* ======================================================================== */
    int i;
    char *_src, *_dst;

    if (r)
    {
        _src = (char *)x;
        _dst = (char *)r;
    } else
    {
        _src = (char *)x;
        _dst = (char *)x;
    }

    for (i = 0; i < nx; i++)
    {
        char t0, t1;
        t0 = _src[i*2 + 1];
        t1 = _src[i*2 + 0];
        _dst[i*2 + 0] = t0;
        _dst[i*2 + 1] = t1;
    }

}

/* ======================================================================== */
/*  End of file: DSPF_blk_eswap16.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap3/1117057367  558   0     0       4457      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap32                                                   */
/*                     (                                                    */
/*                         float * restrict x,                              */
/*                         float * restrict r,                              */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of words (32-bit values) to endian-swap.           */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytest within wach word of x is                   */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_blk_eswap32,    ".text:ansi");

#include "DSPF_blk_eswap32.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_blk_eswap32(float    * restrict x, float * restrict r, int nx)
{

/* ======================================================================== */
/* ======================================================================== */
    int i;
    char *_src, *_dst;

    if (r)
    {
        _src = (char *)x;
        _dst = (char *)r;
    } else
    {
        _src = (char *)x;
        _dst = (char *)x;
    }

    for (i = 0; i < nx; i++)
    {
        char t0, t1, t2, t3;
        t0 = _src[i*4 + 3];
        t1 = _src[i*4 + 2];
        t2 = _src[i*4 + 1];
        t3 = _src[i*4 + 0];

        _dst[i*4 + 0] = t0;
        _dst[i*4 + 1] = t1;
        _dst[i*4 + 2] = t2;
        _dst[i*4 + 3] = t3;
    }

}

/* ======================================================================== */
/*  End of file: DSPF_blk_eswap32.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap6/1117057368  578   0     0       4711      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap64                                                   */
/*                     (                                                    */
/*                         double * restrict x,                             */
/*                         double * restrict r,                             */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of double words (64-bit values) to endian-swap.    */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytes within each double word of x is             */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_blk_eswap64,    ".text:ansi");

#include "DSPF_blk_eswap64.h"

/* ======================================================================== */
/* ======================================================================== */

void DSPF_blk_eswap64(double    * restrict x, double * restrict r, int nx)
{

/* ======================================================================== */
/* ======================================================================== */
    int i;
    char *_src, *_dst;

    if (r)
    {
        _src = (char *)x;
        _dst = (char *)r;
    } else
    {
        _src = (char *)x;
        _dst = (char *)x;
    }

    for (i = 0; i < nx; i++)
    {
        char t0, t1, t2, t3, t4, t5, t6, t7;

        t0 = _src[i*8 + 7];
        t1 = _src[i*8 + 6];
        t2 = _src[i*8 + 5];
        t3 = _src[i*8 + 4];
        t4 = _src[i*8 + 3];
        t5 = _src[i*8 + 2];
        t6 = _src[i*8 + 1];
        t7 = _src[i*8 + 0];


        _dst[i*8 + 0] = t0;
        _dst[i*8 + 1] = t1;
        _dst[i*8 + 2] = t2;
        _dst[i*8 + 3] = t3;
        _dst[i*8 + 4] = t4;
        _dst[i*8 + 5] = t5;
        _dst[i*8 + 6] = t6;
        _dst[i*8 + 7] = t7;
    }

}

/* ======================================================================== */
/*  End of file: DSPF_blk_eswap64.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_fltoq15.c/ 1117057369  0     0     0       4075      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       */

/*                                                                          */

/*  USAGE                                                                   */

/*     This routine is C-callable and can be called as:                     */

/*                                                                          */

/*     void DSPF_fltoq15                                                         */

/*     (                                                                    */

/*         const float* restrict x,                                         */

/*         short*       restrict r,                                         */

/*         int         nx                                                   */

/*     );                                                                   */

/*                                                                          */

/*     x[nx] :  Input array contaning values of type float                  */

/*     r[nx] :  Output array contains Q15 equivalents of x[nx]              */

/*     nx    :  Number of elements in both arrays                           */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*     Convert the IEEE floating point numbers stored in vector x[] into    */

/*     Q.15 format numbers stored in vector r[]. Results will be rounded    */

/*     towards negative infinity. All values that exceed the size limit     */

/*     will be saturated to 0x7fff if value is positive and 0x8000 if       */

/*     value is negative.                                                   */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_fltoq15,    ".text:ansi");



#include "DSPF_fltoq15.h"

#include <math.h>



void DSPF_fltoq15(const    float * x, short * restrict r, int nx)

{



           int i, a;                                                       

                                                                           

           for(i = 0; i < nx; i++)                                         

           {                                                               

               a = floor(32768 * x[i]);

                                                                           

               // saturate to 16-bit //                                    

               if (a > 32767)  

                    a =  32767;                                   

               if (a < -32768) 

                    a = -32768;                                   

               r[i] = (short) a;                                           

           }                                                               

}



/* ======================================================================== */

/*  End of file: DSPF_fltoq15.c                                                  */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_minerr./1117057370  598   0     0       4427      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      */

/*      dot product                                                         */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,    */

/*                                              int *restrict max_index)    */

/*                                                                          */

/*          GSP0_TABLE[256*9]: GSP0 terms array.                            */

/*          errCoefs[9]:       Array of error coefficients.                 */

/*                             Must be Double word aligned.                 */

/*          max_index:         Index to GSP0_TABLE[max_index], the first    */

/*                             element of the 9-element vector that         */

/*                             resulted in the maximum dot product.         */

/*          return float       Maximum dot product result.                  */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       Performs a dot product on 256 pairs of 9 element vectors and       */

/*       searches for the pair of vectors which produces the maximum dot    */

/*       product result. This is a large part of the VSELP vocoder          */

/*       codebook search.                                                   */

/*                                                                          */

/*       The function stores the index to the first element of the          */

/*       9-element vector that resulted in the maximum dot product in the   */

/*       memory loaction Pointed by max_index. The maximum dot product      */

/*       value is returned by the function.                                 */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */



#pragma CODE_SECTION(DSPF_sp_minerr,    ".text:ansi");



#include "DSPF_sp_minerr.h"

#define GSP0_TERMS 9

#define GSP0_NUM 256



/* ======================================================================== */

/* ======================================================================== */



float DSPF_sp_minerr(const    float* GSP0_TABLE, const float* errCoefs, int *restrict max_index)

{



/* ======================================================================== */

/* ======================================================================== */

           float val;

           float maxVal = _itof(0xFF800000);

           int i, j;

           

           for (i = 0; i < GSP0_NUM; i++)

               {

               for (val = 0, j = 0; j < GSP0_TERMS; j++)

                   val += GSP0_TABLE[i*GSP0_TERMS+j] * errCoefs[j];

               if (val > maxVal)

                  {

                  maxVal = val;

                  *max_index = i*GSP0_TERMS;

                  }

               }

           return (maxVal);

}



/* ======================================================================== */

/*  End of file: DSPF_sp_minerr.c                                                */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_q15tofl.c/ 1117057370  0     0     0       3108      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       */

/*      format                                                              */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*    This routine is C Callable and can be called as:                      */

/*                                                                          */

/*      float DSPF_q15tofl(short *x, float *r, int nx);                          */

/*                                                                          */

/*      x     : Input array containing shorts in Q15 format                 */

/*      r     : Output array containing equivalent floats                   */

/*      nx    : Number of values in the x vector                            */

/*                                                                          */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*      This routine converts data in the Q15 format into IEEE Single Preci */

/*      floating point.                                                     */

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_q15tofl,    ".text:ansi");



#include "DSPF_q15tofl.h"



void DSPF_q15tofl(const    short * x, float * restrict r, int nx)

{

        int i;

        

        for (i=0;i<nx;i++)                                         

             r[i]=(float)x[i]/0x8000;                              



}



/* ======================================================================== */

/*  End of file: DSPF_q15tofl.c                                                  */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_dp_lms.c/  1117057372  0     0     0       9360      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C callable, and has the following C prototype:       */
/*                                                                          */
/*     double DSPF_dp_lms (double *x,                                            */
/*                    double *h,                                             */
/*                    double *desired,                                      */
/*                    double *r,                                            */
/*                    double adaptrate,                                     */
/*                    double error,                                         */
/*                    int nh,                                               */
/*                    int nr                                                */
/*                    )                                                     */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  */
/*     signal and a desired input signal, the filter produces an output     */
/*     signal, the final coefficient values and returns the final output    */
/*     error signal.                                                        */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*   1. The inner loop is unrolled Two times to allow update of             */
/*      two coefficients in the kernel.                                     */
/*                                                                          */
/*   2. The 'error' term needs to be computed in the outer loop             */
/*      before a new iteration of the inner loop can start. As a            */
/*      result the prolog cannot be placed in parallel with epilog          */
/*      (after the loop kernel).                                            */
/*                                                                          */
/*  3. Register sharing is used to make optimal use of available            */
/*      registers.                                                          */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*   1. The inner loop counter must be a multiple of 2 and >=2.             */
/*   2. Little endianness is assumed.                                       */
/*   3. Extraneous loads are allowed in the program.                        */
/*   4. The coefficient array is assumed to be in reverse order,            */
/*      i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   This is the C equivalent of the Assembly Code without                  */
/*   restrictions.                                                          */
/*                                                                          */
/*   Note that the assembly code is hand optimized and restrictions         */
/*   may apply.                                                             */
/*                                                                          */
/*   double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou */
/*        int nr, double error)                                             */
/*   {                                                                      */
/*       int i,j;                                                           */
/*       double sum;                                                        */
/*                                                                          */
/*       for (i = 0; i < nr; i++)                                           */
/*       {                                                                  */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*           h[j] = h[j] + (ar*error*x[i+j-1]);                             */
/*        }                                                                 */
/*                                                                          */
/*       sum = 0.0f;                                                        */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*          sum += h[j] * x[i+j];                                           */
/*        }                                                                 */
/*       y[i] = sum;                                                        */
/*       error = d[i] - sum;                                                */
/*      }                                                                   */
/*      return error;                                                       */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*    (4*nh + 47) nr + 27                                                   */
/*    eg. for nh = 24 and nr = 36                                           */
/*    cycles = 5175                                                         */
/*                                                                          */
/* CODESIZE                                                                 */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_lms,    ".text:ansi");

#include "DSPF_dp_lms.h"


double DSPF_dp_lms(double    * x, double * h, double * desired, double * r, double adaptrate, double error, int nh, int nr)
{

int i,j;
double sum;

 for (i = 0; i < nr; i++)
  {
    for (j = 0; j < nh; j++)
    {
    h[j] = h[j] +adaptrate*error*x[i+j-1];
    }

    sum = 0.0f;

    for (j = 0; j < nh; j++)
    {
      sum += h[j] * x[i+j];
    }

    r[i] = sum;
    error = desired[i] - sum;

    }
 return error;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_lms.c                                                   */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_autocor/1117057372  616   0     0       3954      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_autocor -- double Precision autocorrelation                      */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*                                                                          */
/*      r  = Pointer to output array of autocorrelation of length nr        */
/*      x  = Pointer to input array of length nx+nr. Input data must        */
/*           be padded with nr consecutive zeros at the beginning.          */
/*      nx = Length of autocorrelation vector.                              */
/*      nr = Length of lags.                                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the autocorrelation of the input array x.     */
/*      is assumed that the length of the input array, x, is a              */
/*      multiple of 2 and the length of the output array, r, is a           */
/*      multiple of 4. The assembly routine computes 4 output samples       */
/*      at a time. It is assumed that input vector x is padded with nr      */
/*      no of zeros in the beginning.                                       */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_autocor,    ".text:ansi");

#include "DSPF_dp_autocor.h"


void DSPF_dp_autocor(double    *restrict r, double *restrict x, int nx, int nr)
{

int i,k;
double sum;
for (i = 0; i < nr; i++)
 {
    sum = 0;
    for (k = nr; k < nx+nr; k++)
        sum += x[k] * x[k-i];
    r[i] = sum ;
  }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_autocor.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_bitrev_/1117057374  635   0     0       17990     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         */
/*      numbers                                                             */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                */
/*                                                                          */
/*     x      : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx doubles                                       */
/*     index  : Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is a double array of length 2*nx containing Double         */
/*     precision floating point complex pairs of data. This routine         */
/*     requires the index array provided by the program below.              */
/*     This index should be generated at compile time not by the DSP.       */
/*                                                                          */
/*     TI retains all rights, title and interest in this code and only      */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*     1. nx must be a power of 2.                                          */
/*     2. The table from bitrev_index is already created.                   */
/*     3. The array x is actually an array of 2*nx doubles.                 */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                */
/*      {                                                                   */
/*         int    i;                                                        */
/*         short  i0, i1, i2;                                               */
/*         short  j0, j1, j2;                                               */
/*         double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       */
/*         double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       */
/*         short  t;                                                        */
/*         int    a, b, ia, ib, ibs;                                        */
/*         int    mask;                                                     */
/*         int    nbits, nbot, ntop, ndiff, n2, halfn;                      */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*            i = i >> 1;                                                   */
/*            nbits++;                                                      */
/*         }                                                                */
/*                                                                          */
/*         nbot    = nbits >> 1;                                            */
/*         ndiff   = nbits & 1;                                             */
/*         ntop    = nbot + ndiff;                                          */
/*         n2       = 1 << ntop;                                            */
/*         mask    = n2 - 1;                                                */
/*         halfn   = nx >> 1;                                               */
/*                                                                          */
/*         for (i0 = 0; i0 < halfn; i0 += 2)                                */
/*         {                                                                */
/*             b       = i0 & mask;                                         */
/*             a       = i0 >> nbot;                                        */
/*             if (!b) ia = index[a];                                       */
/*             ib      = index[b];                                          */
/*             ibs     = ib << nbot;                                        */
/*                                                                          */
/*             j0      = ibs + ia;                                          */
/*             t       = i0 < j0;                                           */
/*             xi0r     = x[2*i0];                                          */
/*             xi0i     = x[2*i0+1];                                        */
/*             xj0r     = x[2*j0];                                          */
/*             xj0i     = x[2*j0+1];                                           */
/*             if (t)                                                       */
/*             {                                                            */
/*                x[2*i0]   = xj0r;                                         */
/*                x[2*i0+1] = xj0i;                                         */
/*                x[2*j0]   = xi0r;                                         */
/*                x[2*j0+1] = xi0i;                                         */
/*              }                                                           */
/*                                                                          */
/*             i1      = i0 + 1;                                            */
/*             j1      = j0 + halfn;                                        */
/*             xi1r    = x[2*i1];                                           */
/*             xi1i    = x[2*i1+1];                                         */
/*             xj1r    = x[2*j1];                                           */
/*             xj1i    = x[2*j1+1];                                         */
/*                                                                          */
/*             x[2*i1]   = xj1r;                                            */
/*             x[2*i1+1] = xj1i;                                            */
/*             x[2*j1]   = xi1r;                                            */
/*             x[2*j1+1] = xi1i;                                            */
/*                                                                          */
/*             i2      = i1 + halfn;                                        */
/*             j2      = j1 + 1;                                            */
/*                                                                          */
/*             xi2r    = x[2*i2];                                           */
/*             xi2i    = x[2*i2+1];                                         */
/*             xj2r    = x[2*j2];                                           */
/*             xj2i    = x[2*j2+1];                                         */
/*             if (t)                                                       */
/*             {                                                            */
/*             x[2*i2]   = xj2r;                                            */
/*             x[2*i2+1] = xj2i;                                            */
/*             x[2*j2]   = xi2r;                                            */
/*             x[2*j2+1] = xi2i;                                            */
/*             }                                                            */
/*           }                                                              */
/*                                                                          */
/*         }                                                                */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1. The index table can be generated using the bitrev_index           */
/*        function provided in the dsplib\support\fft directory.            */
/*     2. If nx <= 4K one can use the char (8-bit) data type for            */
/*        the "index" variable. This would require changing the LDH when    */
/*        loading index values in the assembly routine to LDB. This would   */
/*        further reduce the size of the Index Table by half its size.      */
/*                                                                          */
/*     3. Endian: LITTLE ENDIAN configuration used.                         */
/*                                                                          */
/*     4. Interruptibility: This code is interrupt tolerant, but not        */
/*        interruptible.                                                    */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     5*nx + 33                                                            */
/*     e.g. nx = 128, cycles = 673                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     736 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_bitrev_cplx,    ".text:ansi");

#include "DSPF_dp_bitrev_cplx.h"


void DSPF_dp_bitrev_cplx(double    * x, short * index, int n)
{

        int    i;
        short  i0, i1, i2;
        short  j0, j1, j2;
        double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;
        double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;
        short  t;
        int    a, b, ia, ib, ibs;
        int    mask;
        int    nbits, nbot, ntop, ndiff, n2, halfn;

        nbits = 0;
        i = n;
        while (i > 1)
        {
           i = i >> 1;
           nbits++;
        }

        nbot    = nbits >> 1;
        ndiff   = nbits & 1;
        ntop    = nbot + ndiff;
        n2      = 1 << ntop;
        mask    = n2 - 1;
        halfn   = n >> 1;

        for (i0 = 0; i0 < halfn; i0 += 2)
        {
            b       = i0 & mask;
            a       = i0 >> nbot;
            if (!b) ia = index[a];
            ib      = index[b];
            ibs     = ib << nbot;

            j0      = ibs + ia;
            t       = i0 < j0;
            xi0r     = x[2*i0];
            xi0i     = x[2*i0+1];
            xj0r     = x[2*j0];
            xj0i     = x[2*j0+1];

            if (t)
            {
              x[2*i0] = xj0r;
              x[2*i0+1]=xj0i;
              x[2*j0] = xi0r;
              x[2*j0+1] = xi0i;
            }

            i1      = i0 + 1;
            j1      = j0 + halfn;
            xi1r    = x[2*i1];
            xi1i    = x[2*i1+1];
            xj1r    = x[2*j1];
            xj1i    = x[2*j1+1];

            x[2*i1]   = xj1r;
            x[2*i1+1] = xj1i;
            x[2*j1]   = xi1r;
            x[2*j1+1] = xi1i;

            i2      = i1 + halfn;
            j2      = j1 + 1;
            xi2r    = x[2*i2];
            xi2i    = x[2*i2+1];

            xj2r     = x[2*j2];
            xj2i     = x[2*j2+1];
            if (t)
            {
              x[2*i2]   = xj2r;
              x[2*i2+1] = xj2i;
              x[2*j2]   = xi2r;
              x[2*j2+1] = xi2i;
            }
          }

}

/* ======================================================================== */
/*  End of file: DSPF_dp_bitrev_cplx.c                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_cfftr4_/1117057375  658   0     0       15172     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      */
/*      Frequency radix-4 FFT with complex input                            */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*                                                                          */
/*  x : Pointer to an array holding the input and output floating           */
/*      point array which contains 'n' complex points                       */
/*  w : Pointer to an array holding the coefficient floating point          */
/*      array which contains 3*n/4 complex numbers                          */
/*  n : Number of complex points in x                                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)               */
/*  complex radix 4 FFT with digit-reversed output and normal               */
/*  order input.  The number of points, 'n', must be a power                */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   */
/*  in-place routine in the sense that the output is written                */
/*  over the input.  It is not an in-place routine in the                   */
/*  sense that the input is in normal order and the output is               */
/*  in digit-reversed order.                                                */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex          */
/*  coefficients (3*n/2 values).                                            */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the               */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             */
/*  are in normal order.  Each real and imaginary output value              */
/*  is interleaved in the 'x' array and the complex numbers are             */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and                 */
/*  imaginary values of the coefficients are interleaved in the             */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           */
/*  are in normal order.                                                    */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                        */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written               */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                  */
/*  performing the complex conjugate on the input complex numbers           */
/*  (negating the imaginary value), and dividing the result by n.           */
/*  Another method to use the FFT to perform an inverse FFT, is to          */
/*  swap the real and imaginary values of the input and the result,         */
/*  and divide the result by n.  In either case, the input is still         */
/*  in normal order and the output is still in digit-reversed order.        */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse              */
/*  FFT by using the complex conjugate of the coefficients as               */
/*  you can do with the complex radix 2 FFT.                                */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),        */
/*  the digit-reversed locations can be calculated by reversing the         */
/*  order of the bit pairs of the labels.  For example, for a 1024          */
/*  point FFT, the digit reversed location for                              */
/*  617d = 1001101001b = 10 01 10 10 01  is                                 */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                    */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*  1.  There are no special alignment requirements.                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent for the assembly code.  Note that              */
/*  the assembly code is hand optimized and restrictions may                */
/*  apply.                                                                  */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*  {                                                                       */
/*      short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              */
/*      double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               */
/*      double si1, si2, si3;                                               */
/*      n2 = n;                                                             */
/*      ie = 1;                                                             */
/*      for(k=n; k>1; k>>=2)                                                */
/*      {                                                                   */
/*         n1 = n2;                                                         */
/*         n2 >>= 2;                                                        */
/*         ia1 = 0;                                                         */
/*         for(j=0; j<n2; j++)                                              */
/*         {                                                                */
/*             ia2 = ia1 + ia1;                                             */
/*             ia3 = ia1 + ia2;                                             */
/*             co1 = w[ia1*2];                                              */
/*             si1 = w[ia1*2 + 1];                                          */
/*             co2 = w[ia2*2];                                              */
/*             si2 = w[ia2*2 + 1];                                          */
/*             co3 = w[ia3*2];                                              */
/*             si3 = w[ia3*2 + 1];                                          */
/*             ia1 += ie;                                                   */
/*             for(i0=j; i0<n; i0+=n1)                                      */
/*             {                                                            */
/*                 i1 = i0 + n2;                                            */
/*                 i2 = i1 + n2;                                            */
/*                 i3 = i2 + n2;                                            */
/*                 r1 = x[i0*2]   + x[i2*2];                                */
/*                 r3 = x[i0*2]   - x[i2*2];                                */
/*                 s1 = x[i0*2+1] + x[i2*2+1];                              */
/*                 s3 = x[i0*2+1] - x[i2*2+1];                              */
/*                 r2 = x[i1*2]   + x[i3*2];                                */
/*                 r4 = x[i1*2]   - x[i3*2];                                */
/*                 s2 = x[i1*2+1] + x[i3*2+1];                              */
/*                 s4 = x[i1*2+1] - x[i3*2+1];                              */
/*                 x[i0*2]   = r1 + r2;                                     */
/*                 r2        = r1 - r2;                                     */
/*                 r1        = r3 - s4;                                     */
/*                 r3        = r3 + s4;                                     */
/*                 x[i0*2+1] = s1 + s2;                                     */
/*                 s2        = s1 - s2;                                     */
/*                 s1        = s3 + r4;                                     */
/*                 s3        = s3 - r4;                                     */
/*                 x[i1*2]   = co1*r3 + si1*s3;                             */
/*                 x[i1*2+1] = co1*s3 - si1*r3;                             */
/*                 x[i2*2]   = co2*r2 + si2*s2;                             */
/*                 x[i2*2+1] = co2*s2 - si2*r2;                             */
/*                 x[i3*2]   = co3*r1 + si3*s1;                             */
/*                 x[i3*2+1] = co3*s1 - si3*r1;                             */
/*            }                                                             */
/*         }                                                                */
/*         ie <<= 2;                                                        */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. The twiddle factor array w can be generated by the tw_r4fft       */
/*        function provided in dsplib\support\fft\tw_r4fft.c. The exe       */
/*        file for this function, dsplib\bin\tw_r4fft.exe, can be           */
/*        used dump the twiddle factor array into a file.                   */
/*     2. The function bit_rev in dsplib\support\fft can be used to         */
/*        bit-reverse the output array to convert it into normal order.     */
/*     3. Endian: This code is LITTLE  ENDIAN.                              */
/*     4. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    14*n*log4(n) + 46                                                     */
/*    eg. if n = 256, cycles = 14382.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1344 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_cfftr4_dif,    ".text:ansi");

#include "DSPF_dp_cfftr4_dif.h"


void DSPF_dp_cfftr4_dif(double    * x, double * w, short n)
{


        short  n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;
        double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3, si1, si2, si3;

        n2 = n;
        ie = 1;
        for(k=n; k>1; k>>=2)
        {
           n1 = n2;
           n2 >>= 2;
           ia1 = 0;
           for(j=0; j<n2; j++)
           {

               ia2 = ia1 + ia1;
               ia3 = ia1 + ia2;
               co1 = w[ia1*2];
               si1 = w[ia1*2 + 1];
               co2 = w[ia2*2];
               si2 = w[ia2*2 + 1];
               co3 = w[ia3*2];
               si3 = w[ia3*2 + 1];
               ia1 += ie;
               for(i0 = j; i0 < n; i0 += n1)
               {
                   i1 = i0 + n2;
                   i2 = i1 + n2;
                   i3 = i2 + n2;
                   r1 = x[i0*2]   + x[i2*2];
                   r3 = x[i0*2]   - x[i2*2];
                   s1 = x[i0*2+1] + x[i2*2+1];
                   s3 = x[i0*2+1] - x[i2*2+1];
                   r2 = x[i1*2]   + x[i3*2];
                   r4 = x[i1*2]   - x[i3*2];
                   s2 = x[i1*2+1] + x[i3*2+1];
                   s4 = x[i1*2+1] - x[i3*2+1];
                   x[i0*2]   = r1 + r2;
                   r2        = r1 - r2;
                   r1        = r3 - s4;
                   r3        = r3 + s4;
                   x[i0*2+1] = s1 + s2;
                   s2        = s1 - s2;
                   s1        = s3 + r4;
                   s3        = s3 - r4;
                   x[i1*2]   = co1*r3 + si1*s3;
                   x[i1*2+1] = co1*s3 - si1*r3;
                   x[i2*2]   = co2*r2 + si2*s2;
                   x[i2*2+1] = co2*s2 - si2*r2;
                   x[i3*2]   = co3*r1 + si3*s1;
                   x[i3*2+1] = co3*s1 - si3*r1;
               }
           }
           ie <<= 2;
        }

}

/* ======================================================================== */
/*  End of file: DSPF_dp_cfftr4_dif.c                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_cfftr2./1117057376  680   0     0       20438     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT   */
/*      with complex input                                                  */
/*                                                                          */
/* USAGE                                                                    */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      This routine is used to compute the Complex, Radix-2, Fast          */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)           // Bit reverse the output if              */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*      }                                                                   */
/*                                                                          */
/*      main fft of size N can be divided into several steps (where         */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_cfftr2(N, x, w, 1);                                              */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_cfftr2(N, x, w, N/4);                                            */
/*                                                                          */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire data set.   */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array, in the    */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   - s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   + s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          //  table of size n complex numbers (or 2*n numbers)            */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_cfftr2,    ".text:ansi");

#include "DSPF_dp_cfftr2.h"


void DSPF_dp_cfftr2(int    n, double * x, double * w, int n_min)
{

           int n2, ie, ia, i, j, k, m;
           double rtemp, itemp, c, s;

           n2 = n;
           ie = 1;

           for(k = n; k > n_min; k >>= 1)
           {
              n2 >>= 1;
              ia = 0;
              for(j=0; j < ie; j++)
              {
                 for(i=0; i < n2; i++)
                 {
                    c = w[2*i];
                    s = w[2*i+1];
                    m = ia + n2;
                    rtemp     = x[2*ia]   - x[2*m];
                    x[2*ia]   = x[2*ia]   + x[2*m];
                    itemp     = x[2*ia+1] - x[2*m+1];
                    x[2*ia+1] = x[2*ia+1] + x[2*m+1];
                    x[2*m]    = c*rtemp   - s*itemp;
                    x[2*m+1]  = c*itemp   + s*rtemp;
                    ia++;
                 }
                 ia += n2;
              }
              ie <<= 1;
              w = w + k;
           }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_cfftr2.c                                                 */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_icfftr2/1117057377  698   0     0       22827     `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      */

/*      FFT with complex input                                              */

/*                                                                          */

/* USAGE                                                                    */

/*                                                                          */

/*        This routine is C-callable and can be called as:                  */

/*                                                                          */

/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */

/*                                                                          */

/*        x : input and output sequences (dim-n)      (input/output)        */

/*            x has n complex numbers (2*n DP values).                      */

/*            The real and imaginary values are interleaved in memory.      */

/*            The input is in normal order and output is in bit-reversed    */

/*            Order.                                                        */

/*        w : FFT coefficients (dim-n)                (input)               */

/*            w has n complex numbers (n DP values).                        */

/*            FFT coeficients are in a special sequence so that FFT can     */

/*            be called on smaller input sets multiple times to avoid       */

/*            cache thrashing.                                              */

/*            The real and imaginary values are interleaved in memory.      */

/*        n : FFT size which is a power of 2 and > 4  (input)               */

/*                                                                          */

/*                                                                          */

/* DESCRIPTION                                                              */

/*                                                                          */

/*      This routine is used to compute the Inverse Complex, Radix-2, Fast  */

/*      Fourier Transform of a double precision complex sequence of size    */

/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */

/*      normal order input and normal order coefficents (twiddle factors)   */

/*      in a special sequence and produces results that are in              */

/*      bit-reversed order.                                                 */

/*                                                                          */

/*      The input can be broken into smaller parts and called multiple      */

/*      times to avoid cache thrashing.                                     */

/*                                                                          */

/*      How to use                                                          */

/*                                                                          */

/*      void main(void)                                                     */

/*      {                                                                   */

/*         gen_w_r2(w, N);         // Generate coefficient table            */

/*                                 // in normal order                       */

/*                                 // Function is given in C-CODE section   */

/*                                                                          */

/*        DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in      */

/*                                 // order bit-reversed                    */

/*                                                                          */

/*        bit_rev(x, N)            // Bit reverse the output if             */

/*                                 // normal order output is needed         */

/*                                 // Function is given in C-CODE section   */

/*                                                                          */

/*        divide(x, N);            // scale inverse FFT output              */

/*                                 // result is the same as original        */

/*                                 // input                                 */

/*                                                                          */

/*     }                                                                    */

/*                                                                          */

/*      main Inverse fft of size N can be divided into several steps (where */

/*      number of steps is a power of 2), allowing as much data             */

/*      reuse as possible.                                                  */

/*                                                                          */

/*      For example the following function                                  */

/*      DSPF_dp_icfftr2(N, x, w, 1);                                             */

/*                                                                          */

/*      is equivalent to:                                                   */

/*                                                                          */

/*      DSPF_dp_icfftr2(N, x, w, N/4);                                           */

/*                                                                          */

/*      DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                 */

/*      DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                 */

/*      DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                 */

/*      DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                 */

/*                                                                          */

/*      Notice how the 1st icfft function is called on the entire data set. */

/*      It covers the 1st pass of the fft until the butterfly size is       */

/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */

/*      size. These continue down to the end when the buttly is of size     */

/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */

/*      for the last 4 calls. This is because the twiddle factor array      */

/*      is composed of successively decimated versions of the main array.   */

/*                                                                          */

/*      The twiddle factor array is composed of log2(N) sets of twiddle     */

/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */

/*      for each stage of the fft can be calculated by summing these        */

/*      indices up appropriately. For example, if we are dividing the       */

/*      input into 2 parts then index into this array should be N, if we    */

/*      are dividing into 4 parts then index into this array should be      */

/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */

/*                                                                          */

/*      For multiple iffts they can share the same table by calling the     */

/*      small iffts from further down in the twiddle factor array, in the   */

/*      same way as the decomposition works for more data reuse.            */

/*                                                                          */

/*      The functions for creating this special sequence of twiddle         */

/*      factors and bit-reversal are provided in the C CODE section.        */

/*                                                                          */

/*      In general if divide the input into NO_OF_DIV parts we can call     */

/*      the function as follows:                                            */

/*                                                                          */

/*      // Divide the input into NO_OF_DIV parts                            */

/*      DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                   */

/*                                                                          */

/*                                                                          */

/*      // Find out the index into twiddle factor array                     */

/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */

/*      {                                                                   */

/*         w_index += j;                                                    */

/*      }                                                                   */

/*      w_index = N * w_index / NO_OF_DIV;                                  */

/*                                                                          */

/*      // Call the Function a subset of inputs                             */

/*      for(i=0; i<NO_OF_DIV; i++)                                          */

/*      {                                                                   */

/*         DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);  */

/*      }                                                                   */

/*                                                                          */

/* TECHNIQUES                                                               */

/*                                                                          */

/*      1. Outer loop instructions are executed in parallel with the        */

/*         inner loop epilog.                                               */

/*                                                                          */

/* ASSUMPTIONS                                                              */

/*                                                                          */

/*      1. Both input x and coefficient w should be aligned on double       */

/*         word boundary.                                                   */

/*      2. n should be greater than 4 and a power of 2.                     */

/*                                                                          */

/* C CODE                                                                   */

/*                                                                          */

/*        This is the C equivalent of the assembly code without             */

/*        restrictions. Note that the assembly code is hand optimized       */

/*        and restrictions may apply.                                       */

/*                                                                          */

/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */

/*        {                                                                 */

/*             int n2, ie, ia, i, j, k, m;                                  */

/*             double rtemp, itemp, c, s;                                   */

/*                                                                          */

/*             n2 = n;                                                      */

/*             ie = 1;                                                      */

/*                                                                          */

/*             for(k = n; k > n_min; k >>= 1)                               */

/*              {                                                           */

/*                n2 >>= 1;                                                 */

/*                ia = 0;                                                   */

/*                for(j=0; j < ie; j++)                                     */

/*                {                                                         */

/*                 for(i=0; i < n2; i++)                                    */

/*                   {                                                      */

/*                      c = w[2*i];                                         */

/*                      s = w[2*i+1];                                       */

/*                      m = ia + n2;                                        */

/*                      rtemp     = x[2*ia]   - x[2*m];                     */

/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */

/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */

/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */

/*                      x[2*m]    = c*rtemp   + s*itemp;                    */

/*                      x[2*m+1]  = c*itemp   - s*rtemp;                    */

/*                      ia++;                                               */

/*                     }                                                    */

/*                  ia += n2;                                               */

/*                 }                                                        */

/*                ie <<= 1;                                                 */

/*                w = w + k;                                                */

/*             }                                                            */

/*         }                                                                */

/*                                                                          */

/*         The follwoing C code is used to generate the coefficient table.  */

/*                                                                          */

/*          #include <math.h>                                               */

/*          // generate real and imaginary twiddle                          */

/*          // table of size n complex numbers (or 2*n numbers)             */

/*                                                                          */

/*          void gen_w_r2(double* w, int n)                                 */

/*          {                                                               */

/*               int i, j=1;                                                */

/*               double pi = 4.0*atan(1.0);                                 */

/*               double e = pi*2.0/n;                                       */

/*               for(j=1; j < n; j <<= 1)                                   */

/*               {                                                          */

/*               for(i=0; i < ( n>>1 ); i += j)                             */

/*                  {                                                       */

/*                  *w++   = cos(i*e);                                      */

/*                  *w++   = -sin(i*e);                                     */

/*                  }                                                       */

/*               }                                                          */

/*          }                                                               */

/*                                                                          */

/*                                                                          */

/*          The follwoing C code is used to bit-reverse the output.         */

/*                                                                          */

/*          bit_rev(double* x, int n)                                       */

/*          {                                                               */

/*            int i, j, k;                                                  */

/*            double rtemp, itemp;                                          */

/*                                                                          */

/*            j = 0;                                                        */

/*            for(i=1; i < (n-1); i++)                                      */

/*            {                                                             */

/*              k = n >> 1;                                                 */

/*               while(k <= j)                                              */

/*               {                                                          */

/*                  j -= k;                                                 */

/*                  k >>= 1;                                                */

/*               }                                                          */

/*               j += k;                                                    */

/*               if(i < j)                                                  */

/*               {                                                          */

/*                  rtemp    = x[j*2];                                      */

/*                  x[j*2]   = x[i*2];                                      */

/*                  x[i*2]   = rtemp;                                       */

/*                  itemp    = x[j*2+1];                                    */

/*                  x[j*2+1] = x[i*2+1];                                    */

/*                  x[i*2+1] = itemp;                                       */

/*               }                                                          */

/*            }                                                             */

/*          }                                                               */

/*                                                                          */

/*      The follwoing C code is used to perform the final scaling           */

/*      of the IFFT:                                                        */

/*                                                                          */

/*      // divide each element of x by n                                    */

/*                                                                          */

/*      divide(double* x, int n)                                            */

/*      {                                                                   */

/*        int i;                                                            */

/*        double inv = 1.0 / n;                                             */

/*                                                                          */

/*         for(i=0; i < n; i++)                                             */

/*          {                                                               */

/*              x[2*i] = inv * x[2*i];                                      */

/*              x[2*i+1] = inv * x[2*i+1];                                  */

/*            }                                                             */

/*       }                                                                  */

/*                                                                          */

/* NOTES                                                                    */

/*                                                                          */

/*      1. The special sequence of twiddle factor array w can be generated  */

/*        using the gen_w_r2 function provided in the previous section.     */

/*                                                                          */

/*      2. Endian:This code is LITTLE ENDIAN.                               */

/*                                                                          */

/*      3. Interruptibility: This code is interrupt-tolerant but not        */

/*         interruptible.                                                   */

/*                                                                          */

/* CYCLES                                                                   */

/*                                                                          */

/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */

/*       eg. IF n = 64,  cycles = 1666                                      */

/*       eg. IF n = 32,  cycles = 754                                       */

/*                                                                          */

/* CODESIZE                                                                 */

/*                                                                          */

/*       1408 bytes                                                         */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#pragma CODE_SECTION(DSPF_dp_icfftr2,    ".text:ansi");



#include "DSPF_dp_icfftr2.h"





void DSPF_dp_icfftr2(int    n, double * x, double * w, int n_min)

{



     int n2, ie, ia, i, j, k, m;

      double rtemp, itemp, c, s;

        

           n2 = n;

           ie = 1;



           for(k = n; k > n_min; k >>= 1)

           {

              n2 >>= 1;

              ia = 0;

              for(j=0; j < ie; j++)

              {

                 for(i=0; i < n2; i++)

                 {

                    c = w[2*i];

                    s = w[2*i+1];

                    m = ia + n2;

                    rtemp     = x[2*ia]   - x[2*m];

                    x[2*ia]   = x[2*ia]   + x[2*m];

                    itemp     = x[2*ia+1] - x[2*m+1];

                    x[2*ia+1] = x[2*ia+1] + x[2*m+1];

                    x[2*m]    = c*rtemp   + s*itemp;

                    x[2*m+1]  = c*itemp   - s*rtemp;

                    ia++;

                 }

                 ia += n2;

              }

              ie <<= 1;

              w = w + k;

           }



}



/* ======================================================================== */

/*  End of file: DSPF_dp_icfftr2.c                                               */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2004 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_dp_fir_cpl/1117057378  717   0     0       4563      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_cplx(                                                  */
/*                        const double * restrict x,                        */
/*                        const double * restrict h,                        */
/*                        double *       restrict r,                        */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*                                                                          */
/*            x[2*(nr+nh-1)]: Pointer to complex input array.               */
/*                            The input data pointer x must point to the    */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]       : Pointer to complex coefficient array          */
/*                            (in normal order).                            */
/*            r[2*nr]       : Pointer to complex output array.              */
/*            nh            : Number of complex coefficients in vector h.   */
/*            nr            : Number of complex output samples to           */
/*                           calculate.                                     */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/*    3. Register Sharing is used to make optimal use of available register */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_fir_cplx,    ".text:ansi");

#include "DSPF_dp_fir_cplx.h"


void DSPF_dp_fir_cplx(const    double *restrict x, const double *restrict h, double *restrict r, int nh, int nr)
{

int i,j;
double  real, imag;
for (i = 0; i < 2*nr; i += 2)
{
real = 0;
imag = 0;

for (j = 0; j < 2*nh; j += 2)
{
real += h[j] * x[i-j] - h[j+1] * x[i+1-j];
imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];
}
r[i] = real;
r[i+1] = imag;
}

}

/* ======================================================================== */
/*  End of file: DSPF_dp_fir_cplx.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_fir_gen/1117057379  737   0     0       3958      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   */
/*                                                                          */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                              double * restrict r,int nh, int nr);        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       r : Pointer to output array                                        */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_fir_gen,    ".text:ansi");

#include "DSPF_dp_fir_gen.h"

void DSPF_dp_fir_gen(const    double * restrict x, const double * restrict h, double * restrict r, int nh, int nr)
{

int i, j;
double sum;


 for(i=0; i < nr; i++)
  {
    sum = 0;/*Clear the accumulator*/
    for(j=0; j < nh; j++)
    {
     sum += x[i+j] * h[j];
    }
   r[i] = sum; /*Storing the Sum*/
  }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_fir_gen.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_fir_r2./1117057380  756   0     0       3864      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_r2(                                                    */
/*                     const double * restrict x,                           */
/*                     const double * restrict h,                           */
/*                     double      * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]     : Pointer to coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]     : Pointer to output array of size nr.               */
/*            nh        : Number of coefficients                            */
/*            nr        : Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_fir_r2,    ".text:ansi");

#include "DSPF_dp_fir_r2.h"

void DSPF_dp_fir_r2(const    double *restrict x, const double *restrict h, double *restrict r, int nh, int nr)
{

int i, j;
double sum;

 for(i=0; i < nr; i++)
 {
  sum = 0;   /*Clear the Accumulator*/
  for(j=0; j < nh; j++)
   {
    sum += x[i+j] * h[j];
   }
  r[i] = sum; /*Store the result*/
 }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_fir_r2.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_fircirc/1117057381  774   0     0       4197      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          */
/*                     int csize, int nh, int nr)                           */
/*                                                                          */
/*            x[]     :     Input array (circular buffer of 2^(csize+1)     */
/*                          bytes)                                          */
/*                          Must be aligned at 2^(csize+1) byte boundary    */
/*            h[nh]   :     Filter coefficients array                       */
/*                          Must be double-word aligned                     */
/*            r[nr]   :     Output array                                    */
/*            index   :     Offset by which to start reading from the       */
/*                          input array. Must be multiple of 2              */
/*            csize   :     Size of circular buffer x[] is 2^(csize+1)      */
/*                          bytes. Must be 2 <= csize <= 31.                */
/*            nh      :     Number of filter coefficients                   */
/*                          Must be multiple of 2 and >= 4                  */
/*            nr      :     Size of output array                            */
/*                          Must be multiple of 4                           */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This routine implements a circularly addressed FIR filter.            */
/*    'nh' is the number of filter coefficients. 'nr' is the number         */
/*    of the output samples.                                                */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_fircirc,    ".text:ansi");

#include "DSPF_dp_fircirc.h"


void DSPF_dp_fircirc(double    * x, double * h, double * r, int index, int csize, int nh, int nr)
{

int i, j,k ;
                    //Circular Buffer block size = ((2^(csize + 1)) /8)
                    //floating point numbers

int mod;
double r0;


mod = (1 << (csize - 2));

for (i = 0; i < nr; i++)
{

  r0 = 0;
  for (j = 0; j < nh; j++)
   {

     k=(i + j + index) & (mod - 1); //Operation % mod is equivalent to & (mod -1)
     r0 += x[k] * h[j];             //r0 += x[(i + j + index) % mod] * h[j];
    }

  r[i] = r0;
 }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_fircirc.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_biquad./1117057382  793   0     0       3749      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        */
/*                   double *r, int nx)                                     */
/*                                                                          */
/*           x       :  Pointer to input samples                            */
/*           b       :  Pointer to Nr coefs b0, b1, b2                      */
/*           a       :  Pointer to Dr coefs a1, a2                          */
/*           delay   :  Pointer to filter delays                            */
/*           r       :  Pointer to output samples                           */
/*           nx      :  Number of input/output samples                      */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine implements a DF 2 transposed structure of the biquad   */
/*      filter. The transfer function of a biquad can be written            */
/*      as:                                                                 */
/*                                                                          */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)         */
/*                       H(Z) =     _________________________________       */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_biquad,    ".text:ansi");

#include "DSPF_dp_biquad.h"


void DSPF_dp_biquad(double    * x, double * b, double * a, double * delay, double * r, int nx)
{

int i;
double a1, a2, b0, b1, b2, d0, d1, x_i;

 a1 = a[0];
 a2 = a[1];
 b0 = b[0];
 b1 = b[1];
 b2 = b[2];
 d0 = delay[0];
 d1 = delay[1];

 for (i = 0; i < nx; i++)
 {
    x_i = x[i];
    r[i] = b0 * x_i + d0;
    d0 = b1 * x_i - a1 * r[i] + d1;
    d1 = b2 * x_i - a2 * r[i];
  }

 delay[0] = d0;
 delay[1] = d1;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_biquad.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_iir.c/  1117057383  0     0     0       4022      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_dp_iir    (double* restrict r1,                                */
/*                      const double*    x,                                 */
/*                      double* restrict r2,                                */
/*                      const double*    h2,                                */
/*                      const double*    h1,                                */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1[nr+4]   :  Delay element values (i/p and o/p)               */
/*           x[nr]      :  Pointer to the input array                       */
/*           r2[nr+4]   :  Pointer to the output array                      */
/*           h2[5]      :  Auto-regressive filter coefficients              */
/*           h1[5]      :  Moving average filter coefficients               */
/*           nr         :  Number of output samples                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder. The               */
/*    4 values in the r1 vector store the initial values of the             */
/*    delays.                                                               */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_iir,    ".text:ansi");

#include "DSPF_dp_iir.h"


void DSPF_dp_iir(double    *restrict r1, const double * x, double *restrict r2, const double * h2, const double * h1, int nr)
{

int i, j;
double sum;
for (i = 0; i < nr; i++)
{
sum = h2[0] * x[4+i];
for (j = 1; j <= 4; j++)
sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];
r1[4+i] = sum;
r2[i] = r1[4+i];
}
}

/* ======================================================================== */
/*  End of file: DSPF_dp_iir.c                                                   */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_iirlat./1117057384  811   0     0       4568      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           */
/*                                                                          */
/*   USAGE                                                                  */
/*                                                                          */
/*        This routine has following C prototype:                           */
/*                                                                          */
/*            void DSPF_dp_iirlat(                                               */
/*                          double *x,                                      */
/*                          int nx,                                         */
/*                          const double * restrict k,                      */
/*                          int nk,                                         */
/*                          double * restrict b,                            */
/*                          double * r                                      */
/*                          )                                               */
/*         x[nx]   : Input vector                                           */
/*         nx      : Length of input vector.                                */
/*         k[nk]   : Reflection coefficients                                */
/*         nk      : Number of reflection coefficients/lattice stages       */
/*                   Must be multiple of 2 and >=6.                         */
/*         b[nk+1] : Delay line elements from previous call. Should be      */
/*                   initialized to all zeros prior to the first call.      */
/*         r[nx]   : Output vector                                          */
/*                                                                          */
/*     DESCRIPTION                                                          */
/*                                                                          */
/*         This routine implements a real all-pole IIR filter in lattice    */
/*     structure (AR lattice). The filter consists of nk lattice stages.    */
/*     Each  stage  requires one  reflection coefficient  k and one delay   */
/*     element b. The routine takes an input vector x[] and returns the     */
/*     filter output in r[]. Prior to the first call of the outine the      */
/*     delay elements in b[]  should be set to zero. The input data may     */
/*     have to be pre-scaled to avoid overflow or achieve better SNR. The   */
/*     reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     */
/*     order of the coefficients is such that k[nk-1] corresponds to the    */
/*     first lattice stage after the input and k[0] Corresponds to the      */
/*     last stage.                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_iirlat,    ".text:ansi");

#include "DSPF_dp_iirlat.h"


void DSPF_dp_iirlat(double    * x, int nx, const double * restrict k, int nk, double * restrict b, double * r)
{

double rt; // output //
int i, j;

    for (j = 0; j < nx; j++)
    {

     rt = x[j];
     for (i = nk - 1; i >= 0; i--)
      {
        rt = rt - b[i] * k[i];
        b[i + 1] = b[i] + rt * k[i];
       }

    b[0] = rt;
    r[j] = rt;
    }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_iirlat.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_convol./1117057385  829   0     0       8824      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_convol -- Double Precision convolution                           */
/*                                                                          */
/* USAGE                                                                    */
/*    This routine has the following C prototype:                           */
/*                                                                          */
/*    void DSPF_dp_convol                                                        */
/*         (                                                                */
/*               double *x, //x: Pointer to input samples//                 */
/*               double *h, //h: Pointer to impulse response samples//      */
/*               double *r, //r: Pointer to output samples//                */
/*               int   nh, //nh: Number of impulse response samples//       */
/*               int   nr  //nr: Number of output samples//                 */
/*         )                                                                */
/*                                                                          */
/*          x = pointer to real input vector of size = nr+nh-1              */
/*          a typically contains input data (x) padded with                 */
/*          consecutive nh - 1  zeros at the beginning and end.             */
/*          h = pointer to real input vector of size nh in forward order.   */
/*          h typically contains the filter coefs.                          */
/*          r = Pointer to real output vector of size nr                    */
/*          nh= Number of elements in vector b. NOTE: nh <= nr  nh is       */
/*          typically noted as m in convol formulas. nh must be a           */
/*          MULTIPLE of 2                                                   */
/*          nr= Number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*          This function calculates the full-length convolution of real    */
/*          vectors x and h using time-domain techniques. The result is     */
/*          placed in real vector r.                                        */
/*                                                                          */
/*          It is assumed that input vector x is padded with nh-1 no of     */
/*          zeros in the beginning and end.                                 */
/*                                                                          */
/*          It is assumed that the length of the input vector h, nh, is a   */
/*          multiple of 2 and the length of the output vector r, nr, is a   */
/*          multiple of 4. nh is greater than or equal to 4 and nr is       */
/*          greater than or equal to nh. The routine computes 4 output      */
/*          samples at a time.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*          1. The inner loop is unrolled twice and the outer loop is       */
/*             unrolled four times.                                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*          1. nh is a multiple of 2 and greater than or equal to 4         */
/*          2. nr is a multiple of 4                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*          This is the C equivalent of the assembly code.  Note that       */
/*          the assembly code is hand optimized and restrictions may        */
/*          apply.                                                          */
/*                                                                          */
/*                                                                          */
/*          void DSPF_dp_convol(double *x, double *h, double *r, short nh,       */
/*                         short nr)                                        */
/*          {                                                               */
/*            short   octr, ictr;                                           */
/*            double  acc ;                                                 */
/*                                                                          */
/*            for (octr = nr ; octr > 0 ; octr--)                           */
/*            {                                                             */
/*              acc = 0 ;                                                   */
/*                                                                          */
/*              for (ictr = nh ; ictr > 0 ; ictr--)                         */
/*              {                                                           */
/*             acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       */
/*              }                                                           */
/*              r[nr-octr] = acc;                                           */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*          1. Endian: This code is LITTLE ENDIAN.                          */
/*          2. Interruptibility: This code is interrupt tolerant but not    */
/*                       interruptible.                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*          2*(nh*nr) + 5/2*nr + 32                                         */
/*          For nh=24 and nr=48, cycles=2456                                */
/*          For nh=20 and nr=32, cycles=1392                                */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*          544 bytes                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_convol,    ".text:ansi");

#include "DSPF_dp_convol.h"


void DSPF_dp_convol(double    * x, double * h, double * r, int nh, int nr)
{

int optr, iptr;
 double acc ;

  for (optr = nr ; optr > 0 ; optr--)
   {
    acc = 0 ;
    for (iptr = nh ; iptr > 0 ; iptr--)
     {
      acc += x[nr-optr+nh-iptr]*h[(iptr-1)];
      }
    r[nr-optr] = acc;
   }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_convol.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_dotp_sq/1117057386  847   0     0       7210      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       */
/*                                                                          */
/*   USAGE                                                                  */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_dotp_sqr(                                                */
/*                       double G,                                          */
/*                       const double * x,                                  */
/*                       const double * y,                                  */
/*                       double *  restrict r,                              */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine computes the dot product of x[] and y[] arrays,       */
/*   adding it to the value in the location pointed to by r.                */
/*   Additionally, it computes the sum of the squares of the terms          */
/*   in the y array,adding it to the argument G. The final value of         */
/*   G is given as the return value of the function.                        */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*     1. Multiple Assignment was used to reduce loop carry path.           */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*     1. There are no special alignment requirements.                      */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    */
/*                        double *restrict r, int nx)                       */
/*      {                                                                   */
/*                                                                          */
/*         int i;                                                           */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         {                                                                */
/*               *r += x[i] * y[i];     // Compute Dot Product //           */
/*               G += y[i] * y[i];      // Compute Square  //               */
/*         }                                                                */
/*                                                                          */
/*         return G;                                                        */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*        1. Endian : This code is LITTLE ENDIAN .                          */
/*        2. Interruptibility: This code is interrupt-tolerant but not      */
/*                             interruptible.                               */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*      4*nx + 26                                                           */
/*                                                                          */
/*       For nx=64, cycles=282.                                             */
/*       For nx=30, cycles=146.                                             */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*      244 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_dotp_sqr,    ".text:ansi");

#include "DSPF_dp_dotp_sqr.h"

double DSPF_dp_dotp_sqr(double    G, const double * x, const double * y, double *restrict r, int nx)
{

int i;
 for (i = 0; i < nx; i++)
 {
    *r += x[i] * y[i];
    G += y[i] * y[i];
  }

 return G;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_dotp_sqr.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_dotprod/1117057386  867   0     0       2844      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx);  */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double precision       */
/*  float vectors.                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_dotprod,    ".text:ansi");

#include "DSPF_dp_dotprod.h"


double DSPF_dp_dotprod(const    double * x, const double * y, const int nx)
{
int i;
double sum = 0;
for (i=0; i < nx; i++)
{
sum += x[i] * y[i];
}
return sum;

}

/* ======================================================================== */
/*  End of file: DSPF_dp_dotprod.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_dotp_cp/1117057387  886   0     0       3606      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         */
/*      product                                                             */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * */
/*                        restrict re, double * restrict im);               */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real                    */
/*              part of the result.                                         */
/*      im    : Pointer to the location storing the imaginary part of       */
/*              the result                                                  */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double   precision     */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_dotp_cplx,    ".text:ansi");

#include "DSPF_dp_dotp_cplx.h"


void DSPF_dp_dotp_cplx(const    double * x, const double * y, int n, double * restrict re, double * restrict im)
{

double real=0, imag=0;
int i=0;
for(i=0; i<n; i++)
{
real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);
imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);
}
*re=real;
*im=imag;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_dotp_cplx.c                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_maxval./1117057388  907   0     0       3211      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_maxval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the maximum number in the                   */
/*   input array.This code returns the maximum value                        */
/*   in the array.                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_maxval,    ".text:ansi");

#include "DSPF_dp_maxval.h"


double DSPF_dp_maxval(const    double* x, int nx)
{

int i;
double max;

*((int *)&max) = 0x00000000;
*((int *)&max+1) = 0xfff00000;

for (i = 0; i < nx; i++)
if (x[i] > max)
{
max = x[i];
}

return max;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_maxval.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_maxidx./1117057389  925   0     0       3062      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_dp_maxidx(                                                     */
/*                      const double* x,                                    */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the index of maximum number in the input    */
/*       array. This function returns the index of the greatest value.      */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_maxidx,    ".text:ansi");

#include "DSPF_dp_maxidx.h"


int DSPF_dp_maxidx(const    double* x, int nx)
{

int i,index;
double max;

*((int *)&max) = 0x00000000;
*((int *)&max+1) = 0xfff00000;
for (i = 0; i < nx; i++)
if (x[i] > max)
{
max = x[i];
index=i;
}
return index;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_maxidx.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_minval./1117057390  943   0     0       2967      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_minval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out and returns the minimum number              */
/*   in the input array.                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_minval,    ".text:ansi");

#include "DSPF_dp_minval.h"


double DSPF_dp_minval(const    double* x, int nx)
{

int i;
double min;
*((int *)&min) = 0x00000000;
*((int *)&min+1) = 0x7ff00000;
for (i = 0; i < nx; i++)
if (x[i] < min)
{
min = x[i];

}
return min;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_minval.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_vecreci/1117057391  961   0     0       3979      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void  DSPF_dp_vecrecip(const double *x,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_dp_vecrecip module calculates the reciprocal of each element    */
/*  in the array x and returns the output in array r. It uses 3             */
/*  iterations of the Newton-Raphson method to improve the accuracy         */
/*  of the output generated by the RCPDP instruction of the C67x.           */
/*  Each iteration doubles the accuracy. The initial output generated       */
/*  by RCPDP is 8 bits.So after the first iteration it is 16 bits and       */
/*  after the second it is the  23 bits and after third it is full 52 bits. */
/*  The formula used is:                                                    */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPDP.          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_vecrecip,    ".text:ansi");

#include "DSPF_dp_vecrecip.h"


void DSPF_dp_vecrecip(const    double * x, double * restrict r, int n)
{

  int i;

    for(i = 0; i < n; i++)
//         this reciprocal eval makes a call to the RTS func
//             so no software pipelining is possible
        r[i] = 1 / x[i];
}

/* ======================================================================== */
/*  End of file: DSPF_dp_vecrecip.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_vecsum_/1117057392  981   0     0       2821      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      double DSPF_dp_vecsum_sq(const double *x,                                */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*       array x and returns the sum.                                       */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_vecsum_sq,    ".text:ansi");

#include "DSPF_dp_vecsum_sq.h"


double DSPF_dp_vecsum_sq(const    double * x, int n)
{

int i;
double sum=0;

for(i = 0; i < n; i++ )
 sum += x[i]*x[i];

return sum;
}

/* ======================================================================== */
/*  End of file: DSPF_dp_vecsum_sq.c                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_w_vec.c/1117057393  0     0     0       3313      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_dp_w_vec(const double* x,                                    */
/*                      const double* y,                                    */
/*                      double m,                                           */
/*                      double * restrict r,                                */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are Double precision floating             */
/*     point numbers.                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_w_vec,    ".text:ansi");

#include "DSPF_dp_w_vec.h"


void DSPF_dp_w_vec(const    double * x, const double * y, double m, double * restrict r, int nr)
{

int i;
for (i = 0; i < nr; i++)
r[i] = (m * x[i]) + y[i];
}

/* ======================================================================== */
/*  End of file: DSPF_dp_w_vec.c                                                 */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_vecmul./1117057394  1002  0     0       3219      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_vecmul -- Double Precision vector multiplication                 */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_dp_vecmul   (const double *x,                                  */
/*                        const double *y,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                        )                                                 */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element Double Precision       */
/*       floating point  multiplication of the vectors x[] and y[] and      */
/*       returns the values in r[].                                         */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_vecmul,    ".text:ansi");

#include "DSPF_dp_vecmul.h"


void DSPF_dp_vecmul(const    double * x, const double * y, double * restrict r, int n)
{

int i;

for(i = 0; i < n; i++)
r[i] = x[i] * y[i];
}

/* ======================================================================== */
/*  End of file: DSPF_dp_vecmul.c                                                */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057395  1020  0     0       3742      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine has following C prototype:                              */
/*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                           */
/*                     double *y, int c2, double *r)                        */
/*                                                                          */
/*     x      : Pointer to r1 by c1 input matrix.                           */
/*     r1     : Number of rows in x.                                        */
/*     c1     : Number of columns in x.  Also number of rows in y.          */
/*     y      : Pointer to c1 by c2 input matrix.                           */
/*     c2     : Number of columns in y.                                     */
/*     r      : Pointer to r1 by c2 output matrix.                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be Double           */
/*     precision floating point values.                                     */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_mat_mul,    ".text:ansi");

#include "DSPF_dp_mat_mul.h"


void DSPF_dp_mat_mul(double    * x, int r1, int c1, double * y, int c2, double * r)
{
int i, j, k;
 double temp;
 for(i=0;i<r1;i++)
 {
  for(j=0;j<c2;j++)
    {
    temp=0;
    for(k=0;k<c1;k++)
    temp+=x[i*c1+k]*y[k*c2+j];
    r[i*c2+j]=temp;
    }
 }
}

/* ======================================================================== */
/*  End of file: DSPF_dp_mat_mul.c                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_mat_tra/1117057396  1039  0     0       6232      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x,                        */
/*                         int rows,                                        */
/*                         int cols,                                        */
/*                         double *restrict r                               */
/*                         )                                                */
/*                                                                          */
/*          x       :  Input matrix containing rows*cols Double Precision   */
/*                     floating point numbers.                              */
/*          rows    :  No. of rows in matrix x.                             */
/*                     Also no. of columns in matrix r                      */
/*          cols    :  No. of columns in matrix x.                          */
/*                     Also no. of rows in matrix r.                        */
/*          r       :  Output matrix containing cols*rows Double Precision  */
/*                     floating point numbers.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The number of rows and columns is > 0.                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*       This is the C equivalent of the assembly code.  Note that          */
/*       the assembly code is hand optimized and restrictions may apply.    */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x, int rows,              */
/*       int cols, double *restrict r)                                      */
/*       {                                                                  */
/*          int i,j;                                                        */
/*                                                                          */
/*          for(i=0; i<cols; i++)                                           */
/*             for(j=0; j<rows; j++)                                        */
/*                r[i * rows + j] = x[i + cols * j];                        */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2 * rows * cols + 15                                                */
/*      For rows=10 and cols=20, cycles=415                                 */
/*      For rows=15 and cols=20, cycles=615                                 */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      256  bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_mat_trans,    ".text:ansi");

#include "DSPF_dp_mat_trans.h"


void DSPF_dp_mat_trans(const    double *restrict x, int rows, int cols, double *restrict r)
{

int i,j;
for(i=0; i<cols; i++)
for(j=0; j<rows; j++)
r[i * rows + j] = x[i + cols * j];
}

/* ======================================================================== */
/*  End of file: DSPF_dp_mat_trans.c                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_mat_mul/1117057397  1060  0     0       5260      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_mul_cplx(                                              */
/*                              const double* x,                            */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const double* y,                            */
/*                              int c2,                                     */
/*                              double* restrict r                          */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   No. of rows in matrix x.                        */
/*            c1        :   No. of columns in matrix x.                     */
/*                          Also no. of rows in matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          real values stored in even positions and        */
/*                          imaginary values in odd positions.              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of the matrix is assumed to be complex numbers with  */
/*        Real values are stored in even positions and imaginary            */
/*        values in odd positions.                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_mat_mul_cplx,    ".text:ansi");

#include "DSPF_dp_mat_mul_cplx.h"


void DSPF_dp_mat_mul_cplx(const    double* x, int r1, int c1, const double* y, int c2, double* restrict r)
{

double real, imag;
int i, j, k;
for(i = 0; i < r1; i++)
{
for(j = 0; j < c2; j++)
{
real=0;
imag=0;
for(k = 0; k < c1; k++)
{

real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j] -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);
imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1] + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);

}

r[i*2*c2 + 2*j] = real;
r[i*2*c2 + 2*j + 1] = imag;
}

}

}

/* ======================================================================== */
/*  End of file: DSPF_dp_mat_mul_cplx.c                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_blk_mov/1117057398  1084  0     0       5778      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_blk_move(                                                  */
/*                        const double *   x,                               */
/*                        double *restrict r,                               */
/*                        int nx                                            */
/*                       )                                                  */
/*                                                                          */
/*            x[nx]: Pointer to source data to be moved.                    */
/*            r[nx]: Pointer to destination array.                          */
/*            nx:    Number of floats to move.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*   This routine moves nx doubles from one memory location                 */
/*       pointed to by x to another pointed to by r.                        */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*       1. nx is greater than 0.                                           */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*       void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     */
/*       {                                                                  */
/*           int i;                                                         */
/*           for (i = 0 ; i < nx; i++)                                      */
/*               r[i] = x[i];                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This implementation is Little-Endian.                    */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2*nx+ 8                                                             */
/*      For nx=64, cycles=136.                                              */
/*      For nx=25, cycles=58.                                               */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      96 bytes                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#pragma CODE_SECTION(DSPF_dp_blk_move,    ".text:ansi");

#include "DSPF_dp_blk_move.h"


void DSPF_dp_blk_move(const    double * x, double *restrict  r, const int nx)
{

int i;
for (i = 0 ; i < nx; i++)
r[i] = x[i];
}

/* ======================================================================== */
/*  End of file: DSPF_dp_blk_move.c                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_lms.h/  1117057336  0     0     0       11198     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_lms -- Single Precision floating point LMS algorithm             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      );                                                                  */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       */
/*      input signal and a desired input signal, the filter produces an     */
/*      output signal, the final coefficient values, and returns the final  */
/*      output error signal.                                                */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled six times to allow update of          */
/*         six coefficients in the kernel.                                  */
/*      2. The outer loop has been unrolled twice to enable use of LDDW     */
/*         for loading the input coefficients.                              */
/*      3. LDDW instruction is used to load in the coefficients.            */
/*      4. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*      5. The outer loop instructions are scheduled in parallel with       */
/*         epilog and prolog wherever possible.                             */
/*      6. The 'error' term needs to be computed in the outer loop          */
/*         before a new iteration of the inner loop can start. As a         */
/*         result the prolog cannot be placed in parallel with epilog       */
/*         (after the loop kernel).                                         */
/*      7. Pushing and popping variables from the stack does not            */
/*         really add any overhead except increase stack size. This         */
/*         is because the pops and pushes are done in the delay slots       */
/*         of the outer loop instructions.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The inner loop counter must be a multiple of 6 and >=6.          */
/*      2. Little endianness is assumed.                                    */
/*      3. Extraneous loads are allowed in the program.                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions      */
/*      may apply.                                                          */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,j;                                                        */
/*                                                                          */
/*          float sum, temp, ae;                                            */
/*          temp = 0.0f;                                                    */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0.0f;                                                 */
/*              ae = adaptrate * error;                                     */
/*                                                                          */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  h[j] = h[j] + (ae * temp);                              */
/*                  sum += h[j] * x[i+j];                                   */
/*                  temp = x[i + j];                                        */
/*              }                                                           */
/*                                                                          */
/*              r[i] = sum;                                                 */
/*              error = desired[i] - sum;                                   */
/*              temp = x[i];                                                */
/*          }                                                               */
/*          // return the final error //                                    */
/*          return error;                                                   */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*      (nh + 35) nr + 21                                                   */
/*      eg. for nh = 36 and nr = 64                                         */
/*      cycles = 4565                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1376 bytes                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_LMS_H_
#define DSPF_SP_LMS_H_ 1

float DSPF_sp_lms
(
    float *x,
    float *h,
    float *desired,
    float *r,
    float adaptrate,
    float error,
    int nh,
    int nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_lms.h67/1117057336  0     0     0       11188     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       *
*       input signal and a desired input signal, the filter produces an     *
*       output signal, the final coefficient values, and returns the final  *
*       output error signal.                                                *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled six times to allow update of          *
*          six coefficients in the kernel.                                  *
*       2. The outer loop has been unrolled twice to enable use of LDDW     *
*          for loading the input coefficients.                              *
*       3. LDDW instruction is used to load in the coefficients.            *
*       4. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*       5. The outer loop instructions are scheduled in parallel with       *
*          epilog and prolog wherever possible.                             *
*       6. The 'error' term needs to be computed in the outer loop          *
*          before a new iteration of the inner loop can start. As a         *
*          result the prolog cannot be placed in parallel with epilog       *
*          (after the loop kernel).                                         *
*       7. Pushing and popping variables from the stack does not            *
*          really add any overhead except increase stack size. This         *
*          is because the pops and pushes are done in the delay slots       *
*          of the outer loop instructions.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The inner loop counter must be a multiple of 6 and >=6.          *
*       2. Little endianness is assumed.                                    *
*       3. Extraneous loads are allowed in the program.                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions      *
*       may apply.                                                          *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i,j;                                                        *
*                                                                           *
*           float sum, temp, ae;                                            *
*           temp = 0.0f;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0.0f;                                                 *
*               ae = adaptrate * error;                                     *
*                                                                           *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   h[j] = h[j] + (ae * temp);                              *
*                   sum += h[j] * x[i+j];                                   *
*                   temp = x[i + j];                                        *
*               }                                                           *
*                                                                           *
*               r[i] = sum;                                                 *
*               error = desired[i] - sum;                                   *
*               temp = x[i];                                                *
*           }                                                               *
*           /* return the final error */                                    *
*           return error;                                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       (nh + 35) nr + 21                                                   *
*       eg. for nh = 36 and nr = 64                                         *
*       cycles = 4565                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1376 bytes                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_lms

*  ======================================================================== *
*   End of file:  DSPF_sp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_autocor/1117057337  1104  0     0       4797      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_autocor -- Single Precision autocorrelation                      */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_autocor                                                    */

/*                     (                                                    */

/*                         float       *  restrict r,                       */

/*                         const short *  restrict x,                       */

/*                         int            nx,                               */

/*                         int            nr                                */

/*                     )                                                    */

/*            r  = pointer to output array of autocorrelation of length nr  */

/*            x  = pointer to input array of length nx+nr. Input data must  */

/*                 be padded with nr consecutive zeros at the beginning.    */

/*            nx = Length of Autocorrelation vector.                        */

/*            nr = Length of lags.                                          */

/*                                                                          */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This routine performs the autocorrelation of the input array inp.  */

/*       It is assumed that the length of the input array, x, is a multiple */

/*       of 2 and the length of the output array, r, is a multiple of 4.    */

/*       The assembly routine computes 4 output samples at a time.          */

/*                                                                          */

/*       It is assumed that input vector x is padded with nr no of zeros in */

/*       the beginning.                                                     */

/*                                                                          */

/*       x is to be aligned on a double word boundary.                      */

/*                                                                          */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*       The inner loop is unrolled twice and the outer loop is unrolled    */

/*       four times.                                                        */

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*       1. nx is a multiple of 2 and greater than or equal to 4.           */

/*       2. nr is a multiple of 4 and greater than or equal to 4.           */

/*       3. nx is greater than or equal to nr                               */

/*       4. x  is double word aligned.                                      */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_AUTOCOR_ASM_H_

#define DSPF_SP_AUTOCOR_ASM_H_ 1



void DSPF_sp_autocor(float     *restrict r, float *restrict x, int nx, int nr);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_autocor_h.asm                                           */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_autocor/1117057337  1123  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_autocor -- Single Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_autocor

* ======================================================================== *
*  End of file: DSPF_sp_autocor_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_bitrev_/1117057338  1144  0     0       7052      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         */

/*      numbers                                                             */

/*                                                                          */

/*                                                                          */

/*  USAGE                                                                   */

/*                                                                          */

/*     This routine is C Callable and can be called as:                     */

/*                                                                          */

/*     void bitrev_cplx(double *x, short *index, int nx);                   */

/*                                                                          */

/*     x[nx]  : Complex input array to be bit-reversed.                     */

/*              Contains 2*nx floats                                        */

/*     index[]: Array of size ~sqrt(nx) created by the routine              */

/*              bitrev_index to allow the fast implementation of the        */

/*              bit-reversal.                                               */

/*     nx     : Number of elements in array x[]. Must be power of 2.        */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*                                                                          */

/*     This routine performs the bit-reversal of the input array x[],       */

/*     where x[] is an integer array of length nx containing 16-bit         */

/*     complex pairs of data.  This routine requires the index array        */

/*     provided by the program below.  This index should be generated at    */

/*     compile time not by the DSP.                                         */

/*                                                                          */

/*     TI retains all rights, title and interest in this code and only      */

/*     authorizes the use of the bit-reversal code and related table        */

/*     generation code with TMS320-family DSPs manufactured by TI.          */

/*                                                                          */

/*     // ----------------------------------------------------------- //    */

/*     //  This routine calculates the index for bit reversal of      //    */

/*     //  an array of length nx.  The length of the index table is   //    */

/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */

/*     //                                                             //    */

/*     //  In other words, the length of the index table is:          //    */

/*     //      - for even power of radix: sqrt(nx)                    //    */

/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */

/*     // ----------------------------------------------------------- //    */

/*     void bitrev_index(short *index, int nx)                              */

/*     {                                                                    */

/*         int   i, j, k, radix = 2;                                        */

/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */

/*                                                                          */

/*         nbits = 0;                                                       */

/*         i = nx;                                                          */

/*         while (i > 1)                                                    */

/*         {                                                                */

/*             i = i >> 1;                                                  */

/*             nbits++;                                                     */

/*         }                                                                */

/*                                                                          */

/*         raddiv2 = radix >> 1;                                            */

/*         nbot    = nbits >> raddiv2;                                      */

/*         nbot    = nbot << raddiv2 - 1;                                   */

/*         ndiff   = nbits & raddiv2;                                       */

/*         ntop    = nbot + ndiff;                                          */

/*         n2      = 1 << ntop;                                             */

/*                                                                          */

/*         index[0] = 0;                                                    */

/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */

/*         {                                                                */

/*             index[i] = j - 1;                                            */

/*                                                                          */

/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */

/*                 j -= k*(radix-1);                                        */

/*                                                                          */

/*             j += k;                                                      */

/*         }                                                                */

/*         index[n2 - 1] = n2 - 1;                                          */

/*     }                                                                    */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_BITREV_CPLX_ASM_H_

#define DSPF_SP_BITREV_CPLX_ASM_H_ 1



void DSPF_sp_bitrev_cplx(double     * x, short * index, int n);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_bitrev_/1117057337  1167  0     0       1766      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_bitrev_cplx

* ======================================================================== *
*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr4_/1117057339  1192  0     0       7440      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      */
/*                                                                          */
/*  USAGE                                                                 */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                        */
/*  void cfftr4_dif(float* x, float* w, short n)                          */
/*                                                                          */
/*  x is pointer to an array holding the input and output floating        */
/*     point array which contains 'n' complex points                      */
/*  w is pointer to an array holding the coefficient floating point       */
/*     array which contains 3*n/4 complex numbers                         */
/*  n is the number of complex points in x                                */
/*                                                                          */
/*  If the routine is not to be used as a C callable function,            */
/*  then you need to initialize values for all of the parameters          */
/*  passed to the function since these are assumed to be in               */
/*  registers as defined by the calling convention of the                 */
/*  compiler, (refer to the TMS320C6x Optimizing C Compiler               */
/*  User's Guide).                                                        */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                            */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)             */
/*  complex radix 4 FFT with digit-reversed output and normal             */
/*  order input.  The number of points, 'n', must be a power              */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                 */
/*  in-place routine in the sense that the output is written              */
/*  over the input.  It is not an in-place routine in the                 */
/*  sense that the input is in normal order and the output is             */
/*  in digit-reversed order.                                              */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex        */
/*  coefficients (3*n/2 values).                                          */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the             */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers           */
/*  are in normal order.  Each real and imaginary output value            */
/*  is interleaved in the 'x' array and the complex numbers are           */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and               */
/*  imaginary values of the coefficients are interleaved in the           */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers         */
/*  are in normal order.                                                  */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                      */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than         */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                     */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written             */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).              */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                */
/*  performing the complex conjugate on the input complex numbers         */
/*  (negating the imaginary value), and dividing the result by n.         */
/*  Another method to use the FFT to perform an inverse FFT, is to        */
/*  swap the real and imaginary values of the input and the result,       */
/*  and divide the result by n.  In either case, the input is still       */
/*  in normal order and the output is still in digit-reversed order.      */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse            */
/*  FFT by using the complex conjugate of the coefficients as             */
/*  you can do with the complex radix 2 FFT.                              */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),      */
/*  the digit-reversed locations can be calculated by reversing the       */
/*  order of the bit pairs of the labels.  For example, for a 1024        */
/*  point FFT, the digit reversed location for                            */
/*  617d = 1001101001b = 10 01 10 10 01  is                               */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                  */
/*                                                                          */
/*  TI plans to provide an inverse complex radix 4 FFT with digit-        */
/*  reversed input and normal order output.  With these 2 routines,       */
/*  the digit-reversed output of the FFT can be the input to the          */
/*  inverse FFT without performing digit-reversing on the data.           */
/*                                                                          */
/*  TI also plans to provide a complex digit reverse routine.             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR4_DIF_ASM_H_
#define DSPF_SP_CFFTR4_DIF_ASM_H_ 1

void DSPF_sp_cfftr4_dif(float     * x, float * w, short n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_cfftr4_/1117057339  1214  0     0       1692      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr4_dif

* ======================================================================== *
*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr2_/1117057340  1238  0     0       7763      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   */
/*      complex input                                                       */
/*                                                                          */
/*  USAGE                                                                   */
/*          This routine is C-callable and can be called as:                */
/*                                                                          */
/*          void DSPF_sp_cfftr2_dit(float * x, float * w, short n);              */
/*                                                                          */
/*          x : Pointer to complex data input                               */
/*          w : pointer to complex twiddle factor in Bit reverse order      */
/*          N : length of FFT in complex samples, power of 2 such that N>=3 */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the Decimation-in-Time (DIT) Radix-2 FFT      */
/*      of the input array x.                                               */
/*      x has N complex floating point numbers arranged as successive       */
/*      real and imaginary number pairs. Input array x contains N           */
/*      complex points (N*2 elements). The coefficients for the             */
/*      FFT are passed to the function in array w which contains            */
/*      N/2 complex numbers (N elements) as successive real and             */
/*      imaginary number pairs.                                             */
/*      The FFT Coefficients w are in N/2 bit-reversed order                */
/*      The elements of input array x are in normal order                   */
/*      The assembly routine performs 4 output samples (2 real and 2        */
/*      imaginary) for a pass through inner loop.                           */
/*                                                                          */
/*      Note that (bit-reversed) coefficients for higher order FFT (1024    */
/*      point) can be used unchanged as coefficients for a lower order      */
/*      FFT (512, 256, 128 ... ,2)                                          */
/*                                                                          */
/*      The routine can be used to implement Inverse-FFT by any ONE of      */
/*      the following methods:                                              */
/*                                                                          */
/*      1.Inputs (x) are replaced by their Complex-conjugate values         */
/*        Output values are divided by N                                    */
/*      2.FFT Coefficients (w) are replaced by their Complex-conjugates     */
/*        Output values are divided by N                                    */
/*      3.Swap Real and Imaginary values of input                           */
/*      4.Swap Real and Imaginary values of output                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_cfftr2_dit(float* x, float* w, short n)                     */
/*      {                                                                   */
/*         short n2, ie, ia, i, j, k, m;                                    */
/*         float rtemp, itemp, c, s;                                        */
/*                                                                          */
/*         n2 = n;                                                          */
/*         ie = 1;                                                          */
/*                                                                          */
/*         for(k=n; k > 1; k >>= 1)                                         */
/*         {                                                                */
/*            n2 >>= 1;                                                     */
/*            ia = 0;                                                       */
/*            for(j=0; j < ie; j++)                                         */
/*            {                                                             */
/*               c = w[2*j];                                                */
/*               s = w[2*j+1];                                              */
/*               for(i=0; i < n2; i++)                                      */
/*               {                                                          */
/*                  m = ia + n2;                                            */
/*                  rtemp     = c * x[2*m]   + s * x[2*m+1];                */
/*                  itemp     = c * x[2*m+1] - s * x[2*m];                  */
/*                  x[2*m]    = x[2*ia]   - rtemp;                          */
/*                  x[2*m+1]  = x[2*ia+1] - itemp;                          */
/*                  x[2*ia]   = x[2*ia]   + rtemp;                          */
/*                  x[2*ia+1] = x[2*ia+1] + itemp;                          */
/*                  ia++;                                                   */
/*               }                                                          */
/*               ia += n2;                                                  */
/*            }                                                             */
/*            ie <<= 1;                                                     */
/*         }                                                                */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR2_DIT_ASM_H_
#define DSPF_SP_CFFTR2_DIT_ASM_H_ 1

void DSPF_sp_cfftr2_dit(float     * x, float * w, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_cfftr2_/1117057339  1260  0     0       1765      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   *
*      complex input                                                       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr2_dit

* ======================================================================== *
*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fftSPxS/1117057341  1284  0     0       37257     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          */
/*     forwards FFT with complex input                                     */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of fft in complex samples, power of 2 such that    */
/*                   N >=8 and N<= 16385.                                   */
/*      ptr_x  :  Pointer to complex data input.                            */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data.                           */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest fft butterfly used in computation used for       */
/*                decomposing fft into subffts, see notes.                  */
/*      offset :  Index in complex samples of sub-fft from start of main    */
/*                fft.                                                      */
/*      n_max  :  size of main fft in complex samples.                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards fft using a special   */
/*      sequece of coefficients generated in the following way:             */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the fft  */
/*      producing the frequency domain data in the Y array.                 */
/*      As the fft allows every input point to effect every output point    */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main fft of size N to  */
/*      be divided into several steps, allowing as much data reuse as       */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire 1K data     */
/*      set it covers the 1st pass of the fft until the butterfly size is   */
/*      256. The following 4 ffts do 256 pt ffts 25% of the size. These     */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the fft the following would be needed :                   */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the fft is calculated by summing these      */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array. In the    */
/*      smae way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the FFT, four other calls are required to        */
/*      perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 FFTs in         */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the FFT with one function call invocation as shown    */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the fft. This collapses the inner 2 loops in the        */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised FFT uses a redundant sequence of twiddle factors to  */
/*         allow a linear access through the data. This linear access       */
/*         enables data and instruction level parallelism.                  */
/*                                                                          */
/*      3. The data produced by the fftSPxSP fft is in normal form, the     */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  */
/*         of the butterfly are corssed over, this has the effect of        */
/*         making the data come out in bit reversed rather than fftSPxSP    */
/*         digit reversed order. This simplifies the last pass of the       */
/*         loop. A simple table is used to do the bit reversal out of       */
/*         place.                                                           */
/*                                                                          */
/*             unsigned char brev[64] =                                     */
/*             {                                                            */
/*                   0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          */
/*                   0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          */
/*                   0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          */
/*                   0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          */
/*                   0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          */
/*                   0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          */
/*                   0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          */
/*                   0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           */
/*             };                                                           */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on double  */
/*         word boundares. Real values are stored in even word positions    */
/*         and imaginary values in odd positions.                           */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on entry  */
/*         to each loop and reanlbed on exit out of the loop.               */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      )                                                                   */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, fft_jmp;                                */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              fft_jmp = stride + (stride>>1);                             */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - fft_jmp);                                  */
/*                  if (!predj) x += fft_jmp;                               */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 + xl21;                                       */
/*                  yt2 = xl1 + xl20;                                       */
/*                  xt2 = xl0 - xl21;                                       */
/*                  yt1 = xl1 - xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += fft_jmp;                                       */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of fft //                 */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1472 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FFTSPXSP_H_
#define DSPF_SP_FFTSPXSP_H_ 1

void DSPF_sp_fftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fftSPxSP.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_fftSPxS/1117057341  1304  0     0       36898     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          *
*      forwards FFT with complex input                                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of fft in complex samples, power of 2 such that    *
*                    N >=8 and N<= 16385.                                   *
*       ptr_x  :  Pointer to complex data input.                            *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data.                           *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest fft butterfly used in computation used for       *
*                 decomposing fft into subffts, see notes.                  *
*       offset :  Index in complex samples of sub-fft from start of main    *
*                 fft.                                                      *
*       n_max  :  size of main fft in complex samples.                      *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards fft using a special   *
*       sequece of coefficients generated in the following way:             *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the fft  *
*       producing the frequency domain data in the Y array.                 *
*       As the fft allows every input point to effect every output point    *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main fft of size N to  *
*       be divided into several steps, allowing as much data reuse as       *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size is   *
*       256. The following 4 ffts do 256 pt ffts 25% of the size. These     *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the fft the following would be needed :                   *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array. In the    *
*       smae way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the FFT, four other calls are required to        *
*       perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 FFTs in         *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the FFT with one function call invocation as shown    *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the fft. This collapses the inner 2 loops in the        *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised FFT uses a redundant sequence of twiddle factors to  *
*          allow a linear access through the data. This linear access       *
*          enables data and instruction level parallelism.                  *
*                                                                           *
*       3. The data produced by the fftSPxSP fft is in normal form, the     *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  *
*          of the butterfly are corssed over, this has the effect of        *
*          making the data come out in bit reversed rather than fftSPxSP    *
*          digit reversed order. This simplifies the last pass of the       *
*          loop. A simple table is used to do the bit reversal out of       *
*          place.                                                           *
*                                                                           *
*              unsigned char brev[64] =                                     *
*              {                                                            *
*                    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          *
*                    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          *
*                    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          *
*                    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          *
*                    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          *
*                    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          *
*                    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          *
*                    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           *
*              };                                                           *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on double  *
*          word boundares. Real values are stored in even word positions    *
*          and imaginary values in odd positions.                           *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on entry  *
*          to each loop and reanlbed on exit out of the loop.               *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       )                                                                   *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, fft_jmp;                                *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 + xl21;                                       *
*                   yt2 = xl1 + xl20;                                       *
*                   xt2 = xl0 - xl21;                                       *
*                   yt1 = xl1 - xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of fft */                 *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1472 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_fftSPxSP.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_ifftSPx/1117057343  1326  0     0       37500     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         */
/*     inverse FFT with complex input                                      */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of ifft in complex samples, power of 2 such that   */
/*                N >=8 and N<= 16385.                                      */
/*      ptr_x  :  Pointer to complex data input (normal order).             */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data (normal order).            */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest ifft butterfly used in computation used for      */
/*                decomposing ifft into sub iffts, see notes.               */
/*      offset :  Index in complex samples of sub-ifft from start of main   */
/*                ifft.                                                     */
/*      n_max  :  size of main ifft in complex samples.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards ifft using a special  */
/*      sequence of coefficients generated in the following way:            */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the      */
/*      ifft producing the time domain data in the Y array. The output is   */
/*      scaled by a scaling factor of 1/N.                                  */
/*                                                                          */
/*      As the ifft allows every input point to effect every output point   */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main ifft of size N    */
/*      to be divided into several steps, allowing as much data reuse as    */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          */
/*                                                                          */
/*      Notice how the 1st ifft function is called on the entire 1K data    */
/*      set it covers the 1st pass of the ifft until the butterfly size is  */
/*      256. The following 4 iffts do 256 pt iffts 25% of the size. These   */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the ifft the following would be needed :                  */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the ifft is calculated by summing these     */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array. In the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the IFFT, four other calls are required to       */
/*      perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 IFFTs in        */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the IFFT with one function call invocation as shown   */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the ifft. This collapses the inner 2 loops in the       */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised IFFT uses a redundant sequence of twiddle            */
/*         factors to allow a linear access through the data. This linear   */
/*         access enables data and instruction level parallelism.           */
/*                                                                          */
/*      3.The data produced by the ifftSPxSP ifft is in normal form, the    */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        */
/*         points of the butterfly are corssed over, this has the effect    */
/*         of making the data come out in bit reversed rather than          */
/*         ifftSPxSP digit reversed order. This simplifies the last pass    */
/*         of the loop. A simple table is used to do the bit reversal out   */
/*         of place.                                                        */
/*                                                                          */
/*      unsigned char brev[64] =                                            */
/*      {                                                                   */
/*          0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   */
/*          0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   */
/*          0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   */
/*          0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   */
/*          0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   */
/*          0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   */
/*          0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   */
/*          0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    */
/*      };                                                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on         */
/*         double word boundares. Real values are stored in even word       */
/*         positions and imaginary values in odd positions.                 */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on        */
/*         entry to each loop and reanlbed on exit out of the loop.         */
/*                                                                          */
/*      5. x must be padded with 16 words at the end.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, ifft_jmp;                               */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              ifft_jmp = stride + (stride>>1);                            */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - ifft_jmp);                                 */
/*                  if (!predj) x += ifft_jmp;                              */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 - xl21;                                       */
/*                  yt2 = xl1 - xl20;                                       */
/*                  xt2 = xl0 + xl21;                                       */
/*                  yt1 = xl1 + xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += ifft_jmp;                                      */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of ifft //                */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1504 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IFFTSPXSP_H_
#define DSPF_SP_IFFTSPXSP_H_ 1

void DSPF_sp_ifftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_ifftSPxSP.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_ifftSPx/1117057342  1347  0     0       37136     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         *
*      inverse FFT with complex input                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of ifft in complex samples, power of 2 such that   *
*                 N >=8 and N<= 16385.                                      *
*       ptr_x  :  Pointer to complex data input (normal order).             *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data (normal order).            *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest ifft butterfly used in computation used for      *
*                 decomposing ifft into sub iffts, see notes.               *
*       offset :  Index in complex samples of sub-ifft from start of main   *
*                 ifft.                                                     *
*       n_max  :  size of main ifft in complex samples.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards ifft using a special  *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the      *
*       ifft producing the time domain data in the Y array. The output is   *
*       scaled by a scaling factor of 1/N.                                  *
*                                                                           *
*       As the ifft allows every input point to effect every output point   *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main ifft of size N    *
*       to be divided into several steps, allowing as much data reuse as    *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          *
*                                                                           *
*       Notice how the 1st ifft function is called on the entire 1K data    *
*       set it covers the 1st pass of the ifft until the butterfly size is  *
*       256. The following 4 iffts do 256 pt iffts 25% of the size. These   *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the ifft the following would be needed :                  *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the ifft is calculated by summing these     *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple iffts they can share the same table by calling the     *
*       small iffts from further down in the twiddle factor array. In the   *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the IFFT, four other calls are required to       *
*       perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 IFFTs in        *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the IFFT with one function call invocation as shown   *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the ifft. This collapses the inner 2 loops in the       *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised IFFT uses a redundant sequence of twiddle            *
*          factors to allow a linear access through the data. This linear   *
*          access enables data and instruction level parallelism.           *
*                                                                           *
*       3.The data produced by the ifftSPxSP ifft is in normal form, the    *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        *
*          points of the butterfly are corssed over, this has the effect    *
*          of making the data come out in bit reversed rather than          *
*          ifftSPxSP digit reversed order. This simplifies the last pass    *
*          of the loop. A simple table is used to do the bit reversal out   *
*          of place.                                                        *
*                                                                           *
*       unsigned char brev[64] =                                            *
*       {                                                                   *
*           0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   *
*           0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   *
*           0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   *
*           0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   *
*           0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   *
*           0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   *
*           0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   *
*           0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    *
*       };                                                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on         *
*          double word boundares. Real values are stored in even word       *
*          positions and imaginary values in odd positions.                 *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on        *
*          entry to each loop and reanlbed on exit out of the loop.         *
*                                                                           *
*       5. x must be padded with 16 words at the end.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, ifft_jmp;                               *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               ifft_jmp = stride + (stride>>1);                            *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - ifft_jmp);                                 *
*                   if (!predj) x += ifft_jmp;                              *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 - xl21;                                       *
*                   yt2 = xl1 - xl20;                                       *
*                   xt2 = xl0 + xl21;                                       *
*                   yt1 = xl1 + xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += ifft_jmp;                                      *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of ifft */                *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       1504 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_ifftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_ifftSPxSP.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_icfftr2/1117057344  1370  0     0       17513     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSPF_sp_icfftr2_dif(                                            */
/*                              float* x,                                   */
/*                              float* w,                                   */
/*                              short n                                     */
/*                             );                                           */
/*                                                                          */
/*          x : input and output sequences (dim-n)      (input/output)      */
/*              x has n complex numbers (2*n SP values).                    */
/*              The real and imaginary values are interleaved in memory.    */
/*              The input is in Bit reversed order nad output is in Normal  */
/*              Order.                                                      */
/*          w : FFT coefficients (dim-n/2)              (input)             */
/*              w has n/2 complex numbers (n SP values).                    */
/*              FFT coeficients must be in bit-reversed order               */
/*              The real and imaginary values are interleaved in memory     */
/*          n : FFT size                                (input)             */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine is used to compute the Inverse, Complex, Radix-2,      */
/*      Decimation-in-Frequency Fast Fourier Transform of a single          */
/*      precision complex sequence of size n, and a power of 2. The         */
/*      routine requires bit-reversed input and bit-reversed coefficents    */
/*      (twiddle factors) and produces results that are in normal order.    */
/*      Final scaling by 1/N is not done in this function.                  */
/*                                                                          */
/*      How To Use                                                          */
/*                                                                          */
/*          void main(void)                                                 */
/*          {                                                               */
/*              gen_w_r2(w, N);      // Generate coefficient table          */
/*              bit_rev(w, N>>1);    // Bit-reverse coefficient table       */
/*              cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   */
/*                                   // from TI available                   */
/*                                   // input in normal order, output in    */
/*                                   // order bit-reversed                  */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 */
/*                                   // input in bit-reversed order,        */
/*                                   // order output in normal              */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              divide(x, N);        // scale inverse FFT output            */
/*                                   // result is same as original input    */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. Loading input x as well as coefficient w in double word.         */
/*      2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       */
/*      3. Because the data loads are 1 itteration ahead of the             */
/*         coefficent loads, counter i was copied so that the actual        */
/*         count could live longer for the coefficent loads.                */
/*      4. 2 Inner loops are callapsed into one loop.                       */
/*      5. prolog and epilog are done in parallel with the outermost loop.  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double word  */
/*         boundary.                                                        */
/*      2. x should be padded with 4 words.                                 */
/*      3. n should be greater than 8.                                      */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions. Note that the assembly code is hand optimized         */
/*      and restrictions may apply.                                         */
/*                                                                          */
/*          void icfftr2_dif(float* x, float* w, short n)                   */
/*          {                                                               */
/*              short n2, ie, ia, i, j, k, m;                               */
/*              float rtemp, itemp, c, s;                                   */
/*                                                                          */
/*              n2 = 1;                                                     */
/*              ie = n;                                                     */
/*              for(k=n; k > 1; k >>= 1)                                    */
/*              {                                                           */
/*                  ie >>= 1;                                               */
/*                  ia = 0;                                                 */
/*                  for(j=0; j < ie; j++)                                   */
/*                  {                                                       */
/*                      c = w[2*j];                                         */
/*                      s = w[2*j+1];                                       */
/*                      for(i=0; i < n2; i++)                               */
/*                      {                                                   */
/*                          m = ia + n2;                                    */
/*                          rtemp     = x[2*ia]   - x[2*m];                 */
/*                          x[2*ia]   = x[2*ia]   + x[2*m];                 */
/*                          itemp     = x[2*ia+1] - x[2*m+1];               */
/*                          x[2*ia+1] = x[2*ia+1] + x[2*m+1];               */
/*                          x[2*m]    = c*rtemp   - s*itemp;                */
/*                          x[2*m+1]  = c*itemp   + s*rtemp;                */
/*                          ia++;                                           */
/*                      }                                                   */
/*                      ia += n2;                                           */
/*                  }                                                       */
/*                  n2 <<= 1;                                               */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to generate the coefficient table      */
/*      (non-bit reversed).                                                 */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*             table of size n/2 complex numbers //                         */
/*                                                                          */
/*          gen_w_r2(float* w, int n)                                       */
/*          {                                                               */
/*              int i;                                                      */
/*              float pi = 4.0*atan(1.0);                                   */
/*              float e = pi*2.0/n;                                         */
/*                                                                          */
/*              for(i=0; i < ( n>>1 ); i++)                                 */
/*              {                                                           */
/*                  w[2*i]   = cos(i*e);                                    */
/*                  w[2*i+1] = sin(i*e);                                    */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to bit-reverse the coefficents.        */
/*                                                                          */
/*          bit_rev(float* x, int n)                                        */
/*          {                                                               */
/*              int i, j, k;                                                */
/*              float rtemp, itemp;                                         */
/*                                                                          */
/*              j = 0;                                                      */
/*              for(i=1; i < (n-1); i++)                                    */
/*              {                                                           */
/*                  k = n >> 1;                                             */
/*                  while(k <= j)                                           */
/*                  {                                                       */
/*                      j -= k;                                             */
/*                      k >>= 1;                                            */
/*                  }                                                       */
/*                  j += k;                                                 */
/*                  if(i < j)                                               */
/*                  {                                                       */
/*                      rtemp    = x[j*2];                                  */
/*                      x[j*2]   = x[i*2];                                  */
/*                      x[i*2]   = rtemp;                                   */
/*                      itemp    = x[j*2+1];                                */
/*                      x[j*2+1] = x[i*2+1];                                */
/*                      x[i*2+1] = itemp;                                   */
/*                  }                                                       */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT.                                                        */
/*                                                                          */
/*          // divide each element of x by n //                             */
/*          divide(float* x, int n)                                         */
/*          {                                                               */
/*              int i;                                                      */
/*              float inv = 1.0 / n;                                        */
/*                                                                          */
/*              for(i=0; i < n; i++)                                        */
/*              {                                                           */
/*                  x[2*i]   = inv * x[2*i];                                */
/*                  x[2*i+1] = inv * x[2*i+1];                              */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      x should be padded with 4 words at the end.                         */
/*                                                                          */
/*      Since the twiddle table is in bit-reversed order, it turns out      */
/*      that the same twiddle table will also work for smaller IFFTs.This   */
/*      means that if you need to do both 512 and 1024 point IFFTs in the   */
/*      same application, you only need to have the 1024 point twiddle      */
/*      table.  The 512 point FFT will use the first half of the 1024       */
/*      point twiddle table.                                                */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*       2*n*log2(n) + 37                                                   */
/*       eg. IF n = 64, cycles = 805                                        */
/*       eg. IF n = 128, cycles = 1829                                      */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*       1600 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_ICFFTR2_DIF_H_
#define DSPF_SP_ICFFTR2_DIF_H_ 1

void DSPF_sp_icfftr2_dif(
                    float* x,
                    float* w,
                    short n
                   );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_icfftr2_dif.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_icfftr2/1117057344  1393  0     0       17432     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSPF_sp_icfftr2_dif(                                            *
*                               float* x,                                   *
*                               float* w,                                   *
*                               short n                                     *
*                              );                                           *
*                                                                           *
*           x : input and output sequences (dim-n)      (input/output)      *
*               x has n complex numbers (2*n SP values).                    *
*               The real and imaginary values are interleaved in memory.    *
*               The input is in Bit reversed order nad output is in Normal  *
*               Order.                                                      *
*           w : FFT coefficients (dim-n/2)              (input)             *
*               w has n/2 complex numbers (n SP values).                    *
*               FFT coeficients must be in bit-reversed order               *
*               The real and imaginary values are interleaved in memory     *
*           n : FFT size                                (input)             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute the Inverse, Complex, Radix-2,      *
*       Decimation-in-Frequency Fast Fourier Transform of a single          *
*       precision complex sequence of size n, and a power of 2. The         *
*       routine requires bit-reversed input and bit-reversed coefficents    *
*       (twiddle factors) and produces results that are in normal order.    *
*       Final scaling by 1/N is not done in this function.                  *
*                                                                           *
*       How To Use                                                          *
*                                                                           *
*           void main(void)                                                 *
*           {                                                               *
*               gen_w_r2(w, N);      // Generate coefficient table          *
*               bit_rev(w, N>>1);    // Bit-reverse coefficient table       *
*               cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   *
*                                    // from TI available                   *
*                                    // input in normal order, output in    *
*                                    // order bit-reversed                  *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 *
*                                    // input in bit-reversed order,        *
*                                    // order output in normal              *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               divide(x, N);        // scale inverse FFT output            *
*                                    // result is same as original input    *
*           }                                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. Loading input x as well as coefficient w in double word.         *
*       2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       *
*       3. Because the data loads are 1 itteration ahead of the             *
*          coefficent loads, counter i was copied so that the actual        *
*          count could live longer for the coefficent loads.                *
*       4. 2 Inner loops are callapsed into one loop.                       *
*       5. prolog and epilog are done in parallel with the outermost loop.  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Both input x and coefficient w should be aligned on double word  *
*          boundary.                                                        *
*       2. x should be padded with 4 words.                                 *
*       3. n should be greater than 8.                                      *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions. Note that the assembly code is hand optimized         *
*       and restrictions may apply.                                         *
*                                                                           *
*           void icfftr2_dif(float* x, float* w, short n)                   *
*           {                                                               *
*               short n2, ie, ia, i, j, k, m;                               *
*               float rtemp, itemp, c, s;                                   *
*                                                                           *
*               n2 = 1;                                                     *
*               ie = n;                                                     *
*               for(k=n; k > 1; k >>= 1)                                    *
*               {                                                           *
*                   ie >>= 1;                                               *
*                   ia = 0;                                                 *
*                   for(j=0; j < ie; j++)                                   *
*                   {                                                       *
*                       c = w[2*j];                                         *
*                       s = w[2*j+1];                                       *
*                       for(i=0; i < n2; i++)                               *
*                       {                                                   *
*                           m = ia + n2;                                    *
*                           rtemp     = x[2*ia]   - x[2*m];                 *
*                           x[2*ia]   = x[2*ia]   + x[2*m];                 *
*                           itemp     = x[2*ia+1] - x[2*m+1];               *
*                           x[2*ia+1] = x[2*ia+1] + x[2*m+1];               *
*                           x[2*m]    = c*rtemp   - s*itemp;                *
*                           x[2*m+1]  = c*itemp   + s*rtemp;                *
*                           ia++;                                           *
*                       }                                                   *
*                       ia += n2;                                           *
*                   }                                                       *
*                   n2 <<= 1;                                               *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to generate the coefficient table      *
*       (non-bit reversed).                                                 *
*                                                                           *
*           #include <math.h>                                               *
*           /* generate real and imaginary twiddle                          *
*              table of size n/2 complex numbers */                         *
*                                                                           *
*           gen_w_r2(float* w, int n)                                       *
*           {                                                               *
*               int i;                                                      *
*               float pi = 4.0*atan(1.0);                                   *
*               float e = pi*2.0/n;                                         *
*                                                                           *
*               for(i=0; i < ( n>>1 ); i++)                                 *
*               {                                                           *
*                   w[2*i]   = cos(i*e);                                    *
*                   w[2*i+1] = sin(i*e);                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to bit-reverse the coefficents.        *
*                                                                           *
*           bit_rev(float* x, int n)                                        *
*           {                                                               *
*               int i, j, k;                                                *
*               float rtemp, itemp;                                         *
*                                                                           *
*               j = 0;                                                      *
*               for(i=1; i < (n-1); i++)                                    *
*               {                                                           *
*                   k = n >> 1;                                             *
*                   while(k <= j)                                           *
*                   {                                                       *
*                       j -= k;                                             *
*                       k >>= 1;                                            *
*                   }                                                       *
*                   j += k;                                                 *
*                   if(i < j)                                               *
*                   {                                                       *
*                       rtemp    = x[j*2];                                  *
*                       x[j*2]   = x[i*2];                                  *
*                       x[i*2]   = rtemp;                                   *
*                       itemp    = x[j*2+1];                                *
*                       x[j*2+1] = x[i*2+1];                                *
*                       x[i*2+1] = itemp;                                   *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to perform the final scaling           *
*       of the IFFT.                                                        *
*                                                                           *
*           /* divide each element of x by n */                             *
*           divide(float* x, int n)                                         *
*           {                                                               *
*               int i;                                                      *
*               float inv = 1.0 / n;                                        *
*                                                                           *
*               for(i=0; i < n; i++)                                        *
*               {                                                           *
*                   x[2*i]   = inv * x[2*i];                                *
*                   x[2*i+1] = inv * x[2*i+1];                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       x should be padded with 4 words at the end.                         *
*                                                                           *
*       Since the twiddle table is in bit-reversed order, it turns out      *
*       that the same twiddle table will also work for smaller IFFTs.This   *
*       means that if you need to do both 512 and 1024 point IFFTs in the   *
*       same application, you only need to have the 1024 point twiddle      *
*       table.  The 512 point FFT will use the first half of the 1024       *
*       point twiddle table.                                                *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*        2*n*log2(n) + 37                                                   *
*        eg. IF n = 64, cycles = 805                                        *
*        eg. IF n = 128, cycles = 1829                                      *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*        1600 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_icfftr2_dif

*  ======================================================================== *
*   End of file:  DSPF_sp_icfftr2_dif.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_fir_cpl/1117057345  1418  0     0       4588      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     */

/*      Filter                                                              */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_fir_cplx(                                                  */

/*                        const float * restrict x,                         */

/*                        const float * restrict h,                         */

/*                        float *       restrict r,                         */

/*                        int   nh,                                         */

/*                        int   nr                                          */

/*                       )                                                  */

/*            x[2*(nr+nh-1)]:Pointer to complex Input array.                */

/*                           The input data pointer x must point to the     */

/*                           (nh)th complex element, i.e. element 2*(nh-1). */

/*            h[2*nh]:       Pointer to complex Coefficient array           */

/*                           (in normal order).                             */

/*            r[2*nr]:       Pointer to complex Output array.               */

/*            nh:            Number of complex coefficients in vector h.    */

/*            nr:            Number of complex output samples to calculate. */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This function implements the FIR filter for complex input data.    */

/*       The filter has nr output samples and nh coefficients. Each array   */

/*       consists of an even and odd term with even terms representing the  */

/*       real part and the odd terms the imaginary part of the element.     */

/*       The coefficients are expected in normal order.                     */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*       The outer loop is unrolled twice.                                  */

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*       1. nr is a multiple of 2 and greater than or equal to 2.           */

/*       2. nh is greater than or equal to 5.                               */

/*       3. x and h are double word aligned.                                */

/*       4. x points to 2*(nh-1)th input element.                           */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_FIR_CPLX_ASM_H_

#define DSPF_SP_FIR_CPLX_ASM_H_ 1



void DSPF_sp_fir_cplx(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_fir_cplx_h.asm                                          */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_fir_cpl/1117057345  1438  0     0       1763      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_cplx

* ======================================================================== *
*  End of file: DSPF_sp_fir_cplx_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_gen/1117057346  1460  0     0       5398      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   */

/*                                                                          */

/*   USAGE                                                                  */

/*                                                                          */

/*   This routine is C Callable and can be called as:                       */

/*                                                                          */

/*       void sp_firgen(const float *x, const float *h, float * restrict r, */

/*                  int nh, int nr);                                        */

/*                                                                          */

/*       x : Pointer to array holding the input floating point array        */

/*       h : Pointer to array holding the coefficient floating point        */

/*           array                                                          */

/*       y : Pointer to array holding the output floating point array       */

/*       nh: Number of coefficents                                          */

/*       nr: Number of output values                                        */

/*                                                                          */

/*   DESCRIPTION                                                            */

/*                                                                          */

/*       This routine implements a block FIR filter.  There are "nh"        */

/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */

/*       input samples.    The coefficients need to be placed in the "h"    */

/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */

/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */

/*       routine calculates y(0) through y(nr-1) using the following        */

/*       formula:                                                           */

/*                                                                          */

/*       y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */

/*                                                                          */

/*       where n = {0, 1, ... , nr-1}.                                      */

/*   C CODE                                                                 */

/*       This is the C equivalent for the assembly code.  Note that         */

/*       the assembly code is hand optimized and restrictions may           */

/*       apply.                                                             */

/*                                                                          */

/*       void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict r */

/*                   int nh, int nr)                                        */

/*       {                                                                  */

/*          int i, j;                                                       */

/*          float sum;                                                      */

/*                                                                          */

/*          for(j=0; j < nh; j++)                                           */

/*          {                                                               */

/*             sum = 0;                                                     */

/*             for(i=0; i < nr; i++)                                        */

/*             {                                                            */

/*                 sum += x[i+j] * h[i];                                    */

/*             }                                                            */

/*             r[j] = sum;                                                  */

/*          }                                                               */

/*       }                                                                  */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_FIR_GEN_ASM_H_

#define DSPF_SP_FIR_GEN_ASM_H_ 1



void DSPF_sp_fir_gen(const     float * restrict x, const float * restrict h, float * restrict r, int nh, int nr);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_fir_gen_h.asm                                           */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_fir_gen/1117057346  1479  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_gen

* ======================================================================== *
*  End of file: DSPF_sp_fir_gen_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fir_r2./1117057347  1500  0     0       4491      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       */

/*      Filter                                                              */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_fir_r2(                                                    */

/*                     const float * restrict x,                            */

/*                     const float * restrict h,                            */

/*                     float       * restrict r,                            */

/*                     int   nh,                                            */

/*                     int   nr                                             */

/*                     )                                                    */

/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */

/*            h[nh]:      Pointer to Coefficient array of size nh.          */

/*                        (in reverse order).                               */

/*            r[nr]:      Pointer to Output array od size nr.               */

/*            nh:         Number of coefficients                            */

/*            nr:         Number of output samples.                         */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       Computes a real FIR filter (direct-form) using coefficients        */

/*       stored in vector h[]. The real data input is stored in vector      */

/*       x[]. The filter output result is stored in vector r[]. The         */

/*       filter calculates nr output samples using nh coefficients.         */

/*       The coefficients are expected to be in reverse order.              */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*       The outer loop is unrolled four times and inner loop is            */

/*       unrolled twice.                                                    */

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*       1. nr is a multiple of 2 and greater than or equal to 2.           */

/*       2. nh is a multiple of 2 and greater than or equal to 8.           */

/*       3. x and h are double word aligned.                                */

/*       4. Coefficients in array h are expected to be in revrse order.     */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef SP_fir_r2_ASM_H_

#define SP_fir_r2_ASM_H_ 1



void DSPF_sp_fir_r2(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_fir_r2_h.asm                                            */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_fir_r2./1117057346  1518  0     0       1784      `
* ======================================================================== *

*  TEXAS INSTRUMENTS, INC.                                                 *

*                                                                          *

*  NAME                                                                    *

*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       *

*      Filter                                                              *

*                                                                          *

*                                                                          *

*  REVISION DATE                                                           *

*      23-Nov-2002                                                         *

*                                                                          *

*  USAGE                                                                   *

* ------------------------------------------------------------------------ *

*          Copyright (C) 2002 Texas Instruments, Incorporated.             *

*                          All Rights Reserved.                            *

* ======================================================================== *

        .global _DSPF_sp_fir_r2


* ======================================================================== *

*  End of file: DSPF_sp_fir_r2_h.asm                                            *

* ------------------------------------------------------------------------ *

*          Copyright (C) 2002 Texas Instruments, Incorporated.             *

*                          All Rights Reserved.                            *

* ======================================================================== *

DSPF_sp_fircirc/1117057348  1538  0     0       11470     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has following C prototype                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       );                                                                 */
/*                                                                          */
/*      x[]     : Input array (circular buffer of 2^(csize+1) bytes)        */
/*                Must be aligned at 2^(csize+1) byte boundary              */
/*      h[nh]   : Filter coefficients array                                 */
/*                Must be double-word aligned                               */
/*      r[nr]   : Output array                                              */
/*      index   : Offset by which to start reading from the input array     */
/*                Must be multiple of 2                                     */
/*      csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         */
/*                Must be 2 <= csize <= 31.                                 */
/*      nh      : Number of filter coefficients                             */
/*                Must be multiple of 2 and >= 4                            */
/*      nr      : Size of output array                                      */
/*                Must be multiple of 4                                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine implements a circularly addressed FIR filter.          */
/*      'nh' is the number of filter coefficients. 'nr' is the number       */
/*      of the output samples.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. LDDW instructions are used to load two SP floating point         */
/*         values simultaneously for the x and h arrays.                    */
/*      2. The outer loop is unrolled 4 times.                              */
/*      3. The inner loop is unrolled 2 times.                              */
/*      4. The variables prod1, prod3, prod5 and prod7 share A9.            */
/*         The variables prod0, prod2, prod4 and prod6 share B6.            */
/*         The variables sum1, sum3, sum5 and sum7 share A7.                */
/*         The variables sum0, sum2, sum4 and sum6 share B8.                */
/*         This multiple assignment is possible since the variables         */
/*         are always read just once on the first cycle that they are       */
/*         avaliable.                                                       */
/*      6. A load counter is used so that an epilog is not needed.  No      */
/*         extraneous loads are performed.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The circular input buffer x[] must be aligned at a 2^(csize+1)   */
/*         byte boundary. csize must lie in the range 2 <= csize <= 31.     */
/*      2. The number of coefficients  (nh) must be a multiple of 2         */
/*         and greater than or equal to 4.                                  */
/*      3. The number of outputs (nr) must be a multiple of 4 and           */
/*         greater than or equal to 4.                                      */
/*      4. The 'index' (offset to start reading input array) must be        */
/*         mutiple of 2 and less than or equal to (2^(csize-1) - 6)         */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       )                                                                  */
/*      {                                                                   */
/*          int i, j;                                                       */
/*          //Circular Buffer block size = ((2^(csize + 1)) / 4)            */
/*          //floating point numbers                                        */
/*          int mod = (1 << (csize - 1));                                   */
/*          float r0;                                                       */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              r0 = 0;                                                     */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  //Operation "% mod" is equivalent to "& (mod -1)"       */
/*                  //r0 += x[(i + j + index) % mod] * h[j];                */
/*                  r0 += x[(i + j + index) & (mod - 1)] * h[j];            */
/*              }                                                           */
/*          r[i] = r0;                                                      */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. This code is LITLLE ENDIAN.                                      */
/*      2. This routine disables interupts for its entire duration.         */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (2*nh + 10) nr/4 + 18                                               */
/*      eg. for nh = 30, nr=100                                             */
/*      cycles = 1768                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      512 bytes                                                           */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIRCIRC_ASM_H_
#define DSPF_SP_FIRCIRC_ASM_H_ 1

void DSPF_sp_fircirc(float     * x, float * h, float * r, int index, int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_fircirc/1117057347  1557  0     0       11503     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has following C prototype                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        );                                                                 *
*                                                                           *
*       x[]     : Input array (circular buffer of 2^(csize+1) bytes)        *
*                 Must be aligned at 2^(csize+1) byte boundary              *
*       h[nh]   : Filter coefficients array                                 *
*                 Must be double-word aligned                               *
*       r[nr]   : Output array                                              *
*       index   : Offset by which to start reading from the input array     *
*                 Must be multiple of 2                                     *
*       csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         *
*                 Must be 2 <= csize <= 31.                                 *
*       nh      : Number of filter coefficients                             *
*                 Must be multiple of 2 and >= 4                            *
*       nr      : Size of output array                                      *
*                 Must be multiple of 4                                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a circularly addressed FIR filter.          *
*       'nh' is the number of filter coefficients. 'nr' is the number       *
*       of the output samples.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. LDDW instructions are used to load two SP floating point         *
*          values simultaneously for the x and h arrays.                    *
*       2. The outer loop is unrolled 4 times.                              *
*       3. The inner loop is unrolled 2 times.                              *
*       4. The variables prod1, prod3, prod5 and prod7 share A9.            *
*          The variables prod0, prod2, prod4 and prod6 share B6.            *
*          The variables sum1, sum3, sum5 and sum7 share A7.                *
*          The variables sum0, sum2, sum4 and sum6 share B8.                *
*          This multiple assignment is possible since the variables         *
*          are always read just once on the first cycle that they are       *
*          avaliable.                                                       *
*       6. A load counter is used so that an epilog is not needed.  No      *
*          extraneous loads are performed.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The circular input buffer x[] must be aligned at a 2^(csize+1)   *
*          byte boundary. csize must lie in the range 2 <= csize <= 31.     *
*       2. The number of coefficients  (nh) must be a multiple of 2         *
*          and greater than or equal to 4.                                  *
*       3. The number of outputs (nr) must be a multiple of 4 and           *
*          greater than or equal to 4.                                      *
*       4. The 'index' (offset to start reading input array) must be        *
*          mutiple of 2 and less than or equal to (2^(csize-1) - 6)         *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        )                                                                  *
*       {                                                                   *
*           int i, j;                                                       *
*           //Circular Buffer block size = ((2^(csize + 1)) / 4)            *
*           //floating point numbers                                        *
*           int mod = (1 << (csize - 1));                                   *
*           float r0;                                                       *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               r0 = 0;                                                     *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   //Operation "% mod" is equivalent to "& (mod -1)"       *
*                   //r0 += x[(i + j + index) % mod] * h[j];                *
*                   r0 += x[(i + j + index) & (mod - 1)] * h[j];            *
*               }                                                           *
*           r[i] = r0;                                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. This code is LITLLE ENDIAN.                                      *
*       2. This routine disables interupts for its entire duration.         *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (2*nh + 10) nr/4 + 18                                               *
*       eg. for nh = 30, nr=100                                             *
*       cycles = 1768                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       512 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_sp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_sp_biquad./1117057348  1578  0     0       3961      `
/* ============================================================================*/

/*                                                                             */

/*  TEXAS INSTRUMENTS, INC.                                                    */

/*                                                                             */

/*  NAME                                                                       */

/*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                     */

/*                                                                             */

/*  USAGE                                                                      */

/*      This routine has following C prototype:                                */

/*                                                                             */

/*           void DSPF_sp_biquad (                                                  */

/*                         float x[],    Pointer to input samples              */

/*                         float b[],    Pointer to Nr coefs b0, b1, b2        */

/*                         float a[],    Pointer to Dr coefs a1, a2            */

/*                         float delay[] Pointer to filter delays              */

/*                         float r[],    Pointer to output samples             */

/*                         int   nx      Number of input/output samples        */

/*                         )                                                   */

/*                                                                             */

/*                                                                             */

/*                                                                             */

/*  DESCRIPTION                                                                */

/*      This routine implements a DF 2 transposed structure of the biquad      */

/*      filter. The transfer function of a biquad can be written               */ 

/*      as:                                                                    */

/*                                                                             */

/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)            */

/*                       H(Z) =     _________________________________          */

/*                                    1 + a(1)z^(-1) + a(2)z^(-2)              */

/*                                                                             */

/* ============================================================================*/

/*            Copyright (c) 2002 Texas Instruments, Incorporated.              */

/*                           All Rights Reserved.                              */

/* ============================================================================*/



#ifndef DSPF_SP_BIQUAD_ASM

#define DSPF_SP_BIQUAD_ASM 1



void DSPF_sp_biquad     (

                float x[],         //Pointer to input samples

                float b[],         //Pointer to numerator coefficients b[0], b[1] and b[2]

                float a[],         //Pointer to denominator coefficients a[1] and a[2]

                float delay[],     //Pointer to filter delays delay[0] and delay[1]

                float r[],         //Pointer to output samples

                int      nx         //Number of input/output samples

               );

#endif

/* ======================================================================== */

/*  End of file:  DSPF_sp_biquad.h                                               */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */










DSPF_sp_biquad./1117057348  1596  0     0       1680      `
 ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_biquad -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_biquad

* ======================================================================== *
*  End of file: DSPF_sp_biquad_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iir.h/  1117057349  0     0     0       6054      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_sp_iir    (float* restrict r1,                                 */
/*                      const float*    x,                                  */
/*                      float* restrict r2,                                 */
/*                      const float*    h2,                                 */
/*                      const float*    h1,                                 */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1   :  Delay element values (i/p and o/p)                     */
/*           x    :  Pointer to the input array                             */
/*           r2   :  Pointer to the output array                            */
/*           h2   :  Auto-regressive filter coefficients                    */
/*           h1   :  Moving average filter coefficients                     */
/*           nr   :  Number of output samples                               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder.                   */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_sp_iir (float* restrict r1,                                        */
/*                   const float*    x,                                     */
/*                   float* restrict r2,                                    */
/*                   const float*    h2,                                    */
/*                   const float*    h1,                                    */
/*                   int nr                                                 */
/*                  )                                                       */
/*      {                                                                   */
/*         int i, j;                                                        */
/*         float sum;                                                       */
/*                                                                          */
/*         for (i = 0; i < nr; i++)                                         */
/*         {                                                                */
/*             sum = h2[0] * x[4+i];                                        */
/*                                                                          */
/*             for (j = 1; j <= 4; j++)                                     */
/*                 sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];             */
/*                                                                          */
/*             r1[4+i] = sum;                                               */
/*             r2[i] = r1[4+i];                                             */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IIR_ASM_H_
#define DSPF_SP_IIR_ASM_H_ 1

void DSPF_sp_iir(float     *restrict r1, const float * x, float *restrict r2, const float * h2, const float * h1, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_iir_h.asm                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_iir.h67/1117057349  0     0     0       1680      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iir

* ======================================================================== *
*  End of file: DSPF_sp_iir_h.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iirlat./1117057350  1616  0     0       7263      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           */

/*                                                                          */

/*    USAGE                                                                  */ 

/*        This routine has following C prototype:                            */

/*                                                                           */ 

/*             void DSPF_sp_iirlat(                                               */ 

/*                           float *x,                                       */ 

/*                           int nx,                                         */ 

/*                           const float * restrict k,                       */ 

/*                           int nk,                                         */ 

/*                           float * restrict b,                             */ 

/*                           float * r                                       */ 

/*                           )                                               */ 

/*          x[nx]   : Input vector                                           */ 

/*          nx      : Length of input vector.                                */ 

/*          k[nk]   : Reflection coefficients                                */ 

/*          nk      : Number of reflection coefficients/lattice stages       */ 

/*                    Must be multiple of 2 and >=6.                         */ 

/*          b[nk+1] : Delay line elements from previous call. Should be      */ 

/*                    initialized to all zeros prior to the first call.      */ 

/*          r[nx]   : Output vector                                          */ 

/*                                                                           */ 

/*      DESCRIPTION                                                          */ 

/*          This routine implements a real all-pole IIR filter in lattice    */ 

/*          structure (AR lattice). The filter consists of nk lattice stages */ 

/*          Each stage requires one reflection coefficient k and one delay   */ 

/*          element b. The routine takes an input vector x[] and returns the */ 

/*          filter output in r[]. Prior to the first call of the routine the */ 

/*          delay elements in b[] should be set to zero. The input data may  */ 

/*          have to be pre-scaled to avoid overflow or achieve better SNR. T */ 

/*          reflections coefficients lie in the range -1.0 < k < 1.0. The    */ 

/*          order of the coefficients is such that k[nk-1] corresponds to th */ 

/*          first lattice stage after the input and k[0] corresponds to the  */ 

/*          last stage.                                                      */ 

/*                                                                           */

/*     TECHNIQUES                                                            */ 

/*          1.  The loop has been unrolled by 4 times.                       */ 

/*                                                                           */ 

/*          2.  Register sharing has been used to optimize on the use of regs*/

/*                                                                           */ 

/*                                                                           */ 

/*     ASSUMPTIONS                                                           */

/*                                                                           */ 

/*         1. nk is a multiple of 2 and >=6.                                 */

/*         2. Extraneous loads are allowed (80 bytes) before the start of    */

/*            array.                                                         */ 

/*                                                                           */ 

/*     C CODE                                                                */

/*                                                                           */ 

/*        void DSPF_sp_iirlat(float * x, int nx, const float * restrict k, int nk,*/ 

/*                       float * restrict b, float * r)                      */

/*        {                                                                  */

/*                                                                           */ 

/*       float rt;     // output       //                                    */

/*       int i, j;                                                           */

/*                                                                           */

/*       for (j = 0; j < nx; j++)                                            */

/*       {                                                                    */

/*           rt = x[j];                                                         */

/*                                                                            */

/*           for (i = nk - 1; i >= 0; i--)                                    */

/*           {                                                                 */

/*               rt = rt - b[i] * k[i];                                         */

/*               b[i + 1] = b[i] + rt * k[i];                                 */

/*           }                                                                 */

/*                                                                            */

/*           b[0] = rt;                                                      */                                

/*           r[j] = rt;                                                         */

/*       }                                                                    */

/*                                                                             */ 

/*      }                                                                     */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_IIRLAT_ASM_H_

#define DSPF_SP_IIRLAT_ASM_H_ 1



void DSPF_sp_iirlat(float     * x, int nx, const float * restrict k, int nk, float * restrict b, float * r);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_iirlat_h.asm                                            */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_iirlat./1117057350  1634  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iirlat

* ======================================================================== *
*  End of file: DSPF_sp_iirlat_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_convol./1117057351  1654  0     0       5887      `
/* =======================================================================      */

/*                                                                              */     

/*  TEXAS INSTRUMENTS, INC.                                                     */

/*                                                                              */

/*  NAME                                                                         */

/*      DSPF_sp_convol: Convolution(Floating Point Version)                          */ 

/*                                                                              */

/*  USAGE                                                                       */

/*      This routine is C callable, and has the following C prototype:          */

/*                                                                              */

/*      void DSPF_sp_convol                                                          */  

/*             (                                                                */

/*                       float *x, //x: Pointer to input samples//              */          

/*                       float *h, //h: Pointer to impulse response samples//   */

/*                       float *r, //r: Pointer to output samples//             */

/*                       int   nh, //nh: Number of impulse response samples//   */

/*                       int   nr  //nr: Number of output samples//             */

/*             )                                                                */

/*                                                                              */

/*              x = pointer to real input vector of size = nr+nh-1              */

/*                  a typically contains input data (x) padded with             */

/*                  consecutive nh - 1  zeros at the beginning and end.         */

/*              h = pointer to real input vector of size nh in forward order.   */

/*                  h typically contains the filter coefs.                      */

/*              r = pointer to real output vector of size nr                    */

/*              nh= number of elements in vector b. NOTE: nh <= nr  nh is       */

/*                  typically noted as m in convol formulas. nh must be a       */

/*                  MULTIPLE of 2                                               */

/*              nr= number of elements in vector r. nr must be a MULTIPLE of 4  */

/*                                                                              */

/*              If routine is not to be used as a C callable function then      */

/*              you need to initialize values for all of the values passed      */

/*              as these are assumed to be in registers as defined by the       */

/*              calling convention of the compiler, (refer to the C compiler    */

/*              reference guide).                                               */

/*                                                                              */

/*  DESCRIPTION                                                                 */

/*              This fucntion calculates the full-lenght convolution of real    */

/*              vectors x and h using time-domain techniques. The result is     */

/*              placed in real vector r.                                        */

/*                                                                              */

/*              It is assumed that input vector x is padded with nh-1 no of     */

/*              zeros in the beginning and end.                                 */

/*                                                                              */

/*              It is assumed that the length of the input vector h, nh, is a   */

/*              multiple of 2 and the length of the output vector r, nr, is a   */    

/*              multiple of 4. nh is greater thanor equal to 4 and nr is greater*/

/*              than or equal to nh. The routine computes 4 output              */

/*              samples at a time.                                              */

/*                                                                              */

/*              x and h are assumed to be aligned on a double word boundary     */

/*                                                                              */

/* -----------------------------------------------------------------------      */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.               */

/*                           All Rights Reserved.                               */

/* =======================================================================      */



#ifndef DSPF_SP_CONVOL_ASM

#define DSPF_SP_CONVOL_ASM 1



void DSPF_sp_convol

        (                                                                   

             float *x, /*x: Pointer to input samples*/                                   

             float *h, /*h: Pointer to impulse response samples*/           

             float *r, /*r: Pointer to output samples*/                       

             int   nh, /*nh: Number of impulse response samples*/            

             int   nr  /*nr: Number of output samples*/                     

        );



#endif

/* ======================================================================== */

/*  End of file:  DSPF_sp_convol.h                                               */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */


DSPF_sp_convol./1117057351  1672  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_convol -- Single Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_convol

* ======================================================================== *
*  End of file: DSPF_sp_convol_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotp_sq/1117057352  1692  0     0       4412      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       */

/*                                                                          */

/* USAGE                                                                    */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_dotp_sqr(                                                  */

/*                       float G,                                           */

/*                       const float * x,                                   */

/*                       const float * y,                                   */

/*                       float *  restrict r,                               */

/*                       int   nx                                           */

/*                       )                                                  */

/*            G:      Sum of y-squared initial value.                       */

/*            x[nx]:  Pointer to First input array.                         */

/*            y[nx]:  Pointer to Second input array.                        */

/*            r:      Pointer to Output for Accumulation of x[]*y[].        */

/*            nx:     Length of input vectors.                              */

/*                                                                          */

/*                                                                          */

/* DESCRIPTION                                                              */

/*       This routine computes the dot product of x[] and y[] arrays,adding */

/*       it to the value in the location pointed to by r. Additionally, it  */

/*       computes the sum of the squares of the terms in the y array,adding */

/*       it to the argument G. The final value of G is given as the return  */

/*       value of the function.                                             */

/*                                                                          */

/*       x and y should be aligned on a double word boundary.               */

/*                                                                          */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*      The loop is unrolled four times.                                    */

/*                                                                          */

/* ASSUMPTIONS                                                              */

/*                                                                          */

/*      1. nx is a multiple of 4.                                           */

/*      2. x and y should be double word aligned.                           */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_DOTP_SQR_ASM_H_

#define DSPF_SP_DOTP_SQR_ASM_H_ 1



float DSPF_sp_dotp_sqr(float     G, const float * x, const float * y, float *restrict r, int nx);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_dotp_sqr_h.asm                                          */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_dotp_sq/1117057352  1712  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_sqr

* ======================================================================== *
*  End of file: DSPF_sp_dotp_sqr_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotprod/1117057353  1734  0     0       4089      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      float dotp(const float *x, const float *y, const int nx)            */
/*      {                                                                   */
/*         int i;                                                           */
/*         float sum = 0;                                                   */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTPROD_ASM_H_
#define DSPF_SP_DOTPROD_ASM_H_ 1

float DSPF_sp_dotprod(const     float * x, const float * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_dotprod/1117057353  1753  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotprod

* ======================================================================== *
*  End of file: DSPF_sp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotp_cp/1117057354  1774  0     0       6614      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         */
/*      product                                                             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const float *x, const float *y, int n, float *    */
/*                        restrict re, float * restrict im);                */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real part of the result */
/*      im    : Pointer to the location storing the imaginary part of       */
/*          the result                                                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1.  The loop is unrolled 4 times because the loop carried           */
/*      dependency bound is 4.                                              */
/*                                                                          */
/*      2.  LDDW instructions are used to load two SP floating point        */
/*          values at a time for the x and y arrays.                        */
/*                                                                          */
/*      3.  A load counter avoids all extraneous loads.                     */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1.  Little Endian is assumed for LDDW instructions.                 */
/*      2.  Since single assignment of registers is not used,               */
/*          interrupts should be disabled before this function is           */
/*          called.                                                         */
/*      3.  Loop counter must be > 0.                                       */
/*  4.  The x and y arrays must be double word aligned.                     */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const    float* x, const float* y,                */
/*                       int n, float* restrict re,                         */
/*               float* restrict im)                                        */
/*      {                                                                   */
/*                                                                          */
/*          float real=0, imag=0;                                           */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTP_CPLX_ASM_H_
#define DSPF_SP_DOTP_CPLX_ASM_H_ 1

void DSPF_sp_dotp_cplx(const     float * x, const float * y, int n, float * restrict re, float * restrict im);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotp_cplx_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_dotp_cp/1117057354  1795  0     0       1764      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_cplx

* ======================================================================== *
*  End of file: DSPF_sp_dotp_cplx_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_maxval./1117057355  1818  0     0       3716      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       float DSPF_sp_maxval(                                                   */

/*                       const float* x,                                    */

/*                       int nx                                             */

/*                      )                                                   */

/*                                                                          */

/*            x :  Pointer to Input array.                                  */

/*            nx:  Number of Inputs in the input Array.                     */

/*            Returns float: Maximum value in the input array               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       This routine Finds out the maximum number in the input array.      */

/*                                                                          */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*      The loop is unrolled Six times.                                     */

/*      Six maximums are maintained in each iteration.                      */ 

/*      One of the maximums are calculated using SUBSP in place of CMPGTSP  */

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*      nx should be multiple of 2 and >= 2.                                */ 

/*      x should be double word aligned.                                    */ 

/*      NAN( Not a Number in Single Precision format) in the input are      */ 

/*      disregarded.                                                        */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_MAXVAL_ASM_H_

#define DSPF_SP_MAXVAL_ASM_H_ 1



float DSPF_sp_maxval(const     float* x, int nx);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_maxval_h.asm                                            */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_maxval./1117057355  1836  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxval

* ======================================================================== *
*  End of file: DSPF_sp_maxval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_maxidx./1117057356  1856  0     0       3580      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_sp_maxidx(                                                     */
/*                      const float* x,                                     */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns int: Index of Maximum value                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the index of maximum number in the input    */
/*       array.                                                             */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled three times.                                   */
/*      Three maximums are maintained in each iteration.                    */
/*      MPY indtructions are  used for move.                                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      nx is a multiple of 3                                               */
/*      nx >= 3, and nx <= 2^16-1.                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAXIDX_ASM_H_
#define DSPF_SP_MAXIDX_ASM_H_ 1

int DSPF_sp_maxidx(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_maxidx_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_maxidx./1117057356  1874  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxidx

* ======================================================================== *
*  End of file: DSPF_sp_maxidx_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minval./1117057357  1894  0     0       3881      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             */

/*                                                                          */

/*     USAGE                                                                */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       float DSPF_sp_minval(                                                   */

/*                       const float* x,                                    */

/*                       int nx                                             */

/*                      )                                                   */

/*                                                                          */

/*            x :  Pointer to Input array.                                  */

/*            nx:  Number of Inputs in the input Array.                     */

/*            Returns float: Minimum value in the input array               */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*       This routine Finds out the minimum number in the input array.      */

/*                                                                          */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*       The loop is unrolled Six times.                                    */ 

/*       Six minimums are maintained in each iteration.                     */ 

/*       One of the minimums are calculated using SUBSP in place of CMPGTSP */ 

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*       nx should be multiple of 2 and >= 2.                               */ 

/*       x should be double word aligned.                                   */ 

/*       NAN( Not a Number in Single Precision format) in the input are     */ 

/*       disregarded.                                                       */ 

/*                                                                          */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_MINVAL_ASM_H_

#define DSPF_SP_MINVAL_ASM_H_ 1



float DSPF_sp_minval(const     float* x, int nx);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_minval_h.asm                                            */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */


DSPF_sp_minval./1117057356  1912  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minval

* ======================================================================== *
*  End of file: DSPF_sp_minval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecreci/1117057359  1932  0     0       5137      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecrecip(const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_vecrecip module calculates the reciprocal of each element in */
/*      array x and returns the output in array r. It uses 2 iterations     */
/*      of the Newton-Raphson method to improve the accuracy of the output  */
/*      generated by the RCPSP instruction of the C67x. Each iteration      */
/*      doubles the accuracy. The initial output generated by RCPSP is 8 bi */
/*      So after the first iteration it is 16 bits and after the second it  */
/*      the full 23 bits. The formula used is:                              */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPSP.          */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel.                                  */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*  void DSPF_sp_vecrecip(const    float* x, float* restrict r, int n)           */
/*      {                                                                   */
/*          int i;                                                          */
/*          for(i = 0; i < n; i++)                                          */
/*              r[i] = 1 / x[i];                                            */
/*      }                                                                   */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECRECIP_ASM_H_
#define DSPF_SP_VECRECIP_ASM_H_ 1

void DSPF_sp_vecrecip(const     float * x, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecrecip_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_vecreci/1117057359  1952  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecrecip

* ======================================================================== *
*  End of file: DSPF_sp_vecrecip_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecsum_/1117057360  1974  0     0       3996      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecsum_sq(const float *x,                                  */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*   array x and returns the sum.                                           */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float DSPF_sp_vecsum_sq(const    float *x,int n)                          */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECSUM_SQ_ASM_H_
#define DSPF_SP_VECSUM_SQ_ASM_H_ 1

float DSPF_sp_vecsum_sq(const     float * x, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecsum_sq_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecsum_/1117057360  1995  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecsum_sq

* ======================================================================== *
*  End of file: DSPF_sp_vecsum_sq_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_w_vec.h/1117057361  0     0     0       4750      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_sp_w_vec(const float* x,                                     */
/*                      const float * y,                                    */
/*                      float m,                                            */
/*                      float * restrict r,                                 */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are single precision floating             */
/*     point numbers.                                                       */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_sp_w_vec(    const float *    x,                                */
/*                       const float *    y,                                */
/*                       float         m,                                   */
/*                       float *        restrict r,                         */
/*                       int         nr                                     */
/*                    )                                                     */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_W_VEC_ASM_H_
#define DSPF_SP_W_VEC_ASM_H_ 1

void DSPF_sp_w_vec(const     float * x, const float * y, float m, float * restrict r, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_w_vec_h.asm                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_w_vec.h/1117057361  2018  0     0       1682      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_w_vec

* ======================================================================== *
*  End of file: DSPF_sp_w_vec_h.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_vecmul./1117057362  2037  0     0       4338      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecmul -- Single Precision vector multiplication                 */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_sp_vecmul   (const float *x,                                   */
/*                        const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element floating point         */
/*   multiply of the vectors x[] and y[] and returns the values in r[].     */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float sp_vecsum_sq(const    float *x,int n)                         */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECMUL_ASM_H_
#define DSPF_SP_VECMUL_ASM_H_ 1

void DSPF_sp_vecmul(const     float * x, const float * y, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecmul_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecmul./1117057362  2055  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecmul -- Single Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecmul

* ======================================================================== *
*  End of file: DSPF_sp_vecmul_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057363  2075  0     0       3828      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                */

/*                                                                          */

/* USAGE                                                                    */

/*     This routine has following C prototype                               */

/*                                                                          */

/*         void DSPF_sp_mat_mul                                                  */

/*         (                                                                */

/*             float *x, int r1, int c1,                                    */

/*             float *y,         int c2,                                    */

/*             float *r,                                                    */

/*         );                                                               */

/*                                                                          */

/*     x[]  : Pointer to r1 by c1 input matrix.                             */

/*     r1   : Number of rows in x.                                          */

/*     c1   : Number of columns in x.  Also number of rows in y.            */

/*     y[]  : Pointer to c1 by c2 input matrix.                             */

/*     c2   : Number of columns in y.                                       */

/*     r[]  : Pointer to r1 by c2 output matrix.                            */

/*                                                                          */

/* DESCRIPTION                                                              */

/*     This function computes the expression "r = x * y" for the matrices   */

/*     x and y.  The column dimension of x must match the row dimension     */

/*     of y.  The resulting matrix has the same number of rows as x and     */

/*     the same number of columns as y.                                     */

/*                                                                          */

/*     The values stored in the matrices are assumed to be single precision */

/*     floating point values.                                               */

/*                                                                          */

/*     This code is suitable for dense matrices.  No optimizations are      */

/*     made for sparse matrices.                                            */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_MAT_MUL_ASM_H_

#define DSPF_SP_MAT_MUL_ASM_H_ 1



void DSPF_sp_mat_mul(float     * x, int r1, int c1, float * y, int c2, float * r);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_mat_mul_h.asm                                           */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_mat_mul/1117057363  2094  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      14-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_tra/1117057364  2115  0     0       3790      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_mat_trans(                                                 */
/*                            const float *restrict x,                      */
/*                            int rows,                                     */
/*                            int cols,                                     */
/*                            float *restrict r)                            */
/*                                                                          */
/*          x[r1*c1]:  Input matrix containing r1*c1 floating point         */
/*                     numbers having r1 rows and c1 columns.               */
/*          rows    :  Number of rows in Matrix x.                          */
/*                     Also Number of columns in matrix y                   */
/*          cols    :  No. of columns in Matrx x.                           */
/*                     Also no. of rows in Matrix y.                        */
/*          y[c1*c2]:  Output matrix containing c1*r1 floating point        */
/*                     numbers having c1 rows and r1 columns.               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    The loop is unrolled twice.                                           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    rows > 0 and cols > 0                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_TRANS_ASM_H_
#define DSPF_SP_MAT_TRANS_ASM_H_ 1

void DSPF_sp_mat_trans(const     float *restrict x, int rows, int cols, float *restrict r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_trans_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_tra/1117057364  2136  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_trans

* ======================================================================== *
*  End of file: DSPF_sp_mat_trans_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_mul/1117057365  2159  0     0       5724      `
/* ======================================================================== */

/*  TEXAS INSTRUMENTS, INC.                                                 */

/*                                                                          */

/*  NAME                                                                    */

/*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    */

/*                                                                          */

/*  USAGE                                                                   */

/*       This routine has the following C prototype:                        */

/*                                                                          */

/*       void DSPF_sp_mat_mul_cplx(                                              */

/*                              const float* x,                             */

/*                              int r1,                                     */

/*                              int c1,                                     */

/*                              const float* y,                             */

/*                              int c2,                                     */

/*                              float* restrict r                           */

/*                           )                                              */

/*                                                                          */

/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */

/*                          floating point numbers having r1 rows and c1    */

/*                          columns of complex numbers.                     */

/*            r1        :   Number of rows in Matrix x.                     */

/*            c1        :   No. of columns in Matrx x.                      */

/*                          Also no. of rows in Matrix y.                   */

/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */

/*                          floating point numbers having c1 rows and c2    */

/*                          columns of complex numbers.                     */

/*            c2        :   No. of columns in Matrix y.                     */

/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */

/*                          point numbers having c1 rows and c2 columns of  */

/*                          complex numbers.                                */

/*                                                                          */

/*                          Complex numbers are stored consecutively with   */

/*                          Real values are stored in even word positions   */

/*                          and imaginary values in odd positions.          */

/*                                                                          */

/*  DESCRIPTION                                                             */

/*        This function computes the expression "r = x * y" for the         */

/*        matrices x and y. The columnar dimension of x must match the row  */

/*        dimension of y. The resulting matrix has the same number of rows  */

/*        as x and the same number of columns as y.                         */

/*                                                                          */

/*        Each element of Matrices are assumed to be complex numbers with   */

/*        Real values are stored in even word positions and imaginary       */

/*        values in odd positions.                                          */

/*                                                                          */

/*  TECHNIQUES                                                              */

/*                                                                          */

/*        Innermost loop is Unrolled twice.                                 */

/*        Two inner loops are collapsed into one loop.                      */

/*        Outermost loop is executed in parallel with innner loops.         */

/*                                                                          */

/*  ASSUMPTIONS                                                             */

/*                                                                          */

/*        c1 >= 4, and r1,r2>=1                                             */

/*        x should be padded with 6 words                                   */

/*        x and y should be double word aligned                             */

/*                                                                          */

/* ------------------------------------------------------------------------ */

/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */

/*                           All Rights Reserved.                           */

/* ======================================================================== */

#ifndef DSPF_SP_MAT_MUL_CPLX_ASM_H_

#define DSPF_SP_MAT_MUL_CPLX_ASM_H_ 1



void DSPF_sp_mat_mul_cplx(const     float* x, int r1, int c1, const float* y, int c2, float* restrict r);



#endif

/* ======================================================================== */

/*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      */

/* ------------------------------------------------------------------------ */

/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */

/*                          All Rights Reserved.                            */

/* ======================================================================== */

DSPF_sp_mat_mul/1117057365  2183  0     0       1689      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul_cplx

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_blk_mov/1117057366  2209  0     0       3207      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_blk_move -- Single Precision Block Move                          */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_blk_move                                                   */
/*                     (                                                    */
/*                         const float    *r,                               */
/*                         const float *  restrict r,                       */
/*                         int            nx,                               */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data to be moved.                       */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:        Number of floats to move.                               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine moves nx floats from memory location pointed to by x  */
/*       to a separate memory location pointed to by r.                     */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_BLK_MOVE_ASM_H_
#define DSPF_SP_BLK_MOVE_ASM_H_ 1

void DSPF_sp_blk_move(const     float * x, float *restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_blk_move_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_blk_mov/1117057366  2229  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_blk_move -- Single Precision Block Move                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_blk_move

* ======================================================================== *
*  End of file: DSPF_sp_blk_move_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap1/1117057367  2251  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap16                                                   */
/*                     (                                                    */
/*                         void * restrict x,                               */
/*                         void * restrict r,                               */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of shorts (16-bit values) to endian-swap.          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*         The date in the x array is endian swapped, meaning that the      */
/*      byte-order of the bytest within wach half-word (short) of x is      */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP16_ASM_H_
#define DSPF_BLK_ESWAP16_ASM_H_ 1

void DSPF_blk_eswap16(short     * restrict x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap16_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap1/1117057367  2271  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap16

* ======================================================================== *
*  End of file: DSPF_blk_eswap16_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap3/1117057368  2293  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap32                                                   */
/*                     (                                                    */
/*                         float * restrict x,                              */
/*                         float * restrict r,                              */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of words (32-bit values) to endian-swap.           */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytest within wach word of x is                   */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP32_ASM_H_
#define DSPF_BLK_ESWAP32_ASM_H_ 1

void DSPF_blk_eswap32(float     * restrict x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap32_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap3/1117057367  2313  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap32

* ======================================================================== *
*  End of file: DSPF_blk_eswap32_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap6/1117057368  2335  0     0       3933      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap64                                                   */
/*                     (                                                    */
/*                         double * restrict x,                             */
/*                         double * restrict r,                             */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of double words (64-bit values) to endian-swap.    */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytes within each double word of x is             */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP64_ASM_H_
#define DSPF_BLK_ESWAP64_ASM_H_ 1

void DSPF_blk_eswap64(double     * restrict x, double * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap64_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap6/1117057368  2355  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap64

* ======================================================================== *
*  End of file: DSPF_blk_eswap64_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_fltoq15.h/ 1117057369  0     0     0       4801      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       */
/*                                                                          */
/*  USAGE                                                                   */
/*     This routine is C-callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     );                                                                   */
/*                                                                          */
/*     x[nx] :  Input array contaning values of type float                  */
/*     r[nx] :  Output array contains Q15 equivalents of x[nx]              */
/*     nx    :  Number of elements in both arrays                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*     Convert the IEEE floating point numbers stored in vector x[] into    */
/*     Q.15 format numbers stored in vector r[]. Results will be rounded    */
/*     towards negative infinity. All values that exceed the size limit     */
/*     will be saturated to 0x7fff if value is positive and 0x8000 if       */
/*     value is negative.                                                   */
/*                                                                          */
/*  C CODE                                                                  */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     )                                                                    */
/*     {                                                                    */
/*         int i, a;                                                        */
/*                                                                          */
/*         for(i = 0; i < nx; i++)                                          */
/*         {                                                                */
/*             a = floor(32768 * x[i]);                                     */
/*                                                                          */
/*             // saturate to 16-bit //                                     */
/*             if (a>32767)  a =  32767;                                    */
/*             if (a<-32768) a = -32768;                                    */
/*                                                                          */
/*             r[i] = (short) a;                                            */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_FLTOQ15_ASM_H_
#define DSPF_FLTOQ15_ASM_H_ 1

void DSPF_fltoq15(const     float * x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_fltoq15_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_fltoq15.h6/1117057369  2377  0     0       1681      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_fltoq15

* ======================================================================== *
*  End of file: DSPF_fltoq15_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minerr./1117057370  2395  0     0       4111      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      */
/*      dot product                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,    */
/*                                              int *restrict max_index)    */
/*                                                                          */
/*          GSP0_TABLE[256*9]: GSP0 terms array.                            */
/*          errCoefs[9]:       Array of error coefficients.                 */
/*                             Must be Double word aligned.                 */
/*          max_index:         Index to GSP0_TABLE[max_index], the first    */
/*                             element of the 9-element vector that         */
/*                             resulted in the maximum dot product.         */
/*          return float       Maximum dot product result.                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       Performs a dot product on 256 pairs of 9 element vectors and       */
/*       searches for the pair of vectors which produces the maximum dot    */
/*       product result. This is a large part of the VSELP vocoder          */
/*       codebook search.                                                   */
/*                                                                          */
/*       The function stores the index to the first element of the          */
/*       9-element vector that resulted in the maximum dot product in the   */
/*       memory loaction Pointed by max_index. The maximum dot product      */
/*       value is returned by the function.                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The inner loop is totally unrolled.                                 */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      errCoefs must be Double word aligned.                               */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MINERR_ASM_H_
#define DSPF_SP_MINERR_ASM_H_ 1

float DSPF_sp_minerr(const     float* GSP0_TABLE, const float* errCoefs, int *restrict max_index);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_minerr_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_minerr./1117057370  2413  0     0       1761      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      *
*      dot product                                                         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minerr

* ======================================================================== *
*  End of file: DSPF_sp_minerr_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_q15tofl.h/ 1117057371  0     0     0       3921      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       */
/*      format                                                              */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_q15tofl(short *x, float *r, int nx);                          */
/*                                                                          */
/*      x     : Input array containing shorts in Q15 format                 */
/*      r     : Output array containing equivalent floats                   */
/*      nx    : Number of values in the x vector                            */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine converts data in the Q15 format into IEEE Single Preci */
/*      floating point.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*  void DSPF_q15tofl(short    *x, float *r, int nx)                             */
/*     {                                                                    */
/*      int i;                                                              */
/*      for (i=0;i<nx;i++)                                                  */
/*           r[i]=(float)x[i]/0x8000;                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_Q15TOFL_ASM_H_
#define DSPF_Q15TOFL_ASM_H_ 1

void DSPF_q15tofl(const     short * x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_q15tofl_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_q15tofl.h6/1117057371  2433  0     0       1759      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       *
*      format                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_q15tofl

* ======================================================================== *
*  End of file: DSPF_q15tofl_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_lms.h/  1117057372  0     0     0       9134      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_lms -- Double Precision floating point LMS algorithm             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C callable, and has the following C prototype:       */
/*                                                                          */
/*     double DSPF_dp_lms (double *x,                                            */
/*                    double *h,                                             */
/*                    double *desired,                                      */
/*                    double *r,                                            */
/*                    double adaptrate,                                     */
/*                    double error,                                         */
/*                    int nh,                                               */
/*                    int nr                                                */
/*                    )                                                     */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  */
/*     signal and a desired input signal, the filter produces an output     */
/*     signal, the final coefficient values and returns the final output    */
/*     error signal.                                                        */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*   1. The inner loop is unrolled Two times to allow update of             */
/*      two coefficients in the kernel.                                     */
/*                                                                          */
/*   2. The 'error' term needs to be computed in the outer loop             */
/*      before a new iteration of the inner loop can start. As a            */
/*      result the prolog cannot be placed in parallel with epilog          */
/*      (after the loop kernel).                                            */
/*                                                                          */
/*  3. Register sharing is used to make optimal use of available            */
/*      registers.                                                          */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*   1. The inner loop counter must be a multiple of 2 and >=2.             */
/*   2. Little endianness is assumed.                                       */
/*   3. Extraneous loads are allowed in the program.                        */
/*   4. The coefficient array is assumed to be in reverse order,            */
/*      i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   This is the C equivalent of the Assembly Code without                  */
/*   restrictions.                                                          */
/*                                                                          */
/*   Note that the assembly code is hand optimized and restrictions         */
/*   may apply.                                                             */
/*                                                                          */
/*   double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
/*        int nr, double error)                                             */
/*   {                                                                      */
/*       int i,j;                                                           */
/*       double sum;                                                        */
/*                                                                          */
/*       for (i = 0; i < nr; i++)                                           */
/*       {                                                                  */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*           h[j] = h[j] + (ar*error*x[i+j-1]);                             */
/*        }                                                                 */
/*                                                                          */
/*       sum = 0.0f;                                                        */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*          sum += h[j] * x[i+j];                                           */
/*        }                                                                 */
/*       y[i] = sum;                                                        */
/*       error = d[i] - sum;                                                */
/*      }                                                                   */
/*      return error;                                                       */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*    (4*nh + 47) nr + 27                                                   */
/*    eg. for nh = 24 and nr = 36                                           */
/*    cycles = 5175                                                         */
/*                                                                          */
/* CODESIZE                                                                 */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_LMS_H_
#define DSPF_DP_LMS_H_ 1

double DSPF_dp_lms     (double *x,
              double *h,
               double *desired,
               double *r,
               double adaptrate,
               double error,
               int nh,
               int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_lms.h67/1117057372  0     0     0       9057      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C callable, and has the following C prototype:       *
*                                                                           *
*      double DSPF_dp_lms (double *x,                                            *
*                     double *h,                                             *
*                     double *desired,                                      *
*                     double *r,                                            *
*                     double adaptrate,                                     *
*                     double error,                                         *
*                     int nh,                                               *
*                     int nr                                                *
*                     )                                                     *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  *
*      signal and a desired input signal, the filter produces an output     *
*      signal, the final coefficient values and returns the final output    *
*      error signal.                                                        *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*    1. The inner loop is unrolled Two times to allow update of             *
*       two coefficients in the kernel.                                     *
*                                                                           *
*    2. The 'error' term needs to be computed in the outer loop             *
*       before a new iteration of the inner loop can start. As a            *
*       result the prolog cannot be placed in parallel with epilog          *
*       (after the loop kernel).                                            *
*                                                                           *
*   3. Register sharing is used to make optimal use of available            *
*       registers.                                                          *
*                                                                           *
*    ASSUMPTIONS                                                            *
*    1. The inner loop counter must be a multiple of 2 and >=2.             *
*    2. Little endianness is assumed.                                       *
*    3. Extraneous loads are allowed in the program.                        *
*    4. The coefficient array is assumed to be in reverse order,            *
*       i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    This is the C equivalent of the Assembly Code without                  *
*    restrictions.                                                          *
*                                                                           *
*    Note that the assembly code is hand optimized and restrictions         *
*    may apply.                                                             *
*                                                                           *
*    double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
*         int nr, double error)                                             *
*    {                                                                      *
*        int i,j;                                                           *
*        double sum;                                                        *
*                                                                           *
*        for (i = 0; i < nr; i++)                                           *
*        {                                                                  *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*            h[j] = h[j] + (ar*error*x[i+j-1]);                             *
*         }                                                                 *
*                                                                           *
*        sum = 0.0f;                                                        *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*           sum += h[j] * x[i+j];                                           *
*         }                                                                 *
*        y[i] = sum;                                                        *
*        error = d[i] - sum;                                                *
*       }                                                                   *
*       return error;                                                       *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
*  CYCLES                                                                   *
*     (4*nh + 47) nr + 27                                                   *
*     eg. for nh = 24 and nr = 36                                           *
*     cycles = 5175                                                         *
*                                                                           *
*  CODESIZE                                                                 *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_lms

*  ======================================================================== *
*   End of file:  DSPF_dp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_autocor/1117057373  2451  0     0       8210      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_autocor -- double Precision autocorrelation                      */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*                                                                          */
/*      r  = Pointer to output array of autocorrelation of length nr        */
/*      x  = Pointer to input array of length nx+nr. Input data must        */
/*           be padded with nr consecutive zeros at the beginning.          */
/*      nx = Length of autocorrelation vector.                              */
/*      nr = Length of lags.                                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the autocorrelation of the input array x.     */
/*      is assumed that the length of the input array, x, is a              */
/*      multiple of 2 and the length of the output array, r, is a           */
/*      multiple of 4. The assembly routine computes 4 output samples       */
/*      at a time. It is assumed that input vector x is padded with nr      */
/*      no of zeros in the beginning.                                       */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice and the outer loop is unrolled  */
/*      four times.                                                         */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 2 and greater than or equal to 4.            */
/*      2. nr is a multiple of 4 and greater than or equal to 4.            */
/*      3. nx is greater than or equal to nr                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,k;                                                        */
/*          double sum;                                                     */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0;                                                    */
/*              for (k = nr; k < nx+nr; k++)                                */
/*                  sum += x[k] * x[k-i];                                   */
/*              r[i] = sum ;                                                */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*      interruptible.                                                      */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      2*nx*nr + 5/2*nr + 32                                               */
/*      For nx=32 and nr=64, cycles=4258                                    */
/*      For nx=24 and nr=32, cycles=1648                                    */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      576 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_AUTOCOR_H_
#define DSPF_DP_AUTOCOR_H_ 1

void DSPF_dp_autocor
(
    double    *  restrict r,
    double    *  restrict x,
    int       nx,
    int       nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_autocor.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_autocor/1117057373  2470  0     0       8264      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_autocor -- double Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*                                                                           *
*       r  = Pointer to output array of autocorrelation of length nr        *
*       x  = Pointer to input array of length nx+nr. Input data must        *
*            be padded with nr consecutive zeros at the beginning.          *
*       nx = Length of autocorrelation vector.                              *
*       nr = Length of lags.                                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the autocorrelation of the input array x.     *
*       is assumed that the length of the input array, x, is a              *
*       multiple of 2 and the length of the output array, r, is a           *
*       multiple of 4. The assembly routine computes 4 output samples       *
*       at a time. It is assumed that input vector x is padded with nr      *
*       no of zeros in the beginning.                                       *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice and the outer loop is unrolled  *
*       four times.                                                         *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 2 and greater than or equal to 4.            *
*       2. nr is a multiple of 4 and greater than or equal to 4.            *
*       3. nx is greater than or equal to nr                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i,k;                                                        *
*           double sum;                                                     *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (k = nr; k < nx+nr; k++)                                *
*                   sum += x[k] * x[k-i];                                   *
*               r[i] = sum ;                                                *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*       interruptible.                                                      *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       2*nx*nr + 5/2*nr + 32                                               *
*       For nx=32 and nr=64, cycles=4258                                    *
*       For nx=24 and nr=32, cycles=1648                                    *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       576 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_autocor

*  ======================================================================== *
*   End of file:  DSPF_dp_autocor.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_bitrev_/1117057374  2491  0     0       15918     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         */
/*     numbers                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                */
/*                                                                          */
/*     x      : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx doubles                                       */
/*     index  : Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is a double array of length 2*nx containing Double         */
/*     precision floating point complex pairs of data. This routine         */
/*     requires the index array provided by the program below.              */
/*     This index should be generated at compile time not by the DSP.       */
/*                                                                          */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*     1. nx must be a power of 2.                                          */
/*     2. The table from bitrev_index is already created.                   */
/*     3. The array x is actually an array of 2*nx doubles.                 */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                */
/*      {                                                                   */
/*         int    i;                                                        */
/*         short  i0, i1, i2;                                               */
/*         short  j0, j1, j2;                                               */
/*         double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       */
/*         double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       */
/*         short  t;                                                        */
/*         int    a, b, ia, ib, ibs;                                        */
/*         int    mask;                                                     */
/*         int    nbits, nbot, ntop, ndiff, n2, halfn;                      */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*            i = i >> 1;                                                   */
/*            nbits++;                                                      */
/*         }                                                                */
/*                                                                          */
/*         nbot    = nbits >> 1;                                            */
/*         ndiff   = nbits & 1;                                             */
/*         ntop    = nbot + ndiff;                                          */
/*         n2       = 1 << ntop;                                            */
/*         mask    = n2 - 1;                                                */
/*         halfn   = nx >> 1;                                               */
/*                                                                          */
/*         for (i0 = 0; i0 < halfn; i0 += 2)                                */
/*         {                                                                */
/*             b       = i0 & mask;                                         */
/*             a       = i0 >> nbot;                                        */
/*             if (!b) ia = index[a];                                       */
/*             ib      = index[b];                                          */
/*             ibs     = ib << nbot;                                        */
/*                                                                          */
/*             j0      = ibs + ia;                                          */
/*             t       = i0 < j0;                                           */
/*             xi0r     = x[2*i0];                                          */
/*             xi0i     = x[2*i0+1];                                        */
/*             xj0r     = x[2*j0];                                          */
/*             xj0i     = x[2*j0+1];                                           */
/*             if (t)                                                       */
/*             {                                                            */
/*                x[2*i0]   = xj0r;                                         */
/*                x[2*i0+1] = xj0i;                                         */
/*                x[2*j0]   = xi0r;                                         */
/*                x[2*j0+1] = xi0i;                                         */
/*              }                                                           */
/*                                                                          */
/*             i1      = i0 + 1;                                            */
/*             j1      = j0 + halfn;                                        */
/*             xi1r    = x[2*i1];                                           */
/*             xi1i    = x[2*i1+1];                                         */
/*             xj1r    = x[2*j1];                                           */
/*             xj1i    = x[2*j1+1];                                         */
/*                                                                          */
/*             x[2*i1]   = xj1r;                                            */
/*             x[2*i1+1] = xj1i;                                            */
/*             x[2*j1]   = xi1r;                                            */
/*             x[2*j1+1] = xi1i;                                            */
/*                                                                          */
/*             i2      = i1 + halfn;                                        */
/*             j2      = j1 + 1;                                            */
/*                                                                          */
/*             xi2r    = x[2*i2];                                           */
/*             xi2i    = x[2*i2+1];                                         */
/*             xj2r    = x[2*j2];                                           */
/*             xj2i    = x[2*j2+1];                                         */
/*             if (t)                                                       */
/*             {                                                            */
/*             x[2*i2]   = xj2r;                                            */
/*             x[2*i2+1] = xj2i;                                            */
/*             x[2*j2]   = xi2r;                                            */
/*             x[2*j2+1] = xi2i;                                            */
/*             }                                                            */
/*           }                                                              */
/*                                                                          */
/*         }                                                                */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1. The index table can be generated using the bitrev_index           */
/*        function provided in the dsplib\support\fft directory.            */
/*     2. If nx <= 4K one can use the char (8-bit) data type for            */
/*        the "index" variable. This would require changing the LDH when    */
/*        loading index values in the assembly routine to LDB. This would   */
/*        further reduce the size of the Index Table by half its size.      */
/*                                                                          */
/*     3. Endian: LITTLE ENDIAN configuration used.                         */
/*                                                                          */
/*     4. Interruptibility: This code is interrupt tolerant, but not        */
/*        interruptible.                                                    */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     5*nx + 33                                                            */
/*     e.g. nx = 128, cycles = 673                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     736 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BITREV_CPLX_H_
#define DSPF_DP_BITREV_CPLX_H_ 1

void DSPF_dp_bitrev_cplx(double     *x, short *index, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_bitrev_cplx.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_bitrev_/1117057374  2514  0     0       15933     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx doubles                                       *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is a double array of length 2*nx containing Double         *
*      precision floating point complex pairs of data. This routine         *
*      requires the index array provided by the program below.              *
*      This index should be generated at compile time not by the DSP.       *
*                                                                           *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. nx must be a power of 2.                                          *
*      2. The table from bitrev_index is already created.                   *
*      3. The array x is actually an array of 2*nx doubles.                 *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2;                                               *
*          short  j0, j1, j2;                                               *
*          double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       *
*          double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = nx >> 1;                                               *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0r     = x[2*i0];                                          *
*              xi0i     = x[2*i0+1];                                        *
*              xj0r     = x[2*j0];                                          *
*              xj0i     = x[2*j0+1];                                           *
*              if (t)                                                       *
*              {                                                            *
*                 x[2*i0]   = xj0r;                                         *
*                 x[2*i0+1] = xj0i;                                         *
*                 x[2*j0]   = xi0r;                                         *
*                 x[2*j0+1] = xi0i;                                         *
*               }                                                           *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1r    = x[2*i1];                                           *
*              xi1i    = x[2*i1+1];                                         *
*              xj1r    = x[2*j1];                                           *
*              xj1i    = x[2*j1+1];                                         *
*                                                                           *
*              x[2*i1]   = xj1r;                                            *
*              x[2*i1+1] = xj1i;                                            *
*              x[2*j1]   = xi1r;                                            *
*              x[2*j1+1] = xi1i;                                            *
*                                                                           *
*              i2      = i1 + halfn;                                        *
*              j2      = j1 + 1;                                            *
*                                                                           *
*              xi2r    = x[2*i2];                                           *
*              xi2i    = x[2*i2+1];                                         *
*              xj2r    = x[2*j2];                                           *
*              xj2i    = x[2*j2+1];                                         *
*              if (t)                                                       *
*              {                                                            *
*              x[2*i2]   = xj2r;                                            *
*              x[2*i2+1] = xj2i;                                            *
*              x[2*j2]   = xi2r;                                            *
*              x[2*j2+1] = xi2i;                                            *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1. The index table can be generated using the bitrev_index           *
*         function provided in the dsplib\support\fft directory.            *
*      2. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      3. Endian: LITTLE ENDIAN configuration used.                         *
*                                                                           *
*      4. Interruptibility: This code is interrupt tolerant, but not        *
*         interruptible.                                                    *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      5*nx + 33                                                            *
*      e.g. nx = 128, cycles = 673                                          *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      736 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_bitrev_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_bitrev_cplx.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr4_/1117057375  2539  0     0       14391     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      */
/*     Frequency radix-4 FFT with complex input                            */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*                                                                          */
/*  x : Pointer to an array holding the input and output floating           */
/*      point array which contains 'n' complex points                       */
/*  w : Pointer to an array holding the coefficient floating point          */
/*      array which contains 3*n/4 complex numbers                          */
/*  n : Number of complex points in x                                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)               */
/*  complex radix 4 FFT with digit-reversed output and normal               */
/*  order input.  The number of points, 'n', must be a power                */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   */
/*  in-place routine in the sense that the output is written                */
/*  over the input.  It is not an in-place routine in the                   */
/*  sense that the input is in normal order and the output is               */
/*  in digit-reversed order.                                                */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex          */
/*  coefficients (3*n/2 values).                                            */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the               */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             */
/*  are in normal order.  Each real and imaginary output value              */
/*  is interleaved in the 'x' array and the complex numbers are             */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and                 */
/*  imaginary values of the coefficients are interleaved in the             */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           */
/*  are in normal order.                                                    */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                        */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written               */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                  */
/*  performing the complex conjugate on the input complex numbers           */
/*  (negating the imaginary value), and dividing the result by n.           */
/*  Another method to use the FFT to perform an inverse FFT, is to          */
/*  swap the real and imaginary values of the input and the result,         */
/*  and divide the result by n.  In either case, the input is still         */
/*  in normal order and the output is still in digit-reversed order.        */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse              */
/*  FFT by using the complex conjugate of the coefficients as               */
/*  you can do with the complex radix 2 FFT.                                */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),        */
/*  the digit-reversed locations can be calculated by reversing the         */
/*  order of the bit pairs of the labels.  For example, for a 1024          */
/*  point FFT, the digit reversed location for                              */
/*  617d = 1001101001b = 10 01 10 10 01  is                                 */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*  1.  All the three loops are executed as one loop with                   */
/*      conditional instructions.                                           */
/*  2.  The outer loop counter is used as load counterto prevent            */
/*      extraneous loads.                                                   */
/*  3.  If more registers were available, the inner loop could              */
/*      probably be as small as 28 cycles,but the loop was extended         */
/*      to 56 cycles to allow more variables to share registers.            */
/*  4.  The pointer for X and W are maintianed  on both register sides      */
/*      to avoid crosspath Conflicts.                                       */
/*  5.  Variable tctr is used as innerloop Counter.                          */
/*  6.  The variable, K, is used as the outer loop counter.We are           */
/*      finished when n2b = 0.                                              */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*  1.  There are no special alignment requirements.                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent for the assembly code.  Note that              */
/*  the assembly code is hand optimized and restrictions may                */
/*  apply.                                                                  */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*  {                                                                       */
/*      short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              */
/*      double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               */
/*      double si1, si2, si3;                                               */
/*      n2 = n;                                                             */
/*      ie = 1;                                                             */
/*      for(k=n; k>1; k>>=2)                                                */
/*      {                                                                   */
/*         n1 = n2;                                                         */
/*         n2 >>= 2;                                                        */
/*         ia1 = 0;                                                         */
/*         for(j=0; j<n2; j++)                                              */
/*         {                                                                */
/*             ia2 = ia1 + ia1;                                             */
/*             ia3 = ia1 + ia2;                                             */
/*             co1 = w[ia1*2];                                              */
/*             si1 = w[ia1*2 + 1];                                          */
/*             co2 = w[ia2*2];                                              */
/*             si2 = w[ia2*2 + 1];                                          */
/*             co3 = w[ia3*2];                                              */
/*             si3 = w[ia3*2 + 1];                                          */
/*             ia1 += ie;                                                   */
/*             for(i0=j; i0<n; i0+=n1)                                      */
/*             {                                                            */
/*                 i1 = i0 + n2;                                            */
/*                 i2 = i1 + n2;                                            */
/*                 i3 = i2 + n2;                                            */
/*                 r1 = x[i0*2]   + x[i2*2];                                */
/*                 r3 = x[i0*2]   - x[i2*2];                                */
/*                 s1 = x[i0*2+1] + x[i2*2+1];                              */
/*                 s3 = x[i0*2+1] - x[i2*2+1];                              */
/*                 r2 = x[i1*2]   + x[i3*2];                                */
/*                 r4 = x[i1*2]   - x[i3*2];                                */
/*                 s2 = x[i1*2+1] + x[i3*2+1];                              */
/*                 s4 = x[i1*2+1] - x[i3*2+1];                              */
/*                 x[i0*2]   = r1 + r2;                                     */
/*                 r2        = r1 - r2;                                     */
/*                 r1        = r3 - s4;                                     */
/*                 r3        = r3 + s4;                                     */
/*                 x[i0*2+1] = s1 + s2;                                     */
/*                 s2        = s1 - s2;                                     */
/*                 s1        = s3 + r4;                                     */
/*                 s3        = s3 - r4;                                     */
/*                 x[i1*2]   = co1*r3 + si1*s3;                             */
/*                 x[i1*2+1] = co1*s3 - si1*r3;                             */
/*                 x[i2*2]   = co2*r2 + si2*s2;                             */
/*                 x[i2*2+1] = co2*s2 - si2*r2;                             */
/*                 x[i3*2]   = co3*r1 + si3*s1;                             */
/*                 x[i3*2+1] = co3*s1 - si3*r1;                             */
/*            }                                                             */
/*         }                                                                */
/*         ie <<= 2;                                                        */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. The twiddle factor array w can be generated by the tw_r4fft       */
/*        function provided in dsplib\support\fft\tw_r4fft.c. The exe       */
/*        file for this function, dsplib\bin\tw_r4fft.exe, can be           */
/*        used dump the twiddle factor array into a file.                   */
/*     2. The function bit_rev in dsplib\support\fft can be used to         */
/*        bit-reverse the output array to convert it into normal order.     */
/*     3. Endian: This code is LITTLE  ENDIAN.                              */
/*     4. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    14*n*log4(n) + 46                                                     */
/*    eg. if n = 256, cycles = 14382.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1344 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR4_DIF_H_
#define DSPF_DP_CFFTR4_DIF_H_ 1

void DSPF_dp_cfftr4_dif(double*     x, double* w, short n);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr4_dif.h                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr4_/1117057375  2561  0     0       14429     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      *
*      Frequency radix-4 FFT with complex input                            *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*   This routine is C Callable and can be called as:                        *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*                                                                           *
*   x : Pointer to an array holding the input and output floating           *
*       point array which contains 'n' complex points                       *
*   w : Pointer to an array holding the coefficient floating point          *
*       array which contains 3*n/4 complex numbers                          *
*   n : Number of complex points in x                                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*   This routine implements the DIF (decimation in frequency)               *
*   complex radix 4 FFT with digit-reversed output and normal               *
*   order input.  The number of points, 'n', must be a power                *
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   *
*   in-place routine in the sense that the output is written                *
*   over the input.  It is not an in-place routine in the                   *
*   sense that the input is in normal order and the output is               *
*   in digit-reversed order.                                                *
*                                                                           *
*   There must be n complex points (2*n values), and 3*n/4 complex          *
*   coefficients (3*n/2 values).                                            *
*                                                                           *
*   Each real and imaginary input value is interleaved in the               *
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             *
*   are in normal order.  Each real and imaginary output value              *
*   is interleaved in the 'x' array and the complex numbers are             *
*   in digit-reversed  order {rx0, ix0, ...}.  The real and                 *
*   imaginary values of the coefficients are interleaved in the             *
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           *
*   are in normal order.                                                    *
*                                                                           *
*   Note that the imaginary coefficients are negated                        *
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           *
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       *
*   where d = 2*PI/n.  The value of w(n,k) is usually written               *
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                *
*                                                                           *
*   The routine can be used to implement an inverse FFT by                  *
*   performing the complex conjugate on the input complex numbers           *
*   (negating the imaginary value), and dividing the result by n.           *
*   Another method to use the FFT to perform an inverse FFT, is to          *
*   swap the real and imaginary values of the input and the result,         *
*   and divide the result by n.  In either case, the input is still         *
*   in normal order and the output is still in digit-reversed order.        *
*                                                                           *
*   Note that you can not make the radix 4 FFT into an inverse              *
*   FFT by using the complex conjugate of the coefficients as               *
*   you can do with the complex radix 2 FFT.                                *
*                                                                           *
*   If you label the input locations from 0 to (n-1) (normal order),        *
*   the digit-reversed locations can be calculated by reversing the         *
*   order of the bit pairs of the labels.  For example, for a 1024          *
*   point FFT, the digit reversed location for                              *
*   617d = 1001101001b = 10 01 10 10 01  is                                 *
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*   1.  All the three loops are executed as one loop with                   *
*       conditional instructions.                                           *
*   2.  The outer loop counter is used as load counterto prevent            *
*       extraneous loads.                                                   *
*   3.  If more registers were available, the inner loop could              *
*       probably be as small as 28 cycles,but the loop was extended         *
*       to 56 cycles to allow more variables to share registers.            *
*   4.  The pointer for X and W are maintianed  on both register sides      *
*       to avoid crosspath Conflicts.                                       *
*   5.  Variable tctr is used as innerloop Counter.                          *
*   6.  The variable, K, is used as the outer loop counter.We are           *
*       finished when n2b = 0.                                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   1.  There are no special alignment requirements.                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent for the assembly code.  Note that              *
*   the assembly code is hand optimized and restrictions may                *
*   apply.                                                                  *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*   {                                                                       *
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              *
*       double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               *
*       double si1, si2, si3;                                               *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for(k=n; k>1; k>>=2)                                                *
*       {                                                                   *
*          n1 = n2;                                                         *
*          n2 >>= 2;                                                        *
*          ia1 = 0;                                                         *
*          for(j=0; j<n2; j++)                                              *
*          {                                                                *
*              ia2 = ia1 + ia1;                                             *
*              ia3 = ia1 + ia2;                                             *
*              co1 = w[ia1*2];                                              *
*              si1 = w[ia1*2 + 1];                                          *
*              co2 = w[ia2*2];                                              *
*              si2 = w[ia2*2 + 1];                                          *
*              co3 = w[ia3*2];                                              *
*              si3 = w[ia3*2 + 1];                                          *
*              ia1 += ie;                                                   *
*              for(i0=j; i0<n; i0+=n1)                                      *
*              {                                                            *
*                  i1 = i0 + n2;                                            *
*                  i2 = i1 + n2;                                            *
*                  i3 = i2 + n2;                                            *
*                  r1 = x[i0*2]   + x[i2*2];                                *
*                  r3 = x[i0*2]   - x[i2*2];                                *
*                  s1 = x[i0*2+1] + x[i2*2+1];                              *
*                  s3 = x[i0*2+1] - x[i2*2+1];                              *
*                  r2 = x[i1*2]   + x[i3*2];                                *
*                  r4 = x[i1*2]   - x[i3*2];                                *
*                  s2 = x[i1*2+1] + x[i3*2+1];                              *
*                  s4 = x[i1*2+1] - x[i3*2+1];                              *
*                  x[i0*2]   = r1 + r2;                                     *
*                  r2        = r1 - r2;                                     *
*                  r1        = r3 - s4;                                     *
*                  r3        = r3 + s4;                                     *
*                  x[i0*2+1] = s1 + s2;                                     *
*                  s2        = s1 - s2;                                     *
*                  s1        = s3 + r4;                                     *
*                  s3        = s3 - r4;                                     *
*                  x[i1*2]   = co1*r3 + si1*s3;                             *
*                  x[i1*2+1] = co1*s3 - si1*r3;                             *
*                  x[i2*2]   = co2*r2 + si2*s2;                             *
*                  x[i2*2+1] = co2*s2 - si2*r2;                             *
*                  x[i3*2]   = co3*r1 + si3*s1;                             *
*                  x[i3*2+1] = co3*s1 - si3*r1;                             *
*             }                                                             *
*          }                                                                *
*          ie <<= 2;                                                        *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. The twiddle factor array w can be generated by the tw_r4fft       *
*         function provided in dsplib\support\fft\tw_r4fft.c. The exe       *
*         file for this function, dsplib\bin\tw_r4fft.exe, can be           *
*         used dump the twiddle factor array into a file.                   *
*      2. The function bit_rev in dsplib\support\fft can be used to         *
*         bit-reverse the output array to convert it into normal order.     *
*      3. Endian: This code is LITTLE  ENDIAN.                              *
*      4. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     14*n*log4(n) + 46                                                     *
*     eg. if n = 256, cycles = 14382.                                       *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr4_dif

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr4_dif.h67                                         *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr2./1117057376  2585  0     0       19475     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    */
/*     with complex input                                                  */
/*                                                                         */
/* USAGE                                                                    */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      This routine is used to compute the Complex, Radix-2, Fast          */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)           // Bit reverse the output if              */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*      }                                                                   */
/*                                                                          */
/*      main fft of size N can be divided into several steps (where         */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_cfftr2(N, x, w, 1);                                              */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_cfftr2(N, x, w, N/4);                                            */
/*                                                                          */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire data set.   */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array, in the    */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   - s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   + s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          //  table of size n complex numbers (or 2*n numbers)            */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR2_H_
#define DSPF_DP_CFFTR2_H_ 1

void DSPF_dp_cfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr2./1117057376  2603  0     0       19447     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    *
*      with complex input                                                  *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Feb-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*         This routine is C-callable and can be called as:                  *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*                                                                           *
*         x : input and output sequences (dim-n)      (input/output)        *
*             x has n complex numbers (2*n DP values).                      *
*             The real and imaginary values are interleaved in memory.      *
*             The input is in normal order and output is in bit-reversed    *
*             Order.                                                        *
*         w : FFT coefficients (dim-n)                (input)               *
*             w has n complex numbers (n DP values).                        *
*             FFT coeficients are in a special sequence so that FFT can     *
*             be called on smaller input sets multiple times to avoid       *
*             cache thrashing.                                              *
*             The real and imaginary values are interleaved in memory.      *
*         n : FFT size which is a power of 2 and > 4  (input)               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       This routine is used to compute the Complex, Radix-2, Fast          *
*       Fourier Transform of a double precision complex sequence of size    *
*       n, and a power of 2 in a Cache-friendly way. The routine requires   *
*       normal order input and normal order coefficents (twiddle factors)   *
*       in a special sequence and produces results that are in              *
*       bit-reversed order.                                                 *
*                                                                           *
*       The input can be broken into smaller parts and called multiple      *
*       times to avoid cache thrashing.                                     *
*                                                                           *
*       How to use                                                          *
*                                                                           *
*       void main(void)                                                     *
*       {                                                                   *
*          gen_w_r2(w, N);         // Generate coefficient table            *
*                                  // in normal order                       *
*                                  // Function is given in C-CODE section   *
*                                                                           *
*         DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      *
*                                  // order bit-reversed                    *
*                                                                           *
*         bit_rev(x, N)           // Bit reverse the output if              *
*                                  // normal order output is needed         *
*                                  // Function is given in C-CODE section   *
*       }                                                                   *
*                                                                           *
*       main fft of size N can be divided into several steps (where         *
*       number of steps is a power of 2), allowing as much data             *
*       reuse as possible.                                                  *
*                                                                           *
*       For example the following function                                  *
*       DSPF_dp_cfftr2(N, x, w, 1);                                              *
*                                                                           *
*       is equivalent to:                                                   *
*                                                                           *
*       DSPF_dp_cfftr2(N, x, w, N/4);                                            *
*                                                                           *
*       DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  *
*                                                                           *
*       Notice how the 1st fft function is called on the entire data set.   *
*       It covers the 1st pass of the fft until the butterfly size is       *
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original    *
*       size. These continue down to the end when the buttly is of size     *
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array    *
*       for the last 4 calls. This is because the twiddle factor array      *
*       is composed of successively decimated versions of the main array.   *
*                                                                           *
*       The twiddle factor array is composed of log2(N) sets of twiddle     *
*       factors of size N, N/2, N/4, N/8 etc. The index into this array     *
*       for each stage of the fft can be calculated by summing these        *
*       indices up appropriately. For example, if we are dividing the       *
*       input into 2 parts then index into this array should be N, if we    *
*       are dividing into 4 parts then index into this array should be      *
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array, in the    *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       The functions for creating this special sequence of twiddle         *
*       factors and bit-reversal are provided in the C CODE section.        *
*                                                                           *
*       In general if divide the input into NO_OF_DIV parts we can call     *
*       the function as follows:                                            *
*                                                                           *
*       // Divide the input into NO_OF_DIV parts                            *
*       DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    *
*                                                                           *
*                                                                           *
*       // Find out the index into twiddle factor array                     *
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       *
*       {                                                                   *
*          w_index += j;                                                    *
*       }                                                                   *
*       w_index = N * w_index / NO_OF_DIV;                                  *
*                                                                           *
*       // Call the Function a subset of inputs                             *
*       for(i=0; i<NO_OF_DIV; i++)                                          *
*       {                                                                   *
*          DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   *
*       }                                                                   *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*       1. Outer loop instructions are executed in parallel with the        *
*          inner loop epilog.                                               *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. Both input x and coefficient w should be aligned on double       *
*          word boundary.                                                   *
*       2. n should be greater than 4 and a power of 2.                     *
*                                                                           *
*  C CODE                                                                   *
*         This is the C equivalent of the assembly code without             *
*         restrictions. Note that the assembly code is hand optimized       *
*         and restrictions may apply.                                       *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*         {                                                                 *
*              int n2, ie, ia, i, j, k, m;                                  *
*              double rtemp, itemp, c, s;                                   *
*                                                                           *
*              n2 = n;                                                      *
*              ie = 1;                                                      *
*                                                                           *
*              for(k = n; k > n_min; k >>= 1)                               *
*               {                                                           *
*                 n2 >>= 1;                                                 *
*                 ia = 0;                                                   *
*                 for(j=0; j < ie; j++)                                     *
*                 {                                                         *
*                  for(i=0; i < n2; i++)                                    *
*                    {                                                      *
*                       c = w[2*i];                                         *
*                       s = w[2*i+1];                                       *
*                       m = ia + n2;                                        *
*                       rtemp     = x[2*ia]   - x[2*m];                     *
*                       x[2*ia]   = x[2*ia]   + x[2*m];                     *
*                       itemp     = x[2*ia+1] - x[2*m+1];                   *
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   *
*                       x[2*m]    = c*rtemp   - s*itemp;                    *
*                       x[2*m+1]  = c*itemp   + s*rtemp;                    *
*                       ia++;                                               *
*                      }                                                    *
*                   ia += n2;                                               *
*                  }                                                        *
*                 ie <<= 1;                                                 *
*                 w = w + k;                                                *
*              }                                                            *
*          }                                                                *
*                                                                           *
*          The follwoing C code is used to generate the coefficient table.  *
*                                                                           *
*           #include <math.h>                                               *
*           // generate real and imaginary twiddle                          *
*           //  table of size n complex numbers (or 2*n numbers)            *
*                                                                           *
*           void gen_w_r2(double* w, int n)                                 *
*           {                                                               *
*                int i, j=1;                                                *
*                double pi = 4.0*atan(1.0);                                 *
*                double e = pi*2.0/n;                                       *
*                for(j=1; j < n; j <<= 1)                                   *
*                {                                                          *
*                for(i=0; i < ( n>>1 ); i += j)                             *
*                   {                                                       *
*                   *w++   = cos(i*e);                                      *
*                   *w++   = -sin(i*e);                                     *
*                   }                                                       *
*                }                                                          *
*           }                                                               *
*                                                                           *
*                                                                           *
*           The follwoing C code is used to bit-reverse the output.         *
*                                                                           *
*           bit_rev(double* x, int n)                                       *
*           {                                                               *
*             int i, j, k;                                                  *
*             double rtemp, itemp;                                          *
*                                                                           *
*             j = 0;                                                        *
*             for(i=1; i < (n-1); i++)                                      *
*             {                                                             *
*               k = n >> 1;                                                 *
*                while(k <= j)                                              *
*                {                                                          *
*                   j -= k;                                                 *
*                   k >>= 1;                                                *
*                }                                                          *
*                j += k;                                                    *
*                if(i < j)                                                  *
*                {                                                          *
*                   rtemp    = x[j*2];                                      *
*                   x[j*2]   = x[i*2];                                      *
*                   x[i*2]   = rtemp;                                       *
*                   itemp    = x[j*2+1];                                    *
*                   x[j*2+1] = x[i*2+1];                                    *
*                   x[i*2+1] = itemp;                                       *
*                }                                                          *
*             }                                                             *
*           }                                                               *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. The special sequence of twiddle factor array w can be generated  *
*         using the gen_w_r2 function provided in the previous section.     *
*                                                                           *
*       2. Endian:This code is LITTLE ENDIAN.                               *
*                                                                           *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        4 * n * lg(n) + 16 * lg(n) + 34                                    *
*        eg. IF n = 64,  cycles = 1666                                      *
*        eg. IF n = 32,  cycles = 754                                       *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        1408 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr2

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_icfftr2/1117057378  2623  0     0       21572     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      */
/*      FFT with complex input                                              */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine is used to compute the Inverse Complex, Radix-2, Fast  */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)            // Bit reverse the output if             */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        divide(x, N);            // scale inverse FFT output              */
/*                                 // result is the same as original        */
/*                                 // input                                 */
/*                                                                          */
/*     }                                                                    */
/*                                                                          */
/*      main Inverse fft of size N can be divided into several steps (where */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_icfftr2(N, x, w, 1);                                             */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_icfftr2(N, x, w, N/4);                                           */
/*                                                                          */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                 */
/*                                                                          */
/*      Notice how the 1st icfft function is called on the entire data set. */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array, in the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                   */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);  */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   + s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   - s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          // table of size n complex numbers (or 2*n numbers)             */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT:                                                        */
/*                                                                          */
/*      // divide each element of x by n                                    */
/*                                                                          */
/*      divide(double* x, int n)                                            */
/*      {                                                                   */
/*        int i;                                                            */
/*        double inv = 1.0 / n;                                             */
/*                                                                          */
/*         for(i=0; i < n; i++)                                             */
/*          {                                                               */
/*              x[2*i] = inv * x[2*i];                                      */
/*              x[2*i+1] = inv * x[2*i+1];                                  */
/*            }                                                             */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_ICFFTR2_ASM_H_
#define DSPF_DP_ICFFTR2_ASM_H_ 1

void DSPF_dp_icfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_icfftr2_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2004 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_icfftr2/1117057377  2642  0     0       1762      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      *
*      FFT with complex input                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_icfftr2

* ======================================================================== *
*  End of file: DSPF_dp_icfftr2_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_cpl/1117057379  2663  0     0       8398      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_cplx(                                                  */
/*                        const double * restrict x,                        */
/*                        const double * restrict h,                        */
/*                        double *       restrict r,                        */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*                                                                          */
/*            x[2*(nr+nh-1)]: Pointer to complex input array.               */
/*                            The input data pointer x must point to the    */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]       : Pointer to complex coefficient array          */
/*                            (in normal order).                            */
/*            r[2*nr]       : Pointer to complex output array.              */
/*            nh            : Number of complex coefficients in vector h.   */
/*            nr            : Number of complex output samples to           */
/*                           calculate.                                     */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*                                                                          */
/*     TECHNIQUES                                                           */
/*                                                                          */
/*    1. The outer loop is unrolled twice.                                  */
/*    2. Outer loop instructions are executed in parallel with inner loop.  */
/*    3. Register Sharing is used to make optimal use of available register *
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. nr is a multiple of 2 and greater than or equal to 2.              */
/*    2. nh is greater than or equal to 4.                                  */
/*    3. x points to 2*(nh-1)th input element.                              */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_cplx(const double * x, const double * h,                    */
/*                   double * restrict r, int nh, int nr)                   */
/*  {                                                                       */
/*       int i,j;                                                           */
/*       double imag, real;                                                 */
/*       for (i = 0; i < 2*nr; i += 2)                                      */
/*       {                                                                  */
/*           imag = 0;                                                      */
/*           real = 0;                                                      */
/*           for (j = 0; j < 2*nh; j += 2)                                  */
/*           {                                                              */
/*               real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 */
/*               imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 */
/*           }                                                              */
/*           r[i] = real;                                                   */
/*           r[i+1] = imag;                                                 */
/*       }                                                                  */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*  8*nh*nr + 5*nr + 30                                                     */
/*  For nh=24 and nr=48, cycles=9486                                        */
/*  For nh=16 and nr=36, cycles=4818                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  608 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_CPLX_H_
#define DSPF_DP_FIR_CPLX_H_ 1

void DSPF_dp_fir_cplx(
                 const double * restrict x,
                 const double * restrict h,
                 double *       restrict r,
                 int   nh,
                 int   nr
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_cplx.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_fir_cpl/1117057378  2683  0     0       8343      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_cplx(                                                  *
*                         const double * restrict x,                        *
*                         const double * restrict h,                        *
*                         double *       restrict r,                        *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*                                                                           *
*             x[2*(nr+nh-1)]: Pointer to complex input array.               *
*                             The input data pointer x must point to the    *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]       : Pointer to complex coefficient array          *
*                             (in normal order).                            *
*             r[2*nr]       : Pointer to complex output array.              *
*             nh            : Number of complex coefficients in vector h.   *
*             nr            : Number of complex output samples to           *
*                            calculate.                                     *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
*                                                                           *
*      TECHNIQUES                                                           *
*                                                                           *
*     1. The outer loop is unrolled twice.                                  *
*     2. Outer loop instructions are executed in parallel with inner loop.  *
*     3. Register Sharing is used to make optimal use of available register *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. nr is a multiple of 2 and greater than or equal to 2.              *
*     2. nh is greater than or equal to 4.                                  *
*     3. x points to 2*(nh-1)th input element.                              *
*                                                                           *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_cplx(const double * x, const double * h,                    *
*                    double * restrict r, int nh, int nr)                   *
*   {                                                                       *
*        int i,j;                                                           *
*        double imag, real;                                                 *
*        for (i = 0; i < 2*nr; i += 2)                                      *
*        {                                                                  *
*            imag = 0;                                                      *
*            real = 0;                                                      *
*            for (j = 0; j < 2*nh; j += 2)                                  *
*            {                                                              *
*                real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 *
*                imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 *
*            }                                                              *
*            r[i] = real;                                                   *
*            r[i+1] = imag;                                                 *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*   8*nh*nr + 5*nr + 30                                                     *
*   For nh=24 and nr=48, cycles=9486                                        *
*   For nh=16 and nr=36, cycles=4818                                        *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   608 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_cplx.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_gen/1117057379  2705  0     0       8125      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                              double * restrict r,int nh, int nr);        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       r : Pointer to output array                                        */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*       1.  The outer loop is unrolled 4 times.                            */
/*       2.  The inner loop is unrolled 2 times and software pipelined.     */
/*       3.  Register sharing is used to make optimum utilisation of        */
/*           available registers                                            */
/*       4.  Outerlop instructions and Prolog for next stage are scheduled  */
/*           in parallel with last iteration of kernel                      */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*       1.  Little Endian is assumed for LDDW instructions.                */
/*       2.  The number of coefficients must be greater than                */
/*           or equal to 4.                                                 */
/*       3.  The number of outputs must be greater than or equal to 4       */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*       This is the C equivalent for the assembly code.  Note that         */
/*       the assembly code is hand optimized and restrictions may           */
/*       apply.                                                             */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                   double * restrict r, int nh, int nr)                   */
/*       {                                                                  */
/*          int i, j;                                                       */
/*          double sum;                                                     */
/*                                                                          */
/*          for(i=0; i < nr; i++)                                           */
/*          {                                                               */
/*             sum = 0;                                                     */
/*             for(j=0; j < nh; j++)                                        */
/*             {                                                            */
/*                 sum += x[i+j] * h[j];                                    */
/*             }                                                            */
/*             r[i] = sum;                                                  */
/*          }                                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/*   NOTES                                                                  */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*   CYCLES                                                                 */
/*                                                                          */
/*   (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              */
/*    for nh=26, nr=42, cycles=2430 cycles.                                 */
/*                                                                          */
/*   CODESIZE                                                               */
/*                                                                          */
/*    672 bytes                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_GEN_H_
#define DSPF_DP_FIR_GEN_H_ 1

void DSPF_dp_fir_gen(const     double *x, const double *h,
                       double * restrict r,int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_gen.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_gen/1117057379  2724  0     0       8185      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                               double * restrict r,int nh, int nr);        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        r : Pointer to output array                                        *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*        1.  The outer loop is unrolled 4 times.                            *
*        2.  The inner loop is unrolled 2 times and software pipelined.     *
*        3.  Register sharing is used to make optimum utilisation of        *
*            available registers                                            *
*        4.  Outerlop instructions and Prolog for next stage are scheduled  *
*            in parallel with last iteration of kernel                      *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*        1.  Little Endian is assumed for LDDW instructions.                *
*        2.  The number of coefficients must be greater than                *
*            or equal to 4.                                                 *
*        3.  The number of outputs must be greater than or equal to 4       *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                    double * restrict r, int nh, int nr)                   *
*        {                                                                  *
*           int i, j;                                                       *
*           double sum;                                                     *
*                                                                           *
*           for(i=0; i < nr; i++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(j=0; j < nh; j++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[j];                                    *
*              }                                                            *
*              r[i] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*    NOTES                                                                  *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*    CYCLES                                                                 *
*                                                                           *
*    (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              *
*     for nh=26, nr=42, cycles=2430 cycles.                                 *
*                                                                           *
*    CODESIZE                                                               *
*                                                                           *
*     672 bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_gen

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_gen.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_r2./1117057380  2745  0     0       7895      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_r2(                                                    */
/*                     const double * restrict x,                           */
/*                     const double * restrict h,                           */
/*                     double      * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]     : Pointer to coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]     : Pointer to output array of size nr.               */
/*            nh        : Number of coefficients                            */
/*            nr        : Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       1. The outer loop is unrolled four times and inner loop is         */
/*          unrolled twice.                                                 */
/*       2. Register sharing is used to make optimum utilisation of         */
/*          available Registers                                             */
/*       3. Outer loop instructions are executed in parallel with           */
/*          inner loop.                                                     */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is a multiple of 2 and greater than or equal to 8.           */
/*       3. Coefficients in array h are expected to be in reverse order.    */
/*       4. x and h should be padded with 4 words at the end.               */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_r2(const double * x, const double * h,                      */
/*                     double *restrict r, int nh, int nr)                  */
/*  {                                                                       */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*          sum = 0;                                                        */
/*                                                                          */
/*          for (j = 0; j < nh; j++)                                        */
/*             sum += x[i + j] * h[j];                                      */
/*             r[i] = sum;                                                  */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*   (8*nh + 10)*ceil(nr/4) + 32                                            */
/*    For nh=24 and nr=62, cycles=3264                                      */
/*                                                                          */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  672 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_R2_H_
#define DSPF_DP_FIR_R2_H_ 1

void DSPF_dp_fir_r2(
              const double * restrict x,
              const double * restrict h,
              double      * restrict r,
              int   nh,
              int   nr
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_r2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_r2./1117057380  2763  0     0       7867      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_r2(                                                    *
*                      const double * restrict x,                           *
*                      const double * restrict h,                           *
*                      double      * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]     : Pointer to coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]     : Pointer to output array of size nr.               *
*             nh        : Number of coefficients                            *
*             nr        : Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*        1. The outer loop is unrolled four times and inner loop is         *
*           unrolled twice.                                                 *
*        2. Register sharing is used to make optimum utilisation of         *
*           available Registers                                             *
*        3. Outer loop instructions are executed in parallel with           *
*           inner loop.                                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*        1. nr is a multiple of 2 and greater than or equal to 2.           *
*        2. nh is a multiple of 2 and greater than or equal to 8.           *
*        3. Coefficients in array h are expected to be in reverse order.    *
*        4. x and h should be padded with 4 words at the end.               *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_r2(const double * x, const double * h,                      *
*                      double *restrict r, int nh, int nr)                  *
*   {                                                                       *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*           sum = 0;                                                        *
*                                                                           *
*           for (j = 0; j < nh; j++)                                        *
*              sum += x[i + j] * h[j];                                      *
*              r[i] = sum;                                                  *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*    (8*nh + 10)*ceil(nr/4) + 32                                            *
*     For nh=24 and nr=62, cycles=3264                                      *
*                                                                           *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   672 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_r2

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_r2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fircirc/1117057381  2783  0     0       9001      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          */
/*                     int csize, int nh, int nr)                           */
/*                                                                          */
/*            x[]     :     Input array (circular buffer of 2^(csize+1)     */
/*                          bytes)                                          */
/*                          Must be aligned at 2^(csize+1) byte boundary    */
/*            h[nh]   :     Filter coefficients array                       */
/*                          Must be double-word aligned                     */
/*            r[nr]   :     Output array                                    */
/*            index   :     Offset by which to start reading from the       */
/*                          input array. Must be multiple of 2              */
/*            csize   :     Size of circular buffer x[] is 2^(csize+1)      */
/*                          bytes. Must be 2 <= csize <= 31.                */
/*            nh      :     Number of filter coefficients                   */
/*                          Must be multiple of 2 and >= 4                  */
/*            nr      :     Size of output array                            */
/*                          Must be multiple of 4                           */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This routine implements a circularly addressed FIR filter.            */
/*    'nh' is the number of filter coefficients. 'nr' is the number         */
/*    of the output samples.                                                */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*    1. The outer loop is unrolled 4 times.                                */
/*    2. The inner loop is unrolled 2 times.                                */
/*    3. Regiter sharing is udes to make optimal utilisation of the         */
/*       available registers.                                               */
/*    4. Outerloop instructions and Prolog for next stage are               */
/*       scheduled in the last cycle of Kernel.                             */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The circular input buffer x[] must be aligned at a 2^(csize+1)     */
/*       byte boundary. csize must lie in the range 2 <= csize <= 31.       */
/*    2. The number of coefficients  (nh) must be a multiple of 2           */
/*       and greater than or equal to 4.                                    */
/*    3. The number of outputs (nr) must be a multiple of 4 and             */
/*       greater than or equal to 4.                                        */
/*    4. The 'index' (offset to start reading input array) must be          */
/*       mutiple of 2 and less than or equal to (2^(csize-2) - 6)           */
/*    5. The coefficient array is assumed to be in reverse order,           */
/*       i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*    This is the C equivalent for the assembly code.  Note that            */
/*    the assembly code is hand optimized and restrictions may              */
/*    apply.                                                                */
/*                                                                          */
/*    void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      */
/*                                  int csize, int nh, int nr)              */
/*      {                                                                   */
/*        int i, j;                                                         */
/*        //Circular Buffer block size = ((2^(csize + 1)) / 8)              */
/*        //floating point numbers                                          */
/*        int mod = (1 << (csize - 2));                                     */
/*        double r0;                                                        */
/*                                                                          */
/*        for (i = 0; i < nr; i++)                                          */
/*        {                                                                 */
/*            r0 = 0;                                                       */
/*            for (j = 0; j < nh; j++)                                      */
/*            {                                                             */
/*             //Operation "% mod" is equivalent to "& (mod -1)"            */
/*             //r0 += x[(i + j + index) % mod] * h[j];                     */
/*                                                                          */
/*               r0 += x[(i + j + index) & (mod - 1)] * h[j];               */
/*            }                                                             */
/*            r[i] = r0;                                                    */
/*        }                                                                 */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2*nh + 2) nr + 38                                                    */
/*     For nh = 36 & nr=64, cycles = 4774                                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIRCIRC_H_
#define DSPF_DP_FIRCIRC_H_ 1

void DSPF_dp_fircirc     (double *x, double *h, double *r, int index,
                 int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fircirc/1117057381  2802  0     0       9054      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      30-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          *
*                      int csize, int nh, int nr)                           *
*                                                                           *
*             x[]     :     Input array (circular buffer of 2^(csize+1)     *
*                           bytes)                                          *
*                           Must be aligned at 2^(csize+1) byte boundary    *
*             h[nh]   :     Filter coefficients array                       *
*                           Must be double-word aligned                     *
*             r[nr]   :     Output array                                    *
*             index   :     Offset by which to start reading from the       *
*                           input array. Must be multiple of 2              *
*             csize   :     Size of circular buffer x[] is 2^(csize+1)      *
*                           bytes. Must be 2 <= csize <= 31.                *
*             nh      :     Number of filter coefficients                   *
*                           Must be multiple of 2 and >= 4                  *
*             nr      :     Size of output array                            *
*                           Must be multiple of 4                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This routine implements a circularly addressed FIR filter.            *
*     'nh' is the number of filter coefficients. 'nr' is the number         *
*     of the output samples.                                                *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*     1. The outer loop is unrolled 4 times.                                *
*     2. The inner loop is unrolled 2 times.                                *
*     3. Regiter sharing is udes to make optimal utilisation of the         *
*        available registers.                                               *
*     4. Outerloop instructions and Prolog for next stage are               *
*        scheduled in the last cycle of Kernel.                             *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The circular input buffer x[] must be aligned at a 2^(csize+1)     *
*        byte boundary. csize must lie in the range 2 <= csize <= 31.       *
*     2. The number of coefficients  (nh) must be a multiple of 2           *
*        and greater than or equal to 4.                                    *
*     3. The number of outputs (nr) must be a multiple of 4 and             *
*        greater than or equal to 4.                                        *
*     4. The 'index' (offset to start reading input array) must be          *
*        mutiple of 2 and less than or equal to (2^(csize-2) - 6)           *
*     5. The coefficient array is assumed to be in reverse order,           *
*        i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*     This is the C equivalent for the assembly code.  Note that            *
*     the assembly code is hand optimized and restrictions may              *
*     apply.                                                                *
*                                                                           *
*     void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      *
*                                   int csize, int nh, int nr)              *
*       {                                                                   *
*         int i, j;                                                         *
*         //Circular Buffer block size = ((2^(csize + 1)) / 8)              *
*         //floating point numbers                                          *
*         int mod = (1 << (csize - 2));                                     *
*         double r0;                                                        *
*                                                                           *
*         for (i = 0; i < nr; i++)                                          *
*         {                                                                 *
*             r0 = 0;                                                       *
*             for (j = 0; j < nh; j++)                                      *
*             {                                                             *
*              //Operation "% mod" is equivalent to "& (mod -1)"            *
*              //r0 += x[(i + j + index) % mod] * h[j];                     *
*                                                                           *
*                r0 += x[(i + j + index) & (mod - 1)] * h[j];               *
*             }                                                             *
*             r[i] = r0;                                                    *
*         }                                                                 *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2*nh + 2) nr + 38                                                    *
*      For nh = 36 & nr=64, cycles = 4774                                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_dp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_biquad./1117057382  2823  0     0       7714      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        */
/*                   double *r, int nx)                                     */
/*                                                                          */
/*           x       :  Pointer to input samples                            */
/*           b       :  Pointer to Nr coefs b0, b1, b2                      */
/*           a       :  Pointer to Dr coefs a1, a2                          */
/*           delay   :  Pointer to filter delays                            */
/*           r       :  Pointer to output samples                           */
/*           nx      :  Number of input/output samples                      */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine implements a DF 2 transposed structure of the biquad   */
/*      filter. The transfer function of a biquad can be written            */
/*      as:                                                                 */
/*                                                                          */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)         */
/*                       H(Z) =     _________________________________       */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)           */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*        1.  Register sharing has been used to optimize on the use of      */
/*            registers.                                                    */
/*        2.  x[i] is loaded on both sides to avoid crosspath conflict         */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*        1. The value of nx is >=4.                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*   void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         */
/*                                                double *r,  int nx)       */
/*      {                                                                   */
/*       int i;                                                             */
/*       double a1, a2, b0, b1, b2, d0, d1, x_i;                            */
/*                                                                          */
/*       a1 = a[0];                                                         */
/*       a2 = a[1];                                                         */
/*                                                                          */
/*       b0 = b[0];                                                         */
/*       b1 = b[1];                                                         */
/*       b2 = b[2];                                                         */
/*                                                                          */
/*       d0 = delay[0];                                                     */
/*       d1 = delay[1];                                                     */
/*                                                                          */
/*       for (i = 0; i < nx; i++)                                           */
/*       {                                                                  */
/*           x_i = x[i];                                                    */
/*           r[i] = b0 * x_i + d0;                                          */
/*           d0 = b1 * x_i - a1 * r[i] + d1;                                */
/*           d1 = b2 * x_i - a2 * r[i];                                     */
/*       }                                                                  */
/*       delay[0] = d0;                                                     */
/*       delay[1] = d1;                                                     */
/*  }                                                                       */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       16 * nx + 49                                                       */
/*       For nx = 64,  cycles = 1073                                        */
/*       For nx = 48,  cycles = 817.                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       576 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BIQUAD_H_
#define DSPF_DP_BIQUAD_H_ 1

void DSPF_dp_biquad(double     *x, double *b, double *a, double *delay,
               double *r, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_biquad.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_biquad./1117057382  2841  0     0       7792      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      03-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        *
*                    double *r, int nx)                                     *
*                                                                           *
*            x       :  Pointer to input samples                            *
*            b       :  Pointer to Nr coefs b0, b1, b2                      *
*            a       :  Pointer to Dr coefs a1, a2                          *
*            delay   :  Pointer to filter delays                            *
*            r       :  Pointer to output samples                           *
*            nx      :  Number of input/output samples                      *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine implements a DF 2 transposed structure of the biquad   *
*       filter. The transfer function of a biquad can be written            *
*       as:                                                                 *
*                                                                           *
*                                    b(0) + b(1)z^(-1) + b(2)z^(-2)         *
*                        H(Z) =     _________________________________       *
*                                     1 + a(1)z^(-1) + a(2)z^(-2)           *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*         1.  Register sharing has been used to optimize on the use of      *
*             registers.                                                    *
*         2.  x[i] is loaded on both sides to avoid crosspath conflict         *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*         1. The value of nx is >=4.                                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         *
*                                                 double *r,  int nx)       *
*       {                                                                   *
*        int i;                                                             *
*        double a1, a2, b0, b1, b2, d0, d1, x_i;                            *
*                                                                           *
*        a1 = a[0];                                                         *
*        a2 = a[1];                                                         *
*                                                                           *
*        b0 = b[0];                                                         *
*        b1 = b[1];                                                         *
*        b2 = b[2];                                                         *
*                                                                           *
*        d0 = delay[0];                                                     *
*        d1 = delay[1];                                                     *
*                                                                           *
*        for (i = 0; i < nx; i++)                                           *
*        {                                                                  *
*            x_i = x[i];                                                    *
*            r[i] = b0 * x_i + d0;                                          *
*            d0 = b1 * x_i - a1 * r[i] + d1;                                *
*            d1 = b2 * x_i - a2 * r[i];                                     *
*        }                                                                  *
*        delay[0] = d0;                                                     *
*        delay[1] = d1;                                                     *
*   }                                                                       *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        16 * nx + 49                                                       *
*        For nx = 64,  cycles = 1073                                        *
*        For nx = 48,  cycles = 817.                                        *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        576 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_biquad

*  ======================================================================== *
*   End of file:  DSPF_dp_biquad.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_iir.h/  1117057383  0     0     0       8557      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_dp_iir    (double* restrict r1,                                */
/*                      const double*    x,                                 */
/*                      double* restrict r2,                                */
/*                      const double*    h2,                                */
/*                      const double*    h1,                                */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1[nr+4]   :  Delay element values (i/p and o/p)               */
/*           x[nr]      :  Pointer to the input array                       */
/*           r2[nr+4]   :  Pointer to the output array                      */
/*           h2[5]      :  Auto-regressive filter coefficients              */
/*           h1[5]      :  Moving average filter coefficients               */
/*           nr         :  Number of output samples                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder. The               */
/*    4 values in the r1 vector store the initial values of the             */
/*    delays.                                                               */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    1. The inner loop is completely unrolled so that two loops            */
/*       become one loop.                                                   */
/*    2. Register Sharing is used to make Optimum Utilisation of            */
/*       available registers.                                               */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. The value of 'nr' must be > 0.                                     */
/*    2. Extraneous loads are allowed in the program.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_dp_iir (double* restrict r1,                                       */
/*               const double*    x,                                        */
/*               double* restrict r2,                                       */
/*               const double*    h2,                                       */
/*               const double*    h1,                                       */
/*               int nr                                                     */
/*               )                                                          */
/*   {                                                                      */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*         sum = h2[0] * x[4+i];                                            */
/*         for (j = 1; j <= 4; j++)                                         */
/*            sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  */
/*                                                                          */
/*         r1[4+i] = sum;                                                   */
/*         r2[i] = r1[4+i];                                                 */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: The code is LITTLE ENDIAN.                                */
/*     2. Interruptibility: This code is interrupt-tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     24*nr + 48                                                           */
/*     eg. for nr = 32, cycles = 816.                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     608 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIR_H_
#define DSPF_DP_IIR_H_ 1

void DSPF_dp_iir        (double* restrict r1,
                const double*    x,
                double* restrict r2,
                const double*    h2,
                const double*    h1,
                int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iir.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_iir.h67/1117057383  0     0     0       8497      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*    This routine is C callable, and has the following C prototype:         *
*                                                                           *
*       void DSPF_dp_iir    (double* restrict r1,                                *
*                       const double*    x,                                 *
*                       double* restrict r2,                                *
*                       const double*    h2,                                *
*                       const double*    h1,                                *
*                       int nr                                              *
*                      );                                                   *
*                                                                           *
*            r1[nr+4]   :  Delay element values (i/p and o/p)               *
*            x[nr]      :  Pointer to the input array                       *
*            r2[nr+4]   :  Pointer to the output array                      *
*            h2[5]      :  Auto-regressive filter coefficients              *
*            h1[5]      :  Moving average filter coefficients               *
*            nr         :  Number of output samples                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*     The IIR performs an auto-regressive moving-average (ARMA)             *
*     filter with 4 auto-regressive filter coefficients and 5               *
*     moving-average filter coefficients for nr output samples.             *
*     The output vector is stored in two locations. This routine            *
*     is used as a high pass filter in the VSELP vocoder. The               *
*     4 values in the r1 vector store the initial values of the             *
*     delays.                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*     1. The inner loop is completely unrolled so that two loops            *
*        become one loop.                                                   *
*     2. Register Sharing is used to make Optimum Utilisation of            *
*        available registers.                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. The value of 'nr' must be > 0.                                     *
*     2. Extraneous loads are allowed in the program.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the Assembly Code without                   *
*   restrictions.                                                           *
*                                                                           *
*   Note that the assembly code is hand optimized and restrictions          *
*   may apply.                                                              *
*                                                                           *
*   void DSPF_dp_iir (double* restrict r1,                                       *
*                const double*    x,                                        *
*                double* restrict r2,                                       *
*                const double*    h2,                                       *
*                const double*    h1,                                       *
*                int nr                                                     *
*                )                                                          *
*    {                                                                      *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*          sum = h2[0] * x[4+i];                                            *
*          for (j = 1; j <= 4; j++)                                         *
*             sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  *
*                                                                           *
*          r1[4+i] = sum;                                                   *
*          r2[i] = r1[4+i];                                                 *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: The code is LITTLE ENDIAN.                                *
*      2. Interruptibility: This code is interrupt-tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      24*nr + 48                                                           *
*      eg. for nr = 32, cycles = 816.                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      608 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iir

*  ======================================================================== *
*   End of file:  DSPF_dp_iir.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_iirlat./1117057384  2861  0     0       8538      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*        This routine has following C prototype:                           */
/*                                                                          */
/*            void DSPF_dp_iirlat(                                               */
/*                          double *x,                                      */
/*                          int nx,                                         */
/*                          const double * restrict k,                      */
/*                          int nk,                                         */
/*                          double * restrict b,                            */
/*                          double * r                                      */
/*                          )                                               */
/*         x[nx]   : Input vector                                           */
/*         nx      : Length of input vector.                                */
/*         k[nk]   : Reflection coefficients                                */
/*         nk      : Number of reflection coefficients/lattice stages       */
/*                   Must be multiple of 2 and >=6.                         */
/*         b[nk+1] : Delay line elements from previous call. Should be      */
/*                   initialized to all zeros prior to the first call.      */
/*         r[nx]   : Output vector                                          */
/*                                                                          */
/*     DESCRIPTION                                                          */
/*                                                                          */
/*         This routine implements a real all-pole IIR filter in lattice    */
/*     structure (AR lattice). The filter consists of nk lattice stages.    */
/*     Each  stage  requires one  reflection coefficient  k and one delay   */
/*     element b. The routine takes an input vector x[] and returns the     */
/*     filter output in r[]. Prior to the first call of the outine the      */
/*     delay elements in b[]  should be set to zero. The input data may     */
/*     have to be pre-scaled to avoid overflow or achieve better SNR. The   */
/*     reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     */
/*     order of the coefficients is such that k[nk-1] corresponds to the    */
/*     first lattice stage after the input and k[0] Corresponds to the      */
/*     last stage.                                                          */
/*                                                                          */
/*    TECHNIQUES                                                            */
/*                                                                          */
/*         1.  The loop has been unrolled by 4 times.                       */
/*                                                                          */
/*         2.  Register sharing has been used to optimize on the            */
/*             use of registers.                                            */
/*                                                                          */
/*    ASSUMPTIONS                                                           */
/*                                                                          */
/*        1. nk is a multiple of 2 and >=6.                                 */
/*        2. Extraneous loads are allowed (80 bytes) before the start of    */
/*           array.                                                         */
/*                                                                          */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  */
/*                   double * restrict b, double * r)                       */
/*   {                                                                      */
/*                                                                          */
/*      double rt;     // output       //                                   */
/*      int i, j;                                                           */
/*                                                                          */
/*      for (j = 0; j < nx; j++)                                            */
/*      {                                                                   */
/*         rt = x[j];                                                       */
/*                                                                          */
/*         for (i = nk - 1; i >= 0; i--)                                    */
/*         {                                                                */
/*             rt = rt - b[i] * k[i];                                       */
/*             b[i + 1] = b[i] + rt * k[i];                                 */
/*         }                                                                */
/*                                                                          */
/*         b[0] = rt;                                                       */
/*         r[j] = rt;                                                       */
/*      }                                                                   */
/*    }                                                                     */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (24*Ceil(nk/4) + 19)* nx + 33                                       */
/*       For nk = 14, nx = 64 cycles = 7393                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIRLAT_H_
#define DSPF_DP_IIRLAT_H_ 1

void DSPF_dp_iirlat(
              double *x,
              int nx,
              const double * restrict k,
              int nk,
              double * restrict b,
              double * r
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iirlat.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_iirlat./1117057384  2879  0     0       8500      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*         This routine has following C prototype:                           *
*                                                                           *
*             void DSPF_dp_iirlat(                                               *
*                           double *x,                                      *
*                           int nx,                                         *
*                           const double * restrict k,                      *
*                           int nk,                                         *
*                           double * restrict b,                            *
*                           double * r                                      *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*                                                                           *
*          This routine implements a real all-pole IIR filter in lattice    *
*      structure (AR lattice). The filter consists of nk lattice stages.    *
*      Each  stage  requires one  reflection coefficient  k and one delay   *
*      element b. The routine takes an input vector x[] and returns the     *
*      filter output in r[]. Prior to the first call of the outine the      *
*      delay elements in b[]  should be set to zero. The input data may     *
*      have to be pre-scaled to avoid overflow or achieve better SNR. The   *
*      reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     *
*      order of the coefficients is such that k[nk-1] corresponds to the    *
*      first lattice stage after the input and k[0] Corresponds to the      *
*      last stage.                                                          *
*                                                                           *
*     TECHNIQUES                                                            *
*                                                                           *
*          1.  The loop has been unrolled by 4 times.                       *
*                                                                           *
*          2.  Register sharing has been used to optimize on the            *
*              use of registers.                                            *
*                                                                           *
*     ASSUMPTIONS                                                           *
*                                                                           *
*         1. nk is a multiple of 2 and >=6.                                 *
*         2. Extraneous loads are allowed (80 bytes) before the start of    *
*            array.                                                         *
*                                                                           *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  *
*                    double * restrict b, double * r)                       *
*    {                                                                      *
*                                                                           *
*       double rt;     // output       //                                   *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*       }                                                                   *
*     }                                                                     *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (24*Ceil(nk/4) + 19)* nx + 33                                       *
*        For nk = 14, nx = 64 cycles = 7393                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iirlat

*  ======================================================================== *
*   End of file:  DSPF_dp_iirlat.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_convol./1117057385  2899  0     0       8817      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_convol -- Double Precision convolution                           */
/*                                                                         */
/* USAGE                                                                    */
/*    This routine has the following C prototype:                           */
/*                                                                          */
/*    void DSPF_dp_convol                                                        */
/*         (                                                                */
/*               double *x, //x: Pointer to input samples//                 */
/*               double *h, //h: Pointer to impulse response samples//      */
/*               double *r, //r: Pointer to output samples//                */
/*               int   nh, //nh: Number of impulse response samples//       */
/*               int   nr  //nr: Number of output samples//                 */
/*         )                                                                */
/*                                                                          */
/*          x = pointer to real input vector of size = nr+nh-1              */
/*          a typically contains input data (x) padded with                 */
/*          consecutive nh - 1  zeros at the beginning and end.             */
/*          h = pointer to real input vector of size nh in forward order.   */
/*          h typically contains the filter coefs.                          */
/*          r = Pointer to real output vector of size nr                    */
/*          nh= Number of elements in vector b. NOTE: nh <= nr  nh is       */
/*          typically noted as m in convol formulas. nh must be a           */
/*          MULTIPLE of 2                                                   */
/*          nr= Number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*          This function calculates the full-length convolution of real    */
/*          vectors x and h using time-domain techniques. The result is     */
/*          placed in real vector r.                                        */
/*                                                                          */
/*          It is assumed that input vector x is padded with nh-1 no of     */
/*          zeros in the beginning and end.                                 */
/*                                                                          */
/*          It is assumed that the length of the input vector h, nh, is a   */
/*          multiple of 2 and the length of the output vector r, nr, is a   */
/*          multiple of 4. nh is greater than or equal to 4 and nr is       */
/*          greater than or equal to nh. The routine computes 4 output      */
/*          samples at a time.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*          1. The inner loop is unrolled twice and the outer loop is       */
/*             unrolled four times.                                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*          1. nh is a multiple of 2 and greater than or equal to 4         */
/*          2. nr is a multiple of 4                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*          This is the C equivalent of the assembly code.  Note that       */
/*          the assembly code is hand optimized and restrictions may        */
/*          apply.                                                          */
/*                                                                          */
/*                                                                          */
/*          void DSPF_dp_convol(double *x, double *h, double *r, short nh,       */
/*                         short nr)                                        */
/*          {                                                               */
/*            short   octr, ictr;                                           */
/*            double  acc ;                                                 */
/*                                                                          */
/*            for (octr = nr ; octr > 0 ; octr--)                           */
/*            {                                                             */
/*              acc = 0 ;                                                   */
/*                                                                          */
/*              for (ictr = nh ; ictr > 0 ; ictr--)                         */
/*              {                                                           */
/*             acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       */
/*              }                                                           */
/*              r[nr-octr] = acc;                                           */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*          1. Endian: This code is LITTLE ENDIAN.                          */
/*          2. Interruptibility: This code is interrupt tolerant but not    */
/*                       interruptible.                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*          2*(nh*nr) + 5/2*nr + 32                                         */
/*          For nh=24 and nr=48, cycles=2456                                */
/*          For nh=20 and nr=32, cycles=1392                                */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*          544 bytes                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CONVOL_H_
#define DSPF_DP_CONVOL_H_ 1

void DSPF_dp_convol
     (
           double *x, //x: Pointer to input samples//
           double *h, //h: Pointer to impulse response samples//
           double *r, //r: Pointer to output samples//
           int   nh, //nh: Number of impulse response samples//
           int   nr  //nr: Number of output samples//
     );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_convol.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_convol./1117057385  2917  0     0       8658      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_convol -- Double Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*     This routine has the following C prototype:                           *
*                                                                           *
*     void DSPF_dp_convol                                                        *
*          (                                                                *
*                double *x, //x: Pointer to input samples//                 *
*                double *h, //h: Pointer to impulse response samples//      *
*                double *r, //r: Pointer to output samples//                *
*                int   nh, //nh: Number of impulse response samples//       *
*                int   nr  //nr: Number of output samples//                 *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*           a typically contains input data (x) padded with                 *
*           consecutive nh - 1  zeros at the beginning and end.             *
*           h = pointer to real input vector of size nh in forward order.   *
*           h typically contains the filter coefs.                          *
*           r = Pointer to real output vector of size nr                    *
*           nh= Number of elements in vector b. NOTE: nh <= nr  nh is       *
*           typically noted as m in convol formulas. nh must be a           *
*           MULTIPLE of 2                                                   *
*           nr= Number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater than or equal to 4 and nr is       *
*           greater than or equal to nh. The routine computes 4 output      *
*           samples at a time.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*                                                                           *
*           void DSPF_dp_convol(double *x, double *h, double *r, short nh,       *
*                          short nr)                                        *
*           {                                                               *
*             short   octr, ictr;                                           *
*             double  acc ;                                                 *
*                                                                           *
*             for (octr = nr ; octr > 0 ; octr--)                           *
*             {                                                             *
*               acc = 0 ;                                                   *
*                                                                           *
*               for (ictr = nh ; ictr > 0 ; ictr--)                         *
*               {                                                           *
*              acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       *
*               }                                                           *
*               r[nr-octr] = acc;                                           *
*             }                                                             *
*           }                                                               *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*           1. Endian: This code is LITTLE ENDIAN.                          *
*           2. Interruptibility: This code is interrupt tolerant but not    *
*                        interruptible.                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*           2*(nh*nr) + 5/2*nr + 32                                         *
*           For nh=24 and nr=48, cycles=2456                                *
*           For nh=20 and nr=32, cycles=1392                                *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*           544 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_convol

*  ======================================================================== *
*   End of file:  DSPF_dp_convol.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_dotp_sq/1117057386  2937  0     0       7174      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_dotp_sqr(                                                */
/*                       double G,                                          */
/*                       const double * x,                                  */
/*                       const double * y,                                  */
/*                       double *  restrict r,                              */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine computes the dot product of x[] and y[] arrays,       */
/*   adding it to the value in the location pointed to by r.                */
/*   Additionally, it computes the sum of the squares of the terms          */
/*   in the y array,adding it to the argument G. The final value of         */
/*   G is given as the return value of the function.                        */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*     1. Multiple Assignment was used to reduce loop carry path.           */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*     1. There are no special alignment requirements.                      */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    */
/*                        double *restrict r, int nx)                       */
/*      {                                                                   */
/*                                                                          */
/*         int i;                                                           */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         {                                                                */
/*               *r += x[i] * y[i];     // Compute Dot Product //           */
/*               G += y[i] * y[i];      // Compute Square  //               */
/*         }                                                                */
/*                                                                          */
/*         return G;                                                        */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*        1. Endian : This code is LITTLE ENDIAN .                          */
/*        2. Interruptibility: This code is interrupt-tolerant but not      */
/*                             interruptible.                               */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*      4*nx + 26                                                           */
/*                                                                          */
/*       For nx=64, cycles=282.                                             */
/*       For nx=30, cycles=146.                                             */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*      244 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_SQR_H_
#define DSPF_DP_DOTP_SQR_H_ 1

double DSPF_dp_dotp_sqr(
                double G,
                const double * x,
                const double * y,
                double *  restrict r,
                int   nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_sqr.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_sq/1117057386  2957  0     0       7159      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_dotp_sqr(                                                *
*                        double G,                                          *
*                        const double * x,                                  *
*                        const double * y,                                  *
*                        double *  restrict r,                              *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine computes the dot product of x[] and y[] arrays,       *
*    adding it to the value in the location pointed to by r.                *
*    Additionally, it computes the sum of the squares of the terms          *
*    in the y array,adding it to the argument G. The final value of         *
*    G is given as the return value of the function.                        *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*      1. Multiple Assignment was used to reduce loop carry path.           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*      1. There are no special alignment requirements.                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    *
*                         double *restrict r, int nx)                       *
*       {                                                                   *
*                                                                           *
*          int i;                                                           *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          {                                                                *
*                *r += x[i] * y[i];     /* Compute Dot Product */           *
*                G += y[i] * y[i];      /* Compute Square  */               *
*          }                                                                *
*                                                                           *
*          return G;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*         1. Endian : This code is LITTLE ENDIAN .                          *
*         2. Interruptibility: This code is interrupt-tolerant but not      *
*                              interruptible.                               *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*       4*nx + 26                                                           *
*                                                                           *
*        For nx=64, cycles=282.                                             *
*        For nx=30, cycles=146.                                             *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*       244 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_sqr

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_sqr.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_dotprod/1117057387  2979  0     0       4097      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx);  */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx)   */
/*      {                                                                   */
/*         int i;                                                           */
/*         double sum = 0;                                                  */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTPROD_ASM_H_
#define DSPF_DP_DOTPROD_ASM_H_ 1

double DSPF_dp_dotprod(const     double * x, const double * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_dotprod/1117057387  2998  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_dotprod

* ======================================================================== *
*  End of file: DSPF_dp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_dotp_cp/1117057388  3019  0     0       6940      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         */
/*     product                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * */
/*                        restrict re, double * restrict im);               */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real                    */
/*              part of the result.                                         */
/*      im    : Pointer to the location storing the imaginary part of       */
/*              the result                                                  */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double   precision     */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1.  The value of nx must be  > 0.                                   */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          */
/*                    double* restrict re, double* restrict im)             */
/*      {                                                                   */
/*                                                                          */
/*          double real=0, imag=0;                                          */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*  1. Endian: This code is LITTLE ENDIAN.                                  */
/*  2. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     8*N + 29                                                             */
/*     eg. for N = 128, cycles = 1053.                                      */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     352 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_CPLX_H_
#define DSPF_DP_DOTP_CPLX_H_ 1

void DSPF_dp_dotp_cplx(const     double *x, const double *y, int n, double *
                  restrict re, double * restrict im);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_cplx.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_cp/1117057388  3040  0     0       7001      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine is C Callable and can be called as:                      *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * *
*                         restrict re, double * restrict im);               *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       n     : Number of values in the x & y vectors                       *
*       re    : Pointer to the location storing the real                    *
*               part of the result.                                         *
*       im    : Pointer to the location storing the imaginary part of       *
*               the result                                                  *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine calculates the dot product of 2 Double   precision     *
*   complex float vectors. The even numbered locations hold the real parts  *
*   of the complex numbers while the odd numbered locations contain the     *
*   imaginary portions.                                                     *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*       1.  The value of nx must be  > 0.                                   *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          *
*                     double* restrict re, double* restrict im)             *
*       {                                                                   *
*                                                                           *
*           double real=0, imag=0;                                          *
*           int i=0;                                                        *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*           {                                                               *
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  *
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  *
*           }                                                               *
*                                                                           *
*           *re=real;                                                       *
*           *im=imag;                                                       *
*      }                                                                    *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*   1. Endian: This code is LITTLE ENDIAN.                                  *
*   2. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      8*N + 29                                                             *
*      eg. for N = 128, cycles = 1053.                                      *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      352 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_cplx.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxval./1117057389  3063  0     0       6903      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxval -- Maximum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_maxval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the maximum number in the                   */
/*   input array.This code returns the maximum value                        */
/*   in the array.                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The loop is unrolled six times.                                   */
/*     2. Six maximums are maintained in each iteration.                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input is    */
/*         disregarded.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_maxval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double max;                                                      */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*          for (i = 0; i < nx; i++)                                        */
/*          if (x[i] > max)                                                 */
/*           {                                                              */
/*            max = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*          return max;                                                     */
/*       }                                                                  */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*      2. Endian: This code is LITTLE ENDIAN.                              */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60, cycles=101.                                              */
/*      For nx=34, cycles=73.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*      672 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXVAL_H_
#define DSPF_DP_MAXVAL_H_ 1

double DSPF_dp_maxval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_maxval./1117057389  3081  0     0       6999      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_maxval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the maximum number in the                   *
*    input array.This code returns the maximum value                        *
*    in the array.                                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The loop is unrolled six times.                                   *
*      2. Six maximums are maintained in each iteration.                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input is    *
*          disregarded.                                                     *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_maxval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double max;                                                      *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           if (x[i] > max)                                                 *
*            {                                                              *
*             max = x[i];                                                   *
*            }                                                              *
*                                                                           *
*           return max;                                                     *
*        }                                                                  *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*       2. Endian: This code is LITTLE ENDIAN.                              *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60, cycles=101.                                              *
*       For nx=34, cycles=73.                                               *
*                                                                           *
*   CODESIZE                                                                *
*       672 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxval

*  ======================================================================== *
*   End of file:  DSPF_dp_maxval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxidx./1117057390  3101  0     0       6496      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_dp_maxidx(                                                     */
/*                      const double* x,                                    */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the index of maximum number in the input    */
/*       array. This function returns the index of the greatest value.      */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled three times.                                */
/*      2. Three maximums are maintained in each iteration.                 */
/*      3. MPY instructions are  used for move.                             */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 3.                                           */
/*      2. nx >= 3, and nx <= 2^16-1.                                       */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      int DSPF_dp_maxidx(const double* x, int nx)                              */
/*      {                                                                   */
/*         int index, i;                                                    */
/*         double max;                                                      */
/*                                                                          */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] > max)                                                  */
/*         {                                                                */
/*            max = x[i];                                                   */
/*            index = i;                                                    */
/*         }                                                                */
/*         return index;                                                    */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: This code is LITTLE ENDIAN.                               */
/*     2. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      4*nx/3 + 22                                                         */
/*      For nx=60, cycles=102.                                              */
/*      For nx=30, cycles=62.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      448 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXIDX_H_
#define DSPF_DP_MAXIDX_H_ 1

int DSPF_dp_maxidx(
               const double* x,
               int nx
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxidx.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_maxidx./1117057390  3119  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      16-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        int DSPF_dp_maxidx(                                                     *
*                       const double* x,                                    *
*                       int nx                                              *
*                     )                                                     *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the index of maximum number in the input    *
*        array. This function returns the index of the greatest value.      *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled three times.                                *
*       2. Three maximums are maintained in each iteration.                 *
*       3. MPY instructions are  used for move.                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 3.                                           *
*       2. nx >= 3, and nx <= 2^16-1.                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       int DSPF_dp_maxidx(const double* x, int nx)                              *
*       {                                                                   *
*          int index, i;                                                    *
*          double max;                                                      *
*                                                                           *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*          {                                                                *
*             max = x[i];                                                   *
*             index = i;                                                    *
*          }                                                                *
*          return index;                                                    *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: This code is LITTLE ENDIAN.                               *
*      2. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       4*nx/3 + 22                                                         *
*       For nx=60, cycles=102.                                              *
*       For nx=30, cycles=62.                                               *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       448 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxidx

*  ======================================================================== *
*   End of file:  DSPF_dp_maxidx.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_minval./1117057391  3139  0     0       6503      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_minval -- Minimum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_minval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out and returns the minimum number              */
/*   in the input array.                                                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled six times.                                  */
/*      2. Six minimums are maintained in each iteration.                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      double DSPF_dp_minval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double min;                                                      */
/*         *((int *)&min) = 0x00000000;                                     */
/*         *((int *)&min+1) = 0x7ff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] < min)                                                  */
/*         {                                                                */
/*            min = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*         return min;                                                      */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*  1. NAN( Not a Number in Double Precision format) in the input are       */
/*     disregarded.                                                         */
/*  2. Endian: This code is LITTLE ENDIAN.                                  */
/*  3. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60 cycles=101                                                */
/*      For nx=34 cycles=73                                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      640 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MINVAL_H_
#define DSPF_DP_MINVAL_H_ 1

double DSPF_dp_minval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_minval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_minval./1117057391  3157  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_minval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out and returns the minimum number              *
*    in the input array.                                                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled six times.                                  *
*       2. Six minimums are maintained in each iteration.                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       double DSPF_dp_minval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double min;                                                      *
*          *((int *)&min) = 0x00000000;                                     *
*          *((int *)&min+1) = 0x7ff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] < min)                                                  *
*          {                                                                *
*             min = x[i];                                                   *
*            }                                                              *
*                                                                           *
*          return min;                                                      *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*   1. NAN( Not a Number in Double Precision format) in the input are       *
*      disregarded.                                                         *
*   2. Endian: This code is LITTLE ENDIAN.                                  *
*   3. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60 cycles=101                                                *
*       For nx=34 cycles=73                                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       640 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_minval

*  ======================================================================== *
*   End of file:  DSPF_dp_minval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecreci/1117057392  3177  0     0       6942      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecrecip -- Double Precision vector reciprocal                   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void  DSPF_dp_vecrecip(const double *x,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_dp_vecrecip module calculates the reciprocal of each element    */
/*  in the array x and returns the output in array r. It uses 3             */
/*  iterations of the Newton-Raphson method to improve the accuracy         */
/*  of the output generated by the RCPDP instruction of the C67x.           */
/*  Each iteration doubles the accuracy. The initial output generated       */
/*  by RCPDP is 8 bits.So after the first iteration it is 16 bits and       */
/*  after the second it is the  23 bits and after third it is full 52 bits. */
/*  The formula used is:                                                    */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPDP.          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel. However the stores are executed  */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*      2. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. There are no alignment requirements.                             */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*    void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          */
/*    {                                                                     */
/*     int i;                                                               */
/*     for(i = 0; i < n; i++)                                               */
/*        r[i] = 1 / x[i];                                                  */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant                */
/*         but not interruptible.                                           */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     78*ceil(n/4) + 24                                                    */
/*     eg. for n = 54, cycles = 1116                                        */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     448 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECRECIP_H_
#define DSPF_DP_VECRECIP_H_ 1

void  DSPF_dp_vecrecip(const     double *x,
                  double * restrict r,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecrecip.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecreci/1117057392  3197  0     0       7006      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void  DSPF_dp_vecrecip(const double *x,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_dp_vecrecip module calculates the reciprocal of each element    *
*   in the array x and returns the output in array r. It uses 3             *
*   iterations of the Newton-Raphson method to improve the accuracy         *
*   of the output generated by the RCPDP instruction of the C67x.           *
*   Each iteration doubles the accuracy. The initial output generated       *
*   by RCPDP is 8 bits.So after the first iteration it is 16 bits and       *
*   after the second it is the  23 bits and after third it is full 52 bits. *
*   The formula used is:                                                    *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPDP.          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled four times to allow calculation of    *
*          four reciprocals in the kernel. However the stores are executed  *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*       2. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. There are no alignment requirements.                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*     void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          *
*     {                                                                     *
*      int i;                                                               *
*      for(i = 0; i < n; i++)                                               *
*         r[i] = 1 / x[i];                                                  *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant                *
*          but not interruptible.                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      78*ceil(n/4) + 24                                                    *
*      eg. for n = 54, cycles = 1116                                        *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      448 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecrecip

*  ======================================================================== *
*   End of file:  DSPF_dp_vecrecip.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecsum_/1117057393  3219  0     0       6101      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecsum_sq -- Double Precision sum of squares                     */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      double DSPF_dp_vecsum_sq(const double *x,                                */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*       array x and returns the sum.                                       */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice. Hence, 2 registers are used    */
/*         to hold the sum of squares. ADDDPs are staggered.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Since loads of 4 doubles beyond the array occur,                 */
/*         a pad must be provided.                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions. Note that the assembly code is hand optimized          */
/*     and restrictions may apply.                                          */
/*                                                                          */
/*     double DSPF_dp_vecsum_sq(const double *x,int n)                           */
/*     {                                                                    */
/*         int i;                                                           */
/*         double sum=0;                                                    */
/*                                                                          */
/*         for(i = 0;  i < n; i++ )                                         */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is ENDIAN NEUTRAL.                               */
/*    2. Interruptibility: This code is interrupt tolerant                  */
/*                            but not interruptible.                        */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    4*Ceil(n/2) + 33                                                      */
/*    eg. for n = 100, cycles = 233                                         */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    288 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECSUM_SQ_H_
#define DSPF_DP_VECSUM_SQ_H_ 1

double DSPF_dp_vecsum_sq(const     double *x,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecsum_sq.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_vecsum_/1117057392  3240  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       double DSPF_dp_vecsum_sq(const double *x,                                *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs a sum of squares of the elements of the      *
*        array x and returns the sum.                                       *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice. Hence, 2 registers are used    *
*          to hold the sum of squares. ADDDPs are staggered.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Since loads of 4 doubles beyond the array occur,                 *
*          a pad must be provided.                                          *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions. Note that the assembly code is hand optimized          *
*      and restrictions may apply.                                          *
*                                                                           *
*      double DSPF_dp_vecsum_sq(const double *x,int n)                           *
*      {                                                                    *
*          int i;                                                           *
*          double sum=0;                                                    *
*                                                                           *
*          for(i = 0;  i < n; i++ )                                         *
*              sum += x[i]*x[i];                                            *
*                                                                           *
*          return sum;                                                      *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is ENDIAN NEUTRAL.                               *
*     2. Interruptibility: This code is interrupt tolerant                  *
*                             but not interruptible.                        *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     4*Ceil(n/2) + 33                                                      *
*     eg. for n = 100, cycles = 233                                         *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     288 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecsum_sq

*  ======================================================================== *
*   End of file:  DSPF_dp_vecsum_sq.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_w_vec.h/1117057394  0     0     0       6417      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_w_vec -- Double Precision weighted sum of vectors                */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_dp_w_vec(const double* x,                                    */
/*                      const double* y,                                    */
/*                      double m,                                           */
/*                      double * restrict r,                                */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are Double precision floating             */
/*     point numbers.                                                       */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The inner loop is unrolled twice.                                 */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The value of nr must be > 0.                                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_w_vec( const double * x,const double * y, double  m,         */
/*                    double * restrict r,int nr)                           */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt tolerant but not          */
/*                         interruptible.                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     4*Ceil(n/2) + 32                                                     */
/*     eg. for n = 100, cycles = 232.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    352 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_W_VEC_H_
#define DSPF_DP_W_VEC_H_ 1

void DSPF_dp_w_vec(const     double* x,
              const double* y,
              double m,
              double * restrict r,
              int     nr
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_w_vec.h                                                */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_w_vec.h/1117057393  3263  0     0       6445      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void DSPF_dp_w_vec(const double* x,                                    *
*                       const double* y,                                    *
*                       double m,                                           *
*                       double * restrict r,                                *
*                       int     nr                                          *
*                      )                                                    *
*                                                                           *
*              x    :  Pointer to first input array                         *
*              y    :  Pointer to second input array                        *
*              m    :  Weight factor                                        *
*              r    :  Output array pointer                                 *
*              nr   :  Number of elements in arrays                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine is used to obtain the weighted vector sum.              *
*      Both the inputs and output are Double precision floating             *
*      point numbers.                                                       *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The inner loop is unrolled twice.                                 *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The value of nr must be > 0.                                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_w_vec( const double * x,const double * y, double  m,         *
*                     double * restrict r,int nr)                           *
*                                                                           *
*     {                                                                     *
*         int i;                                                            *
*         for (i = 0; i < nr; i++)                                          *
*             r[i] = (m * x[i]) + y[i];                                     *
*     }                                                                     *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt tolerant but not          *
*                          interruptible.                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      4*Ceil(n/2) + 32                                                     *
*      eg. for n = 100, cycles = 232.                                       *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     352 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_w_vec

*  ======================================================================== *
*   End of file:  DSPF_dp_w_vec.h67                                              *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_vecmul./1117057395  3282  0     0       6570      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecmul -- Double Precision vector multiplication                 */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_dp_vecmul   (const double *x,                                  */
/*                        const double *y,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                        )                                                 */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element Double Precision       */
/*       floating point  multiplication of the vectors x[] and y[] and      */
/*       returns the values in r[].                                         */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled twice to allow calculation of         */
/*         2 outputs in the kernel. However the stores are executed         */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*      1. The value of n > 0.                                              */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_vecmul(const double * x, const double * y,                   */
/*                           double * restrict r, int n)                    */
/*      {                                                                   */
/*        int i;                                                            */
/*                                                                          */
/*        for(i = 0; i < n; i++)                                            */
/*             r[i] = x[i] * y[i];                                          */
/*                                                                          */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*       1. Endian: This code is LITTLE ENDIAN.                             */
/*       2. Interruptibility: The code is interrupt tolerant but not        */
/*          interruptible.                                                  */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*         4*Ceil(n/2) + 13                                                 */
/*         eg. for n = 100, cycles = 213                                    */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*         256 bytes                                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECMUL_H_
#define DSPF_DP_VECMUL_H_ 1

void DSPF_dp_vecmul       (const double *x,
                  const double *y,
                  double * restrict r,
                  int n
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecmul.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecmul./1117057394  3300  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecmul -- Double Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void DSPF_dp_vecmul   (const double *x,                                  *
*                         const double *y,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs an element by element Double Precision       *
*        floating point  multiplication of the vectors x[] and y[] and      *
*        returns the values in r[].                                         *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*       1. The inner loop is unrolled twice to allow calculation of         *
*          2 outputs in the kernel. However the stores are executed         *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*       1. The value of n > 0.                                              *
*                                                                           *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_vecmul(const double * x, const double * y,                   *
*                            double * restrict r, int n)                    *
*       {                                                                   *
*         int i;                                                            *
*                                                                           *
*         for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                          *
*                                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*        1. Endian: This code is LITTLE ENDIAN.                             *
*        2. Interruptibility: The code is interrupt tolerant but not        *
*           interruptible.                                                  *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*          4*Ceil(n/2) + 13                                                 *
*          eg. for n = 100, cycles = 213                                    *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*          256 bytes                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecmul

*  ======================================================================== *
*   End of file:  DSPF_dp_vecmul.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057395  3320  0     0       8271      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine has following C prototype:                              */
/*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                           */
/*                     double *y, int c2, double *r)                        */
/*                                                                          */
/*     x      : Pointer to r1 by c1 input matrix.                           */
/*     r1     : Number of rows in x.                                        */
/*     c1     : Number of columns in x.  Also number of rows in y.          */
/*     y      : Pointer to c1 by c2 input matrix.                           */
/*     c2     : Number of columns in y.                                     */
/*     r      : Pointer to r1 by c2 output matrix.                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be Double           */
/*     precision floating point values.                                     */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*     1.    All three loops are unrolled two times                         */
/*     2.    All the prolog stages of the innermost loop (kLoop) are        */
/*           Scheduled in Parallel with outer loop.                         */
/*     3.    Extraneous Loads are allowed in Program                        */
/*     4.    Outer most Loop Instructions are scheduled in Parallel with In *r
/*           Loop Instructions.                                                   */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*     1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    */
/*           That is, in-place processing is not allowed.                   */
/*     2.    All r1, c1, c2 are assumed to be > 1                           */
/*     3.   If r1 is odd, one extra row of x[] matrix is loaded             */
/*     4.   If c2 is odd, one extra col of y[] matrix is loaded.            */
/*     5.   If c1 is odd, one extra col of x[] and  one extra row of        */
/*          y[] array is loaded                                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*    void DSPF_dp_mat_mul(double *x, int r1, int c1,                            */
/*                    double *y, int c2, double *r)                         */
/*    {                                                                     */
/*        int i, j, k;                                                      */
/*        double sum;                                                       */
/*                                                                          */
/*     //  Multiply each row in x by each column in y.                      */
/*     //  The product of row m in x and column n in y is placed            */
/*     //  in position (m,n) in the result.                                 */
/*                                                                          */
/*        for (i = 0; i < r1; i++)                                          */
/*            for (j = 0; j < c2; j++)                                      */
/*            {                                                             */
/*                sum = 0;                                                  */
/*                for (k = 0; k < c1; k++)                                  */
/*                    sum += x[k + i*c1] * y[j + k*c2];                     */
/*                                                                          */
/*                r[j + i*c2] = sum;                                        */
/*            }                                                             */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1.   Endian: This code is LITTLE ENDIAN .                            */
/*     2.   Interruptibility: This code is interrupt-tolerant but not       */
/*          interruptible.                                                  */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       */
/*    where                                                                 */
/*           r1' = r1 + (r1&1)                                              */
/*           c2' = c2 + (c2&1)                                              */
/*    For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*    960 Bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_H_
#define DSPF_DP_MAT_MUL_H_ 1

void DSPF_dp_mat_mul(double     *x, int r1, int c1,
                double *y, int c2, double *r);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057395  3339  0     0       8350      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine has following C prototype:                              *
*      void DSPF_dp_mat_mul(double *x, int r1, int c1,                           *
*                      double *y, int c2, double *r)                        *
*                                                                           *
*      x      : Pointer to r1 by c1 input matrix.                           *
*      r1     : Number of rows in x.                                        *
*      c1     : Number of columns in x.  Also number of rows in y.          *
*      y      : Pointer to c1 by c2 input matrix.                           *
*      c2     : Number of columns in y.                                     *
*      r      : Pointer to r1 by c2 output matrix.                          *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      This function computes the expression "r = x * y" for the matrices   *
*      x and y.  The column dimension of x must match the row dimension     *
*      of y.  The resulting matrix has the same number of rows as x and     *
*      the same number of columns as y.                                     *
*                                                                           *
*      The values stored in the matrices are assumed to be Double           *
*      precision floating point values.                                     *
*                                                                           *
*      This code is suitable for dense matrices.  No optimizations are      *
*      made for sparse matrices.                                            *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*      1.    All three loops are unrolled two times                         *
*      2.    All the prolog stages of the innermost loop (kLoop) are        *
*            Scheduled in Parallel with outer loop.                         *
*      3.    Extraneous Loads are allowed in Program                        *
*      4.    Outer most Loop Instructions are scheduled in Parallel with In *r
*            Loop Instructions.                                                   *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*      1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    *
*            That is, in-place processing is not allowed.                   *
*      2.    All r1, c1, c2 are assumed to be > 1                           *
*      3.   If r1 is odd, one extra row of x[] matrix is loaded             *
*      4.   If c2 is odd, one extra col of y[] matrix is loaded.            *
*      5.   If c1 is odd, one extra col of x[] and  one extra row of        *
*           y[] array is loaded                                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                            *
*                     double *y, int c2, double *r)                         *
*     {                                                                     *
*         int i, j, k;                                                      *
*         double sum;                                                       *
*                                                                           *
*      //  Multiply each row in x by each column in y.                      *
*      //  The product of row m in x and column n in y is placed            *
*      //  in position (m,n) in the result.                                 *
*                                                                           *
*         for (i = 0; i < r1; i++)                                          *
*             for (j = 0; j < c2; j++)                                      *
*             {                                                             *
*                 sum = 0;                                                  *
*                 for (k = 0; k < c1; k++)                                  *
*                     sum += x[k + i*c1] * y[j + k*c2];                     *
*                                                                           *
*                 r[j + i*c2] = sum;                                        *
*             }                                                             *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1.   Endian: This code is LITTLE ENDIAN .                            *
*      2.   Interruptibility: This code is interrupt-tolerant but not       *
*           interruptible.                                                  *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       *
*     where                                                                 *
*            r1' = r1 + (r1&1)                                              *
*            c2' = c2 + (c2&1)                                              *
*     For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*     960 Bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_tra/1117057396  3360  0     0       6180      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_trans -- Double Precision matrix transpose                   */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x,                        */
/*                         int rows,                                        */
/*                         int cols,                                        */
/*                         double *restrict r                               */
/*                         )                                                */
/*                                                                          */
/*          x       :  Input matrix containing rows*cols Double Precision   */
/*                     floating point numbers.                              */
/*          rows    :  No. of rows in matrix x.                             */
/*                     Also no. of columns in matrix r                      */
/*          cols    :  No. of columns in matrix x.                          */
/*                     Also no. of rows in matrix r.                        */
/*          r       :  Output matrix containing cols*rows Double Precision  */
/*                     floating point numbers.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The number of rows and columns is > 0.                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*       This is the C equivalent of the assembly code.  Note that          */
/*       the assembly code is hand optimized and restrictions may apply.    */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x, int rows,              */
/*       int cols, double *restrict r)                                      */
/*       {                                                                  */
/*          int i,j;                                                        */
/*                                                                          */
/*          for(i=0; i<cols; i++)                                           */
/*             for(j=0; j<rows; j++)                                        */
/*                r[i * rows + j] = x[i + cols * j];                        */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2 * rows * cols + 15                                                */
/*      For rows=10 and cols=20, cycles=415                                 */
/*      For rows=15 and cols=20, cycles=615                                 */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      256  bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_TRANS_H_
#define DSPF_DP_MAT_TRANS_H_ 1

void DSPF_dp_mat_trans(const     double *restrict x,
                  int rows,
                  int cols,
                  double *restrict r
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_trans.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_mat_tra/1117057396  3381  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x,                        *
*                          int rows,                                        *
*                          int cols,                                        *
*                          double *restrict r                               *
*                          )                                                *
*                                                                           *
*           x       :  Input matrix containing rows*cols Double Precision   *
*                      floating point numbers.                              *
*           rows    :  No. of rows in matrix x.                             *
*                      Also no. of columns in matrix r                      *
*           cols    :  No. of columns in matrix x.                          *
*                      Also no. of rows in matrix r.                        *
*           r       :  Output matrix containing cols*rows Double Precision  *
*                      floating point numbers.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This function transposes the input matrix x[] and writes the          *
*     result to matrix r[].                                                 *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The number of rows and columns is > 0.                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*        This is the C equivalent of the assembly code.  Note that          *
*        the assembly code is hand optimized and restrictions may apply.    *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x, int rows,              *
*        int cols, double *restrict r)                                      *
*        {                                                                  *
*           int i,j;                                                        *
*                                                                           *
*           for(i=0; i<cols; i++)                                           *
*              for(j=0; j<rows; j++)                                        *
*                 r[i * rows + j] = x[i + cols * j];                        *
*        }                                                                  *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2 * rows * cols + 15                                                *
*       For rows=10 and cols=20, cycles=415                                 *
*       For rows=15 and cols=20, cycles=615                                 *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       256  bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_trans

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_trans.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057397  3404  0     0       9807      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_mul_cplx(                                              */
/*                              const double* x,                            */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const double* y,                            */
/*                              int c2,                                     */
/*                              double* restrict r                          */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   No. of rows in matrix x.                        */
/*            c1        :   No. of columns in matrix x.                     */
/*                          Also no. of rows in matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          real values stored in even positions and        */
/*                          imaginary values in odd positions.              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of the matrix is assumed to be complex numbers with  */
/*        Real values are stored in even positions and imaginary            */
/*        values in odd positions.                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*        1. Innermost loop is unrolled twice.                              */
/*        2. Outermost loop is executed in parallel with innner loops.      */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*        1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 */
/*        2. x should be padded with 6 words                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*   the assembly code is hand optimized and restrictions may apply.        */
/*                                                                          */
/*        void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             */
/*          const double* y, int c2, double* restrict r)                    */
/*        {                                                                 */
/*            double real, imag;                                            */
/*            int i, j, k;                                                  */
/*                                                                          */
/*            for(i = 0; i < r1; i++)                                       */
/*            {                                                             */
/*              for(j = 0; j < c2; j++)                                     */
/*              {                                                           */
/*                real=0;                                                   */
/*                imag=0;                                                   */
/*                                                                          */
/*                for(k = 0; k < c1; k++)                                   */
/*                {                                                         */
/*                real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  */
/*                -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              */
/*                                                                          */
/*                imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              */
/*                   + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              */
/*                }                                                         */
/*                r[i*2*c2 + 2*j] = real;                                   */
/*                r[i*2*c2 + 2*j + 1] = imag;                               */
/*              }                                                           */
/*            }                                                             */
/*        }                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*        1. Real values are stored in even word positions and imaginary    */
/*           values in odd positions.                                       */
/*        2. Endian: This code is LITTLE ENDIAN.                            */
/*        3. Interruptibility: This code is interrupt tolerant but not      */
/*           interruptible.                                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*        8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 */
/*        When r1=3, c1=4, c2=4, cycles = 640                               */
/*        When r1=4, c1=4, c2=5, cycles = 1040                              */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_CPLX_H_
#define DSPF_DP_MAT_MUL_CPLX_H_ 1

void DSPF_dp_mat_mul_cplx(
                       const double* x,
                       int r1,
                       int c1,
                       const double* y,
                       int c2,
                       double* restrict r
                    );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul_cplx.h                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057397  3428  0     0       9691      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_mul_cplx(                                              *
*                               const double* x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const double* y,                            *
*                               int c2,                                     *
*                               double* restrict r                          *
*                            )                                              *
*                                                                           *
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           *
*                           floating point numbers having r1 rows and c1    *
*                           columns of complex numbers.                     *
*             r1        :   No. of rows in matrix x.                        *
*             c1        :   No. of columns in matrix x.                     *
*                           Also no. of rows in matrix y.                   *
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           *
*                           floating point numbers having c1 rows and c2    *
*                           columns of complex numbers.                     *
*             c2        :   No. of columns in matrix y.                     *
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         *
*                           point numbers having c1 rows and c2 columns of  *
*                           complex numbers.                                *
*                                                                           *
*                           Complex numbers are stored consecutively with   *
*                           real values stored in even positions and        *
*                           imaginary values in odd positions.              *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*         This function computes the expression "r = x * y" for the         *
*         matrices x and y. The columnar dimension of x must match the row  *
*         dimension of y. The resulting matrix has the same number of rows  *
*         as x and the same number of columns as y.                         *
*                                                                           *
*         Each element of the matrix is assumed to be complex numbers with  *
*         Real values are stored in even positions and imaginary            *
*         values in odd positions.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*         1. Innermost loop is unrolled twice.                              *
*         2. Outermost loop is executed in parallel with innner loops.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*         1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 *
*         2. x should be padded with 6 words                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*    the assembly code is hand optimized and restrictions may apply.        *
*                                                                           *
*         void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             *
*           const double* y, int c2, double* restrict r)                    *
*         {                                                                 *
*             double real, imag;                                            *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  *
*                 -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              *
*                                                                           *
*                 imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              *
*                    + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              *
*                 }                                                         *
*                 r[i*2*c2 + 2*j] = real;                                   *
*                 r[i*2*c2 + 2*j + 1] = imag;                               *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*         1. Real values are stored in even word positions and imaginary    *
*            values in odd positions.                                       *
*         2. Endian: This code is LITTLE ENDIAN.                            *
*         3. Interruptibility: This code is interrupt tolerant but not      *
*            interruptible.                                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*         8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 *
*         When r1=3, c1=4, c2=4, cycles = 640                               *
*         When r1=4, c1=4, c2=5, cycles = 1040                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul_cplx.h67                                       *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_blk_mov/1117057398  3454  0     0       5756      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_blk_move -- DSPF_dp_blk_move                                          */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_blk_move(                                                  */
/*                        const double *   x,                               */
/*                        double *restrict r,                               */
/*                        int nx                                            */
/*                       )                                                  */
/*                                                                          */
/*            x[nx]: Pointer to source data to be moved.                    */
/*            r[nx]: Pointer to destination array.                          */
/*            nx:    Number of floats to move.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*   This routine moves nx doubles from one memory location                 */
/*       pointed to by x to another pointed to by r.                        */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*       1. nx is greater than 0.                                           */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*       void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     */
/*       {                                                                  */
/*           int i;                                                         */
/*           for (i = 0 ; i < nx; i++)                                      */
/*               r[i] = x[i];                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This implementation is Little-Endian.                    */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2*nx+ 8                                                             */
/*      For nx=64, cycles=136.                                              */
/*      For nx=25, cycles=58.                                               */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      96 bytes                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BLK_MOVE_H_
#define DSPF_DP_BLK_MOVE_H_ 1

void DSPF_dp_blk_move(
                 const double *   x,
                 double *restrict r,
                 int nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_blk_move.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_blk_mov/1117057398  3474  0     0       5821      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_blk_move(                                                  *
*                         const double *   x,                               *
*                         double *restrict r,                               *
*                         int nx                                            *
*                        )                                                  *
*                                                                           *
*             x[nx]: Pointer to source data to be moved.                    *
*             r[nx]: Pointer to destination array.                          *
*             nx:    Number of floats to move.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*    This routine moves nx doubles from one memory location                 *
*        pointed to by x to another pointed to by r.                        *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*        1. nx is greater than 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*        void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     *
*        {                                                                  *
*            int i;                                                         *
*            for (i = 0 ; i < nx; i++)                                      *
*                r[i] = x[i];                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This implementation is Little-Endian.                    *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2*nx+ 8                                                             *
*       For nx=64, cycles=136.                                              *
*       For nx=25, cycles=58.                                               *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       96 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_blk_move

*  ======================================================================== *
*   End of file:  DSPF_dp_blk_move.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

